+ [js]
+----[admin]
+------admin-events.js
+------deals-orchestrator.js
+------deals.js
+------initializer.js
+------navigation.js
+------settings-orchestrator.js
+------settings.js
+------users-data.js
+------users-orchestrator.js
+------users-ui.js
+----admin-page.js
+----[community]
+------categories-data.js
+------categories-events.js
+------categories-navigation.js
+------categories-page.js
+------categories-ui.js
+------community-providers.js
+------providers-data.js
+------providers-events.js
+------providers-handlers.js
+------providers-page.js
+------referrals-data.js
+------referrals-page.js
+------referrals-ui.js
+----community-page.js
+----[config]
+------constants.js
+------endpoints.js
+------form-configs.js
+------menus.js
+------pages.js
+------roles.js
+------settings.js
+----[core]
+------auth.js
+------cookies.js
+------logger.js
+------markdown.js
+------mce.js
+------notifications.js
+------user.js
+----[login]
+------forgot-password.js
+------login.js
+------signup.js
+----login-page.js
+----main.js
+----[merchant]
+------api-keys-events.js
+------api-keys.js
+------documentation.js
+------navigation.js
+------products.js
+------setup.js
+------user-settings.js
+----merchant-page.js
+----[modules]
+------dataLoader.js
+------navigation.js
+------pageSetup.js
+------site-request.js
+------userSettings.js
+----[partner]
+------initializer.js
+------integrations-data.js
+------integrations-ui.js
+------integrations.js
+------navigation.js
+------partner-events.js
+----partner-page.js
+----[utils]
+------auth.js
+------data-fetch.js
+------dom-events.js
+------dom-manipulation.js
+------error.js
+------event-listeners.js
+------form-rendering.js
+------form-submission.js
+------form-validation-utils.js
+------form-validation.js
+------icons.js
+------initialization.js
+------settings-data.js
+------settings-events.js
+------settings-renderer.js
+------settings-ui.js
+------ui-components.js

admin/admin-events.js
// /static/js/admin/admin-events.js
// Purpose: Centralizes event listener setup for the admin page.

import { log } from '../core/logger.js';
import { registerEvents } from '../utils/event-listeners.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Sets up all event listeners for the admin page.
 * @param {string} context - The context or module name.
 * @returns {void}
 */
export function setupAdminEvents(context) {
  log(context, 'Setting up admin event listeners');
  withErrorHandling(`${context}:setupAdminEvents`, () => {
    registerEvents(context, [
      'formSubmit',
      'navigationToggle',
      'permissionChange',
      'modifyPermissions',
    ], {
      formId: 'settingsForm',
      endpoint: '/settings/user',
      configKey: 'userSettings',
      navToggleId: 'adminNavToggle',
      navId: 'adminNav',
    });
  }, ERROR_MESSAGES.EVENT_HANDLER_FAILED);
}

/**
 * Initializes the admin events module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Events instance with public methods.
 */
export function initializeAdminEventsModule(registry) {
  return createModuleInitializer('admin-events.js', {
    setupAdminEvents,
  });
}

// Initialize module with lifecycle logging
const context = 'admin-events.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
admin/deals-orchestrator.js
// /static/js/admin/deals-orchestrator.js
// Purpose: Orchestrates deals feature initialization for the admin interface.

import { log } from '../core/logger.js';
import { loadDeals } from './deals.js';
import { getElements } from '../utils/dom-manipulation.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Initializes the deals feature by loading and rendering deals data.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeDealsOrchestrator(context) {
  log(context, 'Initializing deals orchestrator');
  await withErrorHandling(`${context}:initializeDealsOrchestrator`, async () => {
    const elements = await getElements(context, ['dealList']);
    await loadDeals(context, elements);
  }, ERROR_MESSAGES.MODULE_INIT_FAILED);
}

/**
 * Initializes the deals orchestrator module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Deals orchestrator instance with public methods.
 */
export function initializeDealsOrchestratorModule(registry) {
  return createModuleInitializer('deals-orchestrator.js', {
    initializeDealsOrchestrator,
  });
}

// Initialize module with lifecycle logging
const context = 'deals-orchestrator.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
admin/deals.js
// /static/js/admin/deals.js
// Purpose: Manages deals data, including fetching and rendering deals in a table.

import { log } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { load as dataLoaderLoad } from '../modules/dataLoader.js';
import { fetchData } from '../utils/data-fetch.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { renderDataTable } from '../utils/ui-components.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Fetches and renders deals data in a table.
 * @param {string} context - The context or module name.
 * @param {Object} elements - DOM elements configuration object.
 * @param {HTMLElement} elements.dealList - The element to render the deals table into.
 * @returns {Promise<void>}
 */
export async function loadDeals(context, { dealList }) {
  log(context, `Loading deals data at: ${new Date().toISOString()}`);
  await withErrorHandling(`${context}:loadDeals`, async () => {
    try {
      // Fetch deals data using dataLoader (retained for compatibility)
      const data = await dataLoaderLoad(context, 'initial');
      log(context, 'Deals fetched:', data);

      // Check for error status
      if (data.status === 'error') {
        throw new Error(ERROR_MESSAGES.FETCH_FAILED('deals'));
      }

      // Prepare table data
      const headers = [
        'Category',
        'Title',
        'URL',
        'Price',
        'Original',
        'Discount',
        'Image',
        'Quantity',
      ];
      const rowMapper = (deal) => [
        deal.category || 'N/A',
        deal.title || 'N/A',
        `<a href="${deal.url || '#'}" target="_blank">Link</a>`,
        deal.price || 'N/A',
        deal.original || 'N/A',
        deal.discount || 'N/A',
        `<img src="${deal.image || ''}" alt="Product Image" style="width: 50px;" onerror="this.src='/static/images/placeholder.png';">`,
        deal.quantity || 'N/A',
      ];

      // Render deals table
      dealList.innerHTML = renderDataTable(context, {
        data: data.data,
        headers,
        rowMapper,
        emptyMessage: ERROR_MESSAGES.DEALS_NO_DATA,
      });
    } catch (err) {
      dealList.innerHTML = renderDataTable(context, {
        data: [],
        headers: [],
        rowMapper: () => [ERROR_MESSAGES.FETCH_FAILED('deals')],
        emptyMessage: ERROR_MESSAGES.FETCH_FAILED('deals'),
      });
      throw err;
    }
  }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Initializes the deals module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Deals instance with public methods.
 */
export function initializeDealsModule(registry) {
  const context = 'deals.js';
  log(context, 'Initializing deals module for module registry');
  return {
    loadDeals: (ctx, ...args) => loadDeals(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'deals.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
admin/initializer.js
// /static/js/admin/initializer.js
// Purpose: Coordinates initialization of admin feature-specific orchestrators.

import { log } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';
import { initializeDealsOrchestrator } from './deals-orchestrator.js';
import { initializeUsersOrchestrator } from './users-orchestrator.js';
import { initializeSettingsOrchestrator } from './settings-orchestrator.js';

/**
 * Initializes admin feature orchestrators for deals, users, and settings.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeAdminModules(context) {
  log(context, 'Initializing admin feature orchestrators');

  const orchestrators = [
    { name: 'deals', init: initializeDealsOrchestrator },
    { name: 'users', init: initializeUsersOrchestrator },
    { name: 'settings', init: initializeSettingsOrchestrator },
  ];

  for (const { name, init } of orchestrators) {
    await withErrorHandling(`${context}:initialize${name}`, async () => {
      await init(context);
    }, ERROR_MESSAGES.MODULE_INIT_FAILED);
  }
}

/**
 * Initializes the initializer module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Initializer instance with public methods.
 */
export function initializeInitializerModule(registry) {
  return createModuleInitializer('initializer.js', {
    initializeAdminModules,
  });
}

// Initialize module with lifecycle logging
const context = 'initializer.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
admin/navigation.js
// /static/js/admin/navigation.js
// Purpose: Defines section change handlers for the admin page.

import { log } from '../core/logger.js';
import { defineSectionHandlers } from '../modules/navigation.js';
import { loadDeals } from './deals.js';
import { initializeUserManagement } from './users-orchestrator.js';
import { loadAdminSettings } from './settings.js';
import { initializeAdminModules } from './initializer.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Defines section handlers for the admin page.
 * @param {string} context - The context or module name.
 * @returns {void}
 */
export function defineAdminSectionHandlers(context) {
  log(context, 'Defining section handlers');
  defineSectionHandlers(context, 'admin', [
    {
      id: 'user_management',
      handler: async (role) => {
        log(context, `Calling initializeUserManagement for role: ${role}`);
        await initializeUserManagement(context, role || 'admin');
        log(context, `initializeUserManagement completed for role: ${role}`);
      },
    },
    {
      id: 'affiliates',
      handler: async () => {
        log(context, 'Calling loadAdminSettings for affiliates');
        await loadAdminSettings(context, 'affiliates');
        log(context, 'loadAdminSettings completed for affiliates');
      },
    },
    {
      id: 'site_settings',
      handler: async () => {
        log(context, 'Calling initializeAdminModules');
        await initializeAdminModules(context);
        log(context, 'initializeAdminModules completed');
      },
    },
    {
      id: 'api_keys',
      handler: async () => {
        log(context, 'Calling loadAdminSettings for apiKeys');
        await loadAdminSettings(context, 'apiKeys');
        log(context, 'loadAdminSettings completed for apiKeys');
      },
    },
    {
      id: 'deals',
      handler: async () => {
        log(context, 'Calling loadDeals');
        const elements = await import('../utils/dom-manipulation.js').then(m => m.getElements(context, ['dealList']));
        await loadDeals(context, elements);
        log(context, 'loadDeals completed');
      },
    },
  ]);
}

/**
 * Initializes the navigation module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Navigation instance with public methods.
 */
export function initializeNavigationModule(registry) {
  const context = 'navigation.js';
  log(context, 'Initializing navigation module for module registry');
  return {
    defineAdminSectionHandlers: (ctx) => defineAdminSectionHandlers(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'navigation.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
admin/settings-orchestrator.js
// /static/js/admin/settings-orchestrator.js
// Purpose: Orchestrates settings feature initialization for affiliates, site settings, and API keys in the admin interface.

import { log } from '../core/logger.js';
import { loadAdminSettings } from './settings.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Initializes the settings feature for affiliates, site settings, and API keys.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeSettingsOrchestrator(context) {
  log(context, 'Initializing settings orchestrator');
  const settingsTypes = ['affiliates', 'siteSettings', 'apiKeys'];
  for (const type of settingsTypes) {
    await withErrorHandling(`${context}:initialize${type}`, async () => {
      await loadAdminSettings(context, type);
    }, ERROR_MESSAGES.MODULE_INIT_FAILED);
  }
}

/**
 * Initializes the settings orchestrator module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Settings orchestrator instance with public methods.
 */
export function initializeSettingsOrchestratorModule(registry) {
  return createModuleInitializer('settings-orchestrator.js', {
    initializeSettingsOrchestrator,
  });
}

// Initialize module with lifecycle logging
const context = 'settings-orchestrator.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
admin/settings.js
// /static/js/admin/settings.js
// Purpose: Manages loading of admin settings for affiliates, API keys, and site settings.

import { log } from '../core/logger.js';
import { renderSettingsForm } from '../utils/settings-renderer.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { SETTINGS } from '../config/settings.js';
import { withScriptLogging } from '../utils/initialization.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Loads admin settings for the specified type (e.g., affiliates, apiKeys, siteSettings).
 * @param {string} context - The context or module name.
 * @param {string} type - The type of settings to load (e.g., 'affiliates', 'apiKeys', 'siteSettings').
 * @returns {Promise<void>}
 * @throws {Error} If the settings type is unknown.
 */
export async function loadAdminSettings(context, type) {
  log(context, `Loading ${type} settings`);
  const settingsConfig = SETTINGS[type];
  if (!settingsConfig) {
    throw new Error(`Unknown settings type: ${type}`);
  }
  await renderSettingsForm(context, settingsConfig);
}

/**
 * Initializes the settings module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Settings instance with public methods.
 */
export function initializeSettingsModule(registry) {
  return createModuleInitializer('settings.js', {
    loadAdminSettings,
  });
}

// Initialize module with lifecycle logging
const context = 'settings.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
admin/users-data.js
// /static/js/admin/users-data.js
// Purpose: Manages user data fetching and permission updates for the admin interface.

import { authenticatedFetch } from '../core/auth.js';
import { log } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Fetches user data for a specific role.
 * @param {string} context - The context or module name.
 * @param {string} [role='admin'] - The role to fetch users for.
 * @returns {Promise<{users: Array, role: string}>} The user data and role.
 */
export async function loadUsers(context, role = 'admin') {
  log(context, `Fetching users for role: ${role} at: ${new Date().toISOString()}`);
  return await withErrorHandling(`${context}:loadUsers`, async () => {
    const response = await authenticatedFetch(API_ENDPOINTS.USERS_ROLE(role));
    const data = await response.json();
    log(context, `Users fetched for role ${role}:`, data);

    if (data.status === 'error') {
      throw new Error(ERROR_MESSAGES.FETCH_FAILED('users'));
    }

    if (!data.users || data.users.length === 0) {
      log(context, `No users found for role ${role}`);
      return { users: [], role };
    }

    return { users: data.users, role };
  }, ERROR_MESSAGES.FETCH_FAILED('users'));
}

/**
 * Updates a user's permission.
 * @param {string} context - The context or module name.
 * @param {string} userId - The user ID.
 * @param {string} permission - The permission to update.
 * @param {boolean} isChecked - Whether to add or remove the permission.
 * @param {string} role - The user role.
 * @returns {Promise<{userId: string, permission: string, isChecked: boolean, role: string, message: string}>} The update result.
 */
export async function updateUserPermission(context, userId, permission, isChecked, role) {
  log(context, `Updating permission ${permission} for user ${userId} (role: ${role}): ${isChecked ? 'add' : 'remove'}`);
  const method = isChecked ? 'PATCH' : 'DELETE';
  return await withErrorHandling(`${context}:updateUserPermission`, async () => {
    const response = await authenticatedFetch(API_ENDPOINTS.PERMISSION, {
      method,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ userId, permission }),
    });
    const data = await response.json();
    return { userId, permission, isChecked, role, message: data.message || 'Permission updated' };
  }, ERROR_MESSAGES.FETCH_FAILED('permission update'));
}

/**
 * Fetches user data for modifying permissions.
 * @param {string} context - The context or module name.
 * @param {string} userId - The user ID.
 * @returns {Promise<Object>} The user data.
 */
export async function fetchUserForPermissions(context, userId) {
  log(context, `Fetching user data for ${userId}`);
  return await withErrorHandling(`${context}:fetchUserForPermissions`, async () => {
    const response = await authenticatedFetch(API_ENDPOINTS.USERS_USERID(userId));
    const userData = await response.json();
    return userData;
  }, ERROR_MESSAGES.FETCH_FAILED('user details'));
}

/**
 * Initializes the users data module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Users data instance with public methods.
 */
export function initializeUsersDataModule(registry) {
  const context = 'users-data.js';
  log(context, 'Initializing users data module for module registry');
  return {
    loadUsers: (ctx, ...args) => loadUsers(ctx, ...args),
    updateUserPermission: (ctx, ...args) => updateUserPermission(ctx, ...args),
    fetchUserForPermissions: (ctx, ...args) => fetchUserForPermissions(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'users-data.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
admin/users-orchestrator.js
// /static/js/admin/users-orchestrator.js
// Purpose: Orchestrates user management for the admin interface, coordinating data, UI, and events.

import { log } from '../core/logger.js';
import { loadUsers } from './users-data.js';
import { renderUsersTable } from './users-ui.js';
import { setupAdminEvents } from './admin-events.js';
import { getElements } from '../utils/dom-manipulation.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Initializes user management for the admin interface.
 * @param {string} context - The context or module name.
 * @param {string} [role='admin'] - The role to manage users for.
 * @returns {Promise<void>}
 */
export async function initializeUserManagement(context, role = 'admin') {
  log(context, `Initializing user management for role: ${role}`);
  await withErrorHandling(`${context}:initializeUserManagement`, async () => {
    const userData = await loadUsers(context, role);
    const elements = await getElements(context, ['userManagement', 'userList']);
    await renderUsersTable(context, userData, elements);
    setupAdminEvents(context);
  }, ERROR_MESSAGES.MODULE_INIT_FAILED);
}

/**
 * Initializes the users-orchestrator module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} UsersOrchestrator instance with public methods.
 */
export function initializeUsersOrchestratorModule(registry) {
  return createModuleInitializer('users-orchestrator.js', {
    initializeUserManagement,
  });
}

// Initialize module with lifecycle logging
const context = 'users-orchestrator.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
admin/users-ui.js
// /static/js/admin/users-ui.js
// Purpose: Manages UI rendering for user management in the admin interface.

import { log, warn } from '../core/logger.js';
import { toggleViewState } from '../utils/dom-manipulation.js';
import { success, error as notifyError } from '../core/notifications.js';
import { renderCheckboxList, renderDataTable, renderModal } from '../utils/ui-components.js';
import { ROLES, SUCCESS_MESSAGES, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Renders user data in a table.
 * @param {string} context - The context or module name.
 * @param {Object} userData - The user data to render, containing users and role.
 * @param {Object} elements - DOM elements configuration object.
 * @param {HTMLElement} elements.userManagement - The user management section element.
 * @param {HTMLElement} elements.userList - The table body element to render into.
 * @returns {Promise<void>}
 */
export async function renderUsersTable(context, { users, role }, { userManagement, userList }) {
  log(context, `Rendering users for role: ${role}`);
  if (userList.tagName.toLowerCase() !== 'tbody') {
    throw new Error(ERROR_MESSAGES.INVALID_TABLE_BODY);
  }

  const parentTable = userList.closest('table');
  if (!parentTable) {
    throw new Error(ERROR_MESSAGES.TABLE_NOT_FOUND);
  }

  if (!users || users.length === 0) {
    warn(context, `No users found for role ${role}`);
    userList.innerHTML = renderDataTable(context, {
      data: [],
      headers: [],
      rowMapper: () => ['No users found'],
      emptyMessage: ERROR_MESSAGES.USERS_NO_DATA,
    });
    success(context, ERROR_MESSAGES.USERS_NO_DATA);
    return;
  }

  const allowedPermissions = ROLES[role]?.permissions || [];
  const headers = ['ID', 'Name', 'Website', 'Email', 'Phone', 'Permissions', 'Actions'];
  const rowMapper = (user) => {
    const userPermissions = Array.isArray(user.permissions) ? user.permissions : [];
    const permissionsContainer = renderCheckboxList(context, {
      items: allowedPermissions,
      name: 'permissions',
      selected: userPermissions,
      dataAttributes: { userId: user.userId, role },
      containerClass: 'permissions-list',
    }).outerHTML;
    return [
      user.userId,
      user.contactName || '',
      user.websiteUrl || '',
      user.emailAddress || '',
      user.phoneNumber || '',
      permissionsContainer,
      `<button class="modify-permissions" data-userId="${user.userId}" data-role="${role}">Modify Permissions</button>`,
    ];
  };

  userList.innerHTML = renderDataTable(context, {
    data: users,
    headers,
    rowMapper,
    emptyMessage: ERROR_MESSAGES.USERS_NO_DATA,
  });

  if (userList.children.length === 0) {
    warn(context, 'Table body empty after rendering');
    userList.innerHTML = renderDataTable(context, {
      data: [],
      headers: [],
      rowMapper: () => [ERROR_MESSAGES.USERS_RENDER_FAILED],
      emptyMessage: ERROR_MESSAGES.USERS_RENDER_FAILED,
    });
    notifyError(context, ERROR_MESSAGES.USERS_RENDER_FAILED);
  } else {
    log(context, `Successfully rendered ${userList.children.length} users`);
    success(context, SUCCESS_MESSAGES.USERS_RENDERED);
  }
}

/**
 * Renders a permissions modification modal.
 * @param {string} context - The context or module name.
 * @param {string} userId - The user ID.
 * @param {Object} userData - The user data containing permissions.
 * @param {string} role - The user role.
 * @param {string} [formId='permissionsForm'] - The ID of the form in the modal.
 * @returns {Promise<HTMLElement>} The rendered modal element.
 */
export async function renderPermissionsModal(context, userId, userData, role, formId = 'permissionsForm') {
  log(context, `Rendering modal for user ${userId} with role ${role}`);
  const allowedPermissions = ROLES[role]?.permissions || [];
  const currentPermissions = Array.isArray(userData.permissions) ? userData.permissions : [];

  const checkboxList = renderCheckboxList(context, {
    items: allowedPermissions,
    name: 'permissions',
    selected: currentPermissions,
    containerClass: 'permissions-checkboxes',
  }).outerHTML;

  const modal = await renderModal(context, {
    id: `permissionsModal-${userId}`,
    title: `Modify Permissions for User ${userId}`,
    content: checkboxList,
    formId,
    buttons: [
      { type: 'submit', text: 'Save', className: 'save' },
      { type: 'button', text: 'Cancel', className: 'cancel', onclick: 'this.closest(".modal").remove()' },
    ],
  });

  return modal;
}

/**
 * Initializes the users UI module for use with the module registry.
 * @param {Object} registry - The cdecl module registry instance.
 * @returns {Object} Users UI instance with public methods.
 */
export function initializeUsersUiModule(registry) {
  const context = 'users-ui.js';
  log(context, 'Initializing users UI module for module registry');
  return {
    renderUsersTable: (ctx, ...args) => renderUsersTable(ctx, ...args),
    renderPermissionsModal: (ctx, ...args) => renderPermissionsModal(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'users-ui.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
admin-page.js
// /static/js/admin-page.js
// Purpose: Orchestrates the admin page, coordinating navigation, events, and module initialization.

import { log } from './core/logger.js';
import { parsePageType, initializeRolePage } from './utils/initialization.js';
import { defineAdminSectionHandlers } from './admin/navigation.js';
import { setupAdminEvents } from './admin/admin-events.js';
import { initializeAdminModules } from './admin/initializer.js';
import { withScriptLogging } from './utils/initialization.js';

/**
 * Initializes the admin page.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeAdminPage(context) {
  log(context, 'Initializing admin page');
  const pageType = parsePageType(context, 'page', 'deals');
  await initializeRolePage(context, 'admin', pageType, async () => {
    defineAdminSectionHandlers(context);
    initializeAdminModules(context);
    setupAdminEvents(context);
  });
}

/**
 * Initializes the admin-page module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} AdminPage instance with public methods.
 */
export function initializeAdminPageModule(registry) {
  const context = 'admin-page.js';
  log(context, 'Initializing admin-page module for module registry');
  return {
    initializeAdminPage: ctx => initializeAdminPage(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'admin-page.js';
withScriptLogging(context, () => {
  initializeAdminPage(context);
});
community/categories-data.js
// /static/js/community/categories-data.js
// Purpose: Manages data fetching, updates, and validation for the community categories page.

import { log } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { withErrorHandling } from '../utils/error.js';
import { validateUserId } from '../utils/auth.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';
import { createModuleInitializer } from '../utils/initialization.js';

// Module-scoped state for cumulative deselections
const state = {
  cumulativeDeselections: [],
};

/**
 * Fetches categories from the server.
 * @param {string} context - The context or module name.
 * @param {string} userId - The user ID.
 * @param {boolean} [isAdmin=false] - Whether the user is an admin.
 * @returns {Promise<Object>} The categories data.
 */
export async function loadCategories(context, userId, isAdmin = false) {
  log(context, `Loading categories for user: ${userId}, isAdmin: ${isAdmin}`);
  return await withErrorHandling(`${context}:loadCategories`, async () => {
    await validateUserId(context);
    const data = await fetchData(API_ENDPOINTS.CATEGORIES, { method: 'GET' });
    return {
      categories: data.categories || {},
      deselected: data.deselected || [],
      previousDeselected: data.previousDeselected || [],
      prompt: data.prompt || '',
      selected: data.selected || [],
    };
  }, ERROR_MESSAGES.FETCH_FAILED('categories'), () => ({
    categories: {},
    deselected: [],
    previousDeselected: [],
    selected: [],
    prompt: '',
  }));
}

/**
 * Saves categories to the server.
 * @param {string} context - The context or module name.
 * @param {Object} data - The categories data to save.
 * @returns {Promise<Object>} The server response.
 */
export async function saveCategories(context, data) {
  log(context, 'Saving categories');
  return await withErrorHandling(`${context}:saveCategories`, async () => {
    return await fetchData(API_ENDPOINTS.SAVE_CATEGORIES, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
  }, ERROR_MESSAGES.FETCH_FAILED('categories save'));
}

/**
 * Resets categories for a user.
 * @param {string} context - The context or module name.
 * @param {string} userId - The user ID.
 * @returns {Promise<Object>} The server response.
 */
export async function resetCategories(context, userId) {
  log(context, `Resetting categories for user: ${userId}`);
  return await withErrorHandling(`${context}:resetCategories`, async () => {
    await validateUserId(context);
    return await fetchData(API_ENDPOINTS.RESET_CATEGORIES, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ userId }),
    });
  }, ERROR_MESSAGES.FETCH_FAILED('categories reset'));
}

/**
 * Merges new deselections with the cumulative state.
 * @param {string} context - The context or module name.
 * @param {string[]} newDeselections - The new deselections to merge.
 * @returns {string[]} The updated cumulative deselections.
 */
export function mergeDeselections(context, newDeselections) {
  if (Array.isArray(newDeselections)) {
    log(context, 'Merging new deselections:', newDeselections);
    state.cumulativeDeselections = [...new Set([...state.cumulativeDeselections, ...newDeselections])];
  }
  return state.cumulativeDeselections;
}

/**
 * Gets the current cumulative deselections.
 * @param {string} context - The context or module name.
 * @returns {string[]} The cumulative deselections.
 */
export function getCumulativeDeselections(context) {
  log(context, 'Retrieving cumulative deselections');
  return state.cumulativeDeselections;
}

/**
 * Updates deselected categories based on provided selections.
 * @param {string} context - The context or module name.
 * @param {string[]} selectedCategories - The currently selected categories.
 * @param {string[]} allCategories - All available categories.
 * @returns {Object} Updated deselected and previousDeselected arrays.
 */
export function updateDeselectedCategories(context, selectedCategories, allCategories) {
  log(context, 'Updating deselected categories');
  return withErrorHandling(`${context}:updateDeselectedCategories`, () => {
    const newDeselections = allCategories.filter(cat => !selectedCategories.includes(cat));
    mergeDeselections(context, newDeselections);
    return {
      deselected: newDeselections,
      previousDeselected: getCumulativeDeselections(context),
    };
  }, ERROR_MESSAGES.DATA_PROCESSING_FAILED, () => ({
    deselected: [],
    previousDeselected: [],
  }));
}

/**
 * Transforms categories form data for submission.
 * @param {FormData} formData - The form data.
 * @returns {Object} Transformed data for API submission.
 */
export function transformCategoriesData(formData) {
  log('categories-data.js', 'Transforming categories form data');
  return {
    prompt: formData.get('prompt')?.trim(),
    categories: JSON.parse(formData.get('categories') || '{}'),
    deselected: JSON.parse(formData.get('deselected') || '[]'),
    previousDeselected: JSON.parse(formData.get('previousDeselected') || '[]'),
    selected: formData.getAll ? formData.getAll('selected') : [],
  };
}

/**
 * Validates categories form data.
 * @param {FormData} formData - The form data.
 * @returns {boolean} True if valid, false otherwise.
 */
export function validateCategoriesData(formData) {
  log('categories-data.js', 'Validating categories form data');
  return !!formData.get('prompt')?.trim();
}

/**
 * Initializes the categories data module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Categories data instance with public methods.
 */
export function initializeCategoriesDataModule(registry) {
  return createModuleInitializer('categories-data.js', {
    loadCategories,
    saveCategories,
    resetCategories,
    mergeDeselections,
    getCumulativeDeselections,
    updateDeselectedCategories,
    transformCategoriesData,
    validateCategoriesData,
  });
}

// Initialize module with lifecycle logging
const context = 'categories-data.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
community/categories-events.js
// /static/js/community/categories-events.js
// Purpose: Manages event listeners for category form interactions on the community categories page.

import { log } from '../core/logger.js';
import { setupEventListeners } from '../utils/event-listeners.js';
import { submitConfiguredForm, updateFormState } from '../utils/form-submission.js';
import { updateDeselectedCategories } from './categories-data.js';
import { updateCategoriesSection } from './categories-ui.js';
import { withElement } from '../utils/dom-manipulation.js';
import { notifyOperationResult } from '../core/notifications.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Sets up event listeners for category form interactions.
 * @param {string} context - The context or module name.
 * @returns {void}
 */
export function setupCategoryEvents(context) {
  log(context, 'Setting up category form event listeners');
  withErrorHandling(`${context}:setupCategoryEvents`, () => {
    setupEventListeners(context, [
      // Form submission for refining categories
      {
        eventType: 'submit',
        selector: '#categoryForm',
        handler: async (event) => {
          event.preventDefault();
          await withErrorHandling(`${context}:submitCategoryForm`, async () => {
            await submitConfiguredForm(context, 'categoryForm', API_ENDPOINTS.CATEGORIES, 'categories', {
              successMessage: SUCCESS_MESSAGES.CATEGORIES_SUBMITTED,
              onSuccess: (data) => updateCategoriesSection(context, data),
              onError: (error, formData) => {
                updateCategoriesSection(context, {
                  categories: JSON.parse(formData.get('categories') || '{}'),
                  deselected: JSON.parse(formData.get('deselected') || '[]'),
                  previousDeselected: JSON.parse(formData.get('previousDeselected') || '[]'),
                  selected: formData.getAll ? formData.getAll('selected') : [],
                  prompt: formData.get('prompt') || '',
                  errorMessage: error.message,
                });
              },
            });
          }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
        },
      },
      // Form submission for saving categories
      {
        eventType: 'click',
        selector: '[data-action="save-categories"]',
        handler: async () => {
          await withErrorHandling(`${context}:saveCategories`, async () => {
            await submitConfiguredForm(context, 'categoryForm', API_ENDPOINTS.SAVE_CATEGORIES, 'categories', {
              onSuccess: (data) => updateCategoriesSection(context, data),
            });
          }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
        },
      },
      // Form submission for resetting categories
      {
        eventType: 'click',
        selector: '[data-action="reset-categories"]',
        handler: async () => {
          await withErrorHandling(`${context}:resetCategories`, async () => {
            await submitConfiguredForm(context, 'reset-categories-form', API_ENDPOINTS.RESET_CATEGORIES, 'resetCategories', {
              onSuccess: (data) => updateCategoriesSection(context, data),
            });
          }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
        },
      },
      // Checkbox change for deselected categories
      {
        eventType: 'change',
        selector: 'input[data-deselected]',
        handler: async () => {
          await withErrorHandling(`${context}:updateDeselections`, async () => {
            await withElement(context, 'deselected', async (deselectedInput) => {
              await withElement(context, 'previousDeselected', async (previousDeselectedInput) => {
                const allCategories = Array.from(document.querySelectorAll('input[name="selected"]')).map(cb => cb.value);
                const selectedCategories = Array.from(document.querySelectorAll('input[name="selected"]:checked')).map(cb => cb.value);
                const { deselected, previousDeselected } = updateDeselectedCategories(context, selectedCategories, allCategories);
                await updateFormState(context, 'categoryForm', {
                  deselected: JSON.stringify(deselected),
                  previousDeselected: JSON.stringify(previousDeselected),
                });
                log(context, 'Updated deselections:', deselected);
              });
            }, 10, 100, true);
          }, ERROR_MESSAGES.DATA_PROCESSING_FAILED);
        },
      },
    ]);
  }, ERROR_MESSAGES.EVENT_HANDLER_FAILED);
}

/**
 * Initializes the categories events module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Categories events instance with public methods.
 */
export function initializeCategoriesEventsModule(registry) {
  return createModuleInitializer('categories-events.js', {
    setupCategoryEvents,
  });
}

// Initialize module with lifecycle logging
const context = 'categories-events.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
community/categories-navigation.js
// /static/js/community/categories-navigation.js
// Purpose: Manages navigation setup for the community categories, providers, and referrals pages.

import { log } from '../core/logger.js';
import { initializeRoleNavigation } from '../utils/initialization.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Sets up navigation for the community page.
 * @param {string} context - The context or module name.
 * @param {string} role - The role associated with the page (e.g., 'community').
 * @param {string} defaultSection - The default section to show (e.g., 'categories', 'providers', 'referrals').
 * @returns {Promise<void>}
 */
export async function setupCategoriesNavigation(context, role, defaultSection) {
  log(context, `Setting up navigation for role ${role}, section ${defaultSection}`);
  await withErrorHandling(`${context}:setupCategoriesNavigation`, async () => {
    await initializeRoleNavigation(context, role, defaultSection);
  }, ERROR_MESSAGES.NAVIGATION_INIT_FAILED);
}

/**
 * Initializes the categories-navigation module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} CategoriesNavigation instance with public methods.
 */
export function initializeCategoriesNavigationModule(registry) {
  const context = 'categories-navigation.js';
  log(context, 'Initializing categories-navigation module for module registry');
  return {
    setupCategoriesNavigation: (ctx, ...args) => setupCategoriesNavigation(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'categories-navigation.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
community/categories-page.js
// /static/js/community/categories-page.js
// Purpose: Orchestrates the community categories page by coordinating data, UI, and event handling.

import { log } from '../core/logger.js';
import { loadCategories } from './categories-data.js';
import { renderCategoriesSection } from './categories-ui.js';
import { setupCategoryEvents } from './categories-events.js'; // Updated to reference correct file
import { withAuthenticatedUser } from '../utils/auth.js';
import { setupCategoriesNavigation } from './categories-navigation.js';
import { getElements } from '../utils/dom-manipulation.js';
import { initializeTinyMCE } from '../core/mce.js'; // Added for TinyMCE
import { ERROR_MESSAGES } from '../config/constants.js';
import { withErrorHandling } from '../utils/error.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Initializes the categories page.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeCategoriesPage(context) {
  log(context, 'Initializing categories page');
  await withAuthenticatedUser(async (userId) => {
    await withErrorHandling(`${context}:initializeCategoriesPage`, async () => {
      await setupCategoriesNavigation(context, 'community', 'categories');
      const data = await loadCategories(context, userId, false);
      const elements = await getElements(context, ['categoriesSection', 'categoriesForm', 'categoryError', 'promptInput']);
      await renderCategoriesSection(context, data, elements);
      setupCategoryEvents(context);
      // Initialize TinyMCE for rich text editors
      await initializeTinyMCE(context, '#aboutCommunity, #stylingDetails, #page1Content');
    }, ERROR_MESSAGES.FETCH_FAILED('categories page initialization'));
  });
}

/**
 * Initializes the categories page module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Categories page instance with public methods.
 */
export function initializeCategoriesPageModule(registry) {
  const context = 'categories-page.js';
  log(context, 'Initializing categories page module for module registry');
  return {
    initializeCategoriesPage: (ctx) => initializeCategoriesPage(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'categories-page.js';
withScriptLogging(context, () => {
  initializeCategoriesPage(context);
});
community/categories-ui.js
// /static/js/community/categories-ui.js
// Purpose: Manages UI rendering for the community categories page.

import { log, warn } from '../core/logger.js';
import { toggleViewState } from '../utils/dom-manipulation.js';
import { success, error as notifyError } from '../core/notifications.js';
import { renderForm } from '../utils/form-rendering.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { getFormConfig } from '../config/form-configs.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Validates categories data structure.
 * @param {Object} categories - The categories data.
 * @returns {boolean} True if valid, false otherwise.
 */
function isValidCategories(categories) {
  return (
    typeof categories === 'object' &&
    !Array.isArray(categories) &&
    Object.keys(categories).length > 0 &&
    Object.keys(categories).length <= 7 &&
    Object.values(categories).every(
      subcats =>
        Array.isArray(subcats) &&
        subcats.length >= 1 &&
        subcats.length <= 7 &&
        subcats.every(s => typeof s === 'string'),
    )
  );
}

/**
 * Renders the categories section UI with the provided data.
 * @param {string} context - The context or module name.
 * @param {Object} data - The categories data to render.
 * @param {Object} elements - DOM elements configuration object.
 * @param {HTMLElement} elements.categoriesSection - The categories section element.
 * @param {HTMLElement} elements.formContainer - The form container element.
 * @param {HTMLElement} elements.errorDiv - The error div element.
 * @param {HTMLElement} elements.promptInput - The prompt input element.
 * @returns {Promise<void>}
 */
export async function renderCategoriesSection(context, data, { categoriesSection, formContainer, errorDiv, promptInput }) {
  log(context, 'Rendering categories section with data:', data);
  toggleViewState(context, { [errorDiv.id]: false });
  errorDiv.textContent = '';

  if (data.errorMessage) {
    errorDiv.textContent = data.errorMessage;
    toggleViewState(context, { [errorDiv.id]: true });
    notifyError(context, data.errorMessage);
  }

  const currentPrompt = promptInput.value || data.prompt || '';
  data.categories = data.categories || {};

  const formConfig = getFormConfig(context, 'categories', {
    currentPrompt,
    deselected: data.deselected || [],
    previousDeselected: data.previousDeselected || [],
    selected: data.selected || [],
    categories: data.categories,
    isValidCategories: isValidCategories(data.categories),
  });

  formContainer.innerHTML = renderForm(formConfig);
  success(context, SUCCESS_MESSAGES.CATEGORIES_RENDERED);
}

/**
 * Updates the categories section UI with new data.
 * @param {string} context - The context or module name.
 * @param {Object} data - The categories data to update the UI with.
 * @param {Object} elements - DOM elements configuration object.
 * @param {HTMLElement} elements.categoriesSection - The categories section element.
 * @param {HTMLElement} elements.formContainer - The form container element.
 * @param {HTMLElement} elements.errorDiv - The error div element.
 * @param {HTMLElement} elements.promptInput - The prompt input element.
 * @returns {Promise<void>}
 */
export async function updateCategoriesSection(context, data, elements) {
  log(context, 'Updating categories section with data:', data);
  await renderCategoriesSection(context, data, elements);
}

/**
 * Initializes the categories UI module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Categories UI instance with public methods.
 */
export function initializeCategoriesUiModule(registry) {
  const context = 'categories-ui.js';
  log(context, 'Initializing categories UI module for module registry');
  return {
    renderCategoriesSection: (ctx, ...args) => renderCategoriesSection(ctx, ...args),
    updateCategoriesSection: (ctx, ...args) => updateCategoriesSection(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'categories-ui.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
community/community-providers.js
// /static/js/community/community-providers.js
// Purpose: Initializes the community providers sub-page.

import { log } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { withAuthenticatedUser } from '../utils/auth.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { initializeProvidersPage } from './providers-page.js';
import { setupCategoriesNavigation } from './categories-navigation.js';
import { setupCollapsibleSections } from '../utils/dom-manipulation.js'; // Added for collapsible sections
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Initializes the community providers page.
 * @param {string} context - The context or module name.
 * @returns {void}
 */
export function initializeProviders(context) {
  log(context, 'Initializing providers page');
  withErrorHandling(`${context}:initializeProviders`, () => {
    withAuthenticatedUser(async userId => {
      const userIdInput = document.getElementById('userId');
      if (userIdInput) userIdInput.value = userId;
      setupCategoriesNavigation(context, 'community', 'providers');
      initializeProvidersPage(context);
      setupCollapsibleSections(context); // Replaced window.setupCollapsibleSections
    });
  }, ERROR_MESSAGES.FETCH_FAILED('providers page initialization'));
}

/**
 * Initializes the community providers module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Community providers instance with public methods.
 */
export function initializeCommunityProvidersModule(registry) {
  const context = 'community-providers.js';
  log(context, 'Initializing community providers module for module registry');
  return {
    initializeProviders: (ctx) => initializeProviders(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'community-providers.js';
withScriptLogging(context, () => {
  initializeProviders(context);
});
community/providers-data.js
// /static/js/community/providers-data.js
// Purpose: Manages data fetching for provider settings on the community providers page.

import { log } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Loads client API settings from the server, with a fallback to hardcoded defaults.
 * @param {string} context - The context or module name.
 * @returns {Promise<Array>} The fetched or default provider settings.
 */
export async function loadClientApiSettings(context) {
  log(context, 'Loading client API settings');
  return await withErrorHandling(`${context}:loadClientApiSettings`, async () => {
    const data = await fetchData(context, API_ENDPOINTS.CLIENT_API_SETTINGS);
    return data.settings || [];
  }, ERROR_MESSAGES.FETCH_FAILED('client API settings'), () => [
    // Hardcoded fallback settings
    {
      "comment": "Wix CMS client API settings",
      "description": "Wix is a versatile website builder, offering clubmadeira.io API tools to integrate custom features into its CMS platform.",
      "doc_link": [
        { "link": "https://dev.wix.com/api/rest/wix-stores", "title": "api" },
        { "link": "https://www.wix.com/signup", "title": "signup" },
        { "link": "https://clubmadeira.io/static/md/wix_readme.md", "title": "readme" }
      ],
      "fields": { "API_TOKEN": "", "SITE_ID": "" },
      "icon": "icon-wix",
      "key_type": "wix"
    },
    {
      "comment": "WordPress CMS client API settings",
      "description": "WordPress, a popular open-source CMS, powers clubmadeira.io with extensible plugins and APIs for dynamic content management.",
      "doc_link": [
        { "link": "https://developer.wordpress.com/docs/api/", "title": "api" },
        { "link": "https://wordpress.com/start", "title": "signup" },
        { "link": "https://clubmadeira.io/static/md/wordpress_readme.md", "title": "readme" }
      ],
      "fields": { "API_KEY": "" },
      "icon": "icon-wordpress",
      "key_type": "wordpress"
    },
    {
      "comment": "Squarespace CMS client API settings",
      "description": "Squarespace provides an elegant CMS platform, integrating with clubmadeira.io via APIs for custom site enhancements.",
      "doc_link": [
        { "link": "https://developers.squarespace.com/", "title": "api" },
        { "link": "https://www.squarespace.com/signup", "title": "signup" },
        { "link": "https://clubmadeira.io/static/md/squarespace_readme.md", "title": "readme" }
      ],
      "fields": { "API_KEY": "" },
      "icon": "icon-squarespace",
      "key_type": "squarespace"
    },
    {
      "comment": "Weebly CMS client API settings",
      "description": "Weebly offers a user-friendly CMS, enabling clubmadeira.io to add custom features through its developer API.",
      "doc_link": [
        { "link": "https://www.weebly.com/developer", "title": "api" },
        { "link": "https://www.weebly.com/signup", "title": "signup" },
        { "link": "https://clubmadeira.io/static/md/weebly_readme.md", "title": "readme" }
      ],
      "fields": { "API_KEY": "" },
      "icon": "icon-weebly",
      "key_type": "weebly"
    },
    {
      "comment": "Joomla CMS client API settings",
      "description": "Joomla, an open-source CMS, supports clubmadeira.io with robust API capabilities for custom module development.",
      "doc_link": [
        { "link": "https://docs.joomla.org/Joomla_API", "title": "api" },
        { "link": "https://www.joomla.org/download.html", "title": "signup" },
        { "link": "https://clubmadeira.io/static/md/joomla_readme.md", "title": "readme" }
      ],
      "fields": { "API_KEY": "" },
      "icon": "icon-joomla",
      "key_type": "joomla"
    }
  ]);
}

/**
 * Initializes the providers-data module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} ProvidersData instance with public methods.
 */
export function initializeProvidersDataModule(registry) {
  const context = 'providers-data.js';
  log(context, 'Initializing providers-data module for module registry');
  return {
    loadClientApiSettings: ctx => loadClientApiSettings(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'providers-data.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
community/providers-events.js
// /static/js/community/providers-events.js
// Purpose: Manages UI rendering and event setup for the community providers page.

import { log } from '../core/logger.js';
import { renderSettings } from '../utils/settings-renderer.js';
import { toggleViewState } from '../utils/dom-manipulation.js';
import { renderMarkdownContent } from '../utils/form-rendering.js';
import { setupProviderEvents } from './providers-handlers.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Renders provider settings and sets up event listeners.
 * @param {string} context - The context or module name.
 * @param {Array} settings - The provider settings.
 * @param {string} containerId - The container element ID.
 * @returns {Promise<void>}
 */
export async function renderProviderSettings(context, settings, containerId) {
  log(context, 'Rendering provider settings');
  await renderSettings(context, {
    containerId,
    formId: 'providerForm',
    fieldsId: 'providerContentArea',
    settings,
    type: 'provider',
    iconClass: 'fas fa-cog',
    onIconClick: (setting, fieldsContainer, form) => {
      toggleViewState(context, { providerContentArea: true });
      Array.from(document.getElementById('providerIconsBar').children).forEach(child => {
        child.style.color = child.dataset.keyType === setting.keyType ? '#007bff' : '#C0C0C0';
      });
    },
    onReadmeClick: async setting => {
      const readmeLink = setting.docLink?.find(link => link.title === 'readme')?.link;
      if (readmeLink) {
        await renderMarkdownContent(readmeLink, `mdContent-${setting.keyType}`);
        toggleViewState(context, { [`mdContent-${setting.keyType}`]: true });
      }
    },
  });
  setupProviderEvents(context);
}

/**
 * Initializes the providers events module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Providers events instance with public methods.
 */
export function initializeProvidersEventsModule(registry) {
  const context = 'providers-events.js';
  log(context, 'Initializing providers events module for module registry');
  return {
    renderProviderSettings: (ctx, ...args) => renderProviderSettings(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'providers-events.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
community/providers-handlers.js
// /static/js/community/providers-handlers.js
// Purpose: Manages event listeners for provider form interactions on the community providers page.

import { log } from '../core/logger.js';
import { setupEventListeners } from '../utils/event-listeners.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { renderProviderSettings } from './providers-events.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Sets up event listeners for provider form interactions.
 * @param {string} context - The context or module name.
 * @returns {void}
 */
export function setupProviderEvents(context) {
  log(context, 'Setting up provider form event listeners');
  withErrorHandling(`${context}:setupProviderEvents`, () => {
    setupEventListeners(context, [
      // Form submission for provider settings
      {
        eventType: 'submit',
        selector: '#providerForm',
        handler: async (event) => {
          event.preventDefault();
          await withErrorHandling(`${context}:submitProviderForm`, async () => {
            await submitConfiguredForm(context, 'providerForm', API_ENDPOINTS.CLIENT_API_SETTINGS, 'providerSettings', {
              successMessage: SUCCESS_MESSAGES.SETTINGS_UPDATED,
              onSuccess: async (data) => {
                await renderProviderSettings(context, data.settings || [], 'providerIconsBar');
              },
              onError: (error) => {
                log(context, `Provider settings submission failed: ${error.message}`);
              },
            });
          }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
        },
      },
      // Icon click for provider settings
      {
        eventType: 'click',
        selector: '#providerIconsBar i[data-key-type]',
        handler: async (event) => {
          await withErrorHandling(`${context}:selectProviderSetting`, async () => {
            const keyType = event.target.dataset.keyType;
            log(context, `Selected provider setting: ${keyType}`);
            // Trigger rendering of specific provider settings
            const settings = await import('./providers-data.js').then(m => m.loadClientApiSettings(context));
            await renderProviderSettings(context, settings.filter(s => s.keyType === keyType), 'providerIconsBar');
          }, ERROR_MESSAGES.EVENT_HANDLER_FAILED);
        },
      },
    ]);
  }, ERROR_MESSAGES.EVENT_HANDLER_FAILED);
}

/**
 * Initializes the providers handlers module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Providers handlers instance with public methods.
 */
export function initializeProvidersHandlersModule(registry) {
  return createModuleInitializer('providers-handlers.js', {
    setupProviderEvents,
  });
}

// Initialize module with lifecycle logging
const context = 'providers-handlers.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
community/providers-page.js
// /static/js/community/providers-page.js
// Purpose: Orchestrates the community providers sub-page.

import { log } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { withAuthenticatedUser } from '../utils/auth.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { loadClientApiSettings } from './providers-data.js';
import { renderProviderSettings } from './providers-events.js';
import { setupCategoriesNavigation } from './categories-navigation.js';
import { setupCollapsibleSections } from '../utils/dom-manipulation.js'; // Added for collapsible sections
import { initializeTinyMCE } from '../core/mce.js'; // Added for TinyMCE
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Initializes the community providers page.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeProvidersPage(context) {
  log(context, 'Initializing providers page');
  await withAuthenticatedUser(async userId => {
    await withErrorHandling(`${context}:initializeProvidersPage`, async () => {
      await setupCategoriesNavigation(context, 'community', 'providers');
      const userIdInput = document.getElementById('userId');
      if (userIdInput) userIdInput.value = userId;
      const settings = await loadClientApiSettings(context);
      await renderProviderSettings(context, settings, 'providerIconsBar');
      setupCollapsibleSections(context); // Replaced window.setupCollapsibleSections
      await initializeTinyMCE(context, '#aboutCommunity, #stylingDetails, #page1Content'); // Added TinyMCE
    }, ERROR_MESSAGES.FETCH_FAILED('providers page initialization'));
  });
}

/**
 * Initializes the providers page module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Providers page instance with public methods.
 */
export function initializeProvidersPageModule(registry) {
  const context = 'providers-page.js';
  log(context, 'Initializing providers page module for module registry');
  return {
    initializeProvidersPage: (ctx) => initializeProvidersPage(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'providers-page.js';
withScriptLogging(context, () => {
  initializeProvidersPage(context);
});
community/referrals-data.js
// /static/js/community/referrals-data.js
// Purpose: Manages data fetching and processing for the community referrals page.

import { log } from '../core/logger.js';
import { authenticatedFetch } from '../core/auth.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Processes visits and orders data, splitting them by time periods.
 * @param {string} context - The context or module name.
 * @param {string} userId - The user ID.
 * @returns {Promise<{visits: Object, orders: Object}>} The processed visits and orders data.
 */
export async function processVisitsAndOrders(context, userId) {
  log(context, `Processing visits and orders for user: ${userId}`);
  return await withErrorHandling(`${context}:processVisitsAndOrders`, async () => {
    const visitsData = await loadVisits(context, userId);
    const ordersData = await loadOrders(context, userId);

    const now = new Date();
    const thisMonth = now.getMonth();
    const thisYear = now.getFullYear();

    const visits = {
      thisMonth: [],
      lastMonth: [],
      earlier: [],
    };
    visitsData.visits.forEach(visit => {
      const visitDate = new Date(visit.timestamp);
      if (visitDate.getFullYear() === thisYear && visitDate.getMonth() === thisMonth) {
        visits.thisMonth.push(visit);
      } else if (
        (visitDate.getFullYear() === thisYear && visitDate.getMonth() === thisMonth - 1) ||
        (visitDate.getFullYear() === thisYear - 1 && thisMonth === 0 && visitDate.getMonth() === 11)
      ) {
        visits.lastMonth.push(visit);
      } else {
        visits.earlier.push(visit);
      }
    });

    const orders = {
      thisMonth: [],
      lastMonth: [],
      earlier: [],
    };
    ordersData.orders.forEach(order => {
      const orderDate = new Date(order.timestamp);
      if (orderDate.getFullYear() === thisYear && orderDate.getMonth() === thisMonth) {
        orders.thisMonth.push(order);
      } else if (
        (orderDate.getFullYear() === thisYear && orderDate.getMonth() === thisMonth - 1) ||
        (orderDate.getFullYear() === thisYear - 1 && thisMonth === 0 && orderDate.getMonth() === 11)
      ) {
        orders.lastMonth.push(order);
      } else {
        orders.earlier.push(order);
      }
    });

    return { visits, orders };
  }, ERROR_MESSAGES.FETCH_FAILED('visits and orders processing'));
}

/**
 * Fetches visits data for the specified user.
 * @param {string} context - The context or module name.
 * @param {string} userId - The user ID.
 * @returns {Promise<Object>} The visits data.
 */
async function loadVisits(context, userId) {
  log(context, `Fetching visits for user: ${userId}`);
  return await withErrorHandling(`${context}:loadVisits`, async () => {
    const response = await authenticatedFetch(API_ENDPOINTS.VISITS(userId));
    const data = await response.json();
    if (data.status === 'error') {
      throw new Error(data.message || ERROR_MESSAGES.FETCH_FAILED('visits'));
    }
    return data;
  }, ERROR_MESSAGES.FETCH_FAILED('visits'));
}

/**
 * Fetches orders data for the specified user.
 * @param {string} context - The context or module name.
 * @param {string} userId - The user ID.
 * @returns {Promise<Object>} The orders data.
 */
async function loadOrders(context, userId) {
  log(context, `Fetching orders for user: ${userId}`);
  return await withErrorHandling(`${context}:loadOrders`, async () => {
    const response = await authenticatedFetch(API_ENDPOINTS.ORDERS(userId));
    const data = await response.json();
    if (data.status === 'error') {
      throw new Error(data.message || ERROR_MESSAGES.FETCH_FAILED('orders'));
    }
    return data;
  }, ERROR_MESSAGES.FETCH_FAILED('orders'));
}

/**
 * Initializes the referrals data module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Referrals data instance with public methods.
 */
export function initializeReferralsDataModule(registry) {
  const context = 'referrals-data.js';
  log(context, 'Initializing referrals data module for module registry');
  return {
    processVisitsAndOrders: (ctx, ...args) => processVisitsAndOrders(ctx, ...args),
    loadVisits: (ctx, ...args) => loadVisits(ctx, ...args),
    loadOrders: (ctx, ...args) => loadOrders(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'referrals-data.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
community/referrals-page.js
// /static/js/community/referrals-page.js
// Purpose: Orchestrates the community referrals page by coordinating data and UI updates.

import { log } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { withAuthenticatedUser } from '../utils/auth.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { processVisitsAndOrders } from './referrals-data.js';
import { updateVisitsTable, updateOrdersTable } from './referrals-ui.js';
import { setupCategoriesNavigation } from './categories-navigation.js';
import { setupCollapsibleSections } from '../utils/dom-manipulation.js'; // Added for collapsible sections
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Initializes the referrals page.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeReferralsPage(context) {
  log(context, 'Initializing referrals page');
  await withAuthenticatedUser(async userId => {
    await withErrorHandling(`${context}:initializeReferralsPage`, async () => {
      await setupCategoriesNavigation(context, 'community', 'referrals');
      const { visits, orders } = await processVisitsAndOrders(context, userId);
      updateVisitsTable(context, { visits });
      updateOrdersTable(context, { orders });
      setupCollapsibleSections(context); // Replaced window.setupCollapsibleSections
    }, ERROR_MESSAGES.FETCH_FAILED('referrals page initialization'));
  });
}

/**
 * Initializes the referrals page module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Referrals page instance with public methods.
 */
export function initializeReferralsPageModule(registry) {
  const context = 'referrals-page.js';
  log(context, 'Initializing referrals page module for module registry');
  return {
    initializeReferralsPage: (ctx) => initializeReferralsPage(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'referrals-page.js';
withScriptLogging(context, () => {
  initializeReferralsPage(context);
});
community/referrals-ui.js
// /static/js/community/referrals-ui.js
// Purpose: Manages UI rendering for the community referrals page, including visits and orders tables.

import { log } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { notifyOperationResult } from '../core/notifications.js';
import { renderDataTable } from '../utils/ui-components.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Updates the visits table with the provided data.
 * @param {string} context - The context or module name.
 * @param {Object} data - The visits data, with properties thisMonth, lastMonth, and earlier.
 * @returns {void}
 */
export function updateVisitsTable(context, data) {
  log(context, 'Updating visits table');
  withErrorHandling(`${context}:updateVisitsTable`, () => {
    const visitList = document.getElementById('visitList');
    if (!visitList) {
      throw new Error(ERROR_MESSAGES.ELEMENT_NOT_FOUND);
    }

    const headers = ['Date', 'User ID', 'Page', 'Referrer'];
    const rowMapper = visit => [
      visit.date || 'N/A',
      visit.userId || 'N/A',
      visit.page || 'N/A',
      visit.referrer || 'N/A',
    ];

    const visits = [
      ...(data.visits?.thisMonth || []),
      ...(data.visits?.lastMonth || []),
      ...(data.visits?.earlier || []),
    ];

    visitList.innerHTML = renderDataTable(context, {
      data: visits,
      headers,
      rowMapper,
      emptyMessage: ERROR_MESSAGES.NO_DATA('visits'),
    });

    notifyOperationResult(context, {
      success: true,
      message: visits.length ? `${visits.length} visits loaded` : ERROR_MESSAGES.NO_DATA('visits'),
      defaultSuccess: SUCCESS_MESSAGES.DEFAULT,
    });
  }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Updates the orders table with the provided data.
 * @param {string} context - The context or module name.
 * @param {Object} data - The orders data, with properties thisMonth, lastMonth, and earlier.
 * @returns {void}
 */
export function updateOrdersTable(context, data) {
  log(context, 'Updating orders table');
  withErrorHandling(`${context}:updateOrdersTable`, () => {
    const orderList = document.getElementById('orderList');
    if (!orderList) {
      throw new Error(ERROR_MESSAGES.ELEMENT_NOT_FOUND);
    }

    const headers = ['Order ID', 'User ID', 'Product', 'Amount', 'Date'];
    const rowMapper = order => [
      order.orderId || 'N/A',
      order.userId || 'N/A',
      order.product || 'N/A',
      order.amount || 'N/A',
      order.date || 'N/A',
    ];

    const orders = [
      ...(data.orders?.thisMonth || []),
      ...(data.orders?.lastMonth || []),
      ...(data.orders?.earlier || []),
    ];

    orderList.innerHTML = renderDataTable(context, {
      data: orders,
      headers,
      rowMapper,
      emptyMessage: ERROR_MESSAGES.NO_DATA('orders'),
    });

    notifyOperationResult(context, {
      success: true,
      message: orders.length ? `${orders.length} orders loaded` : ERROR_MESSAGES.NO_DATA('orders'),
      defaultSuccess: SUCCESS_MESSAGES.DEFAULT,
    });
  }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Initializes the referrals-ui module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} ReferralsUi instance with public methods.
 */
export function initializeReferralsUiModule(registry) {
  const context = 'referrals-ui.js';
  log(context, 'Initializing referrals-ui module for module registry');
  return {
    updateVisitsTable: (ctx, ...args) => updateVisitsTable(ctx, ...args),
    updateOrdersTable: (ctx, ...args) => updateOrdersTable(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'referrals-ui.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
community-page.js
// /static/js/community-page.js
// Purpose: Orchestrates the community page, coordinating navigation, events, and module initialization.

import { log } from './core/logger.js';
import { parsePageType, initializeRolePage } from './utils/initialization.js';
import { setupCategoriesNavigation } from './community/categories-navigation.js';
import { initializeCategoriesPage } from './community/categories-page.js';
import { initializeProvidersPage } from './community/providers-page.js';
import { initializeReferralsPage } from './community/referrals-page.js';
import { withScriptLogging } from './utils/initialization.js';

/**
 * Initializes the community page.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeCommunityPage(context) {
  log(context, 'Initializing community page');
  const pageType = parsePageType(context, 'page', 'categories');
  await initializeRolePage(context, 'community', pageType, async () => {
    setupCategoriesNavigation(context, 'community', pageType);
    switch (pageType) {
      case 'categories':
        await initializeCategoriesPage(context);
        break;
      case 'providers':
        await initializeProvidersPage(context);
        break;
      case 'referrals':
        await initializeReferralsPage(context);
        break;
      default:
        log(context, `Unknown page type: ${pageType}`);
    }
  });
}

/**
 * Initializes the community-page module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} CommunityPage instance with public methods.
 */
export function initializeCommunityPageModule(registry) {
  const context = 'community-page.js';
  log(context, 'Initializing community-page module for module registry');
  return {
    initializeCommunityPage: ctx => initializeCommunityPage(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'community-page.js';
withScriptLogging(context, () => {
  initializeCommunityPage(context);
});
config/constants.js
// /static/js/config/constants.js
// Purpose: Defines centralized constants for error and success messages used across the application.

import { log } from '../core/logger.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Error message templates with context parameterization.
 * @type {Object.<string, Function|string>}
 */
export const ERROR_MESSAGES = {
  DEFAULT: 'An unexpected error occurred. Please try again.',
  FETCH_FAILED: context => `Failed to fetch ${context} data.`,
  NO_DATA: context => `No ${context} available.`,
  RENDER_FAILED: context => `Failed to render ${context} data.`,
  ELEMENT_NOT_FOUND: 'Required DOM element not found.',
  INVALID_TABLE_BODY: 'Invalid table body element.',
  TABLE_NOT_FOUND: 'Parent table not found.',
  DATA_PROCESSING_FAILED: 'Failed to process data.',
  INVALID_SETTINGS_TYPE: 'Invalid settings type specified.',
  NO_ENDPOINT: 'No API endpoint provided.',
  INVALID_SETTINGS_DATA: 'Invalid settings data received.',
  NO_SETTINGS_FOUND: 'No settings found.',
  ALL_FIELDS_REQUIRED: 'All fields are required.',
  FORM_SUBMISSION_FAILED: 'Form submission failed.',
  FORM_VALIDATION_FAILED: 'Form validation failed.',
  CUSTOM_FIELD_RENDER_FAILED: 'Failed to render custom form fields.',
  MARKDOWN_RENDER_FAILED: 'Failed to render markdown content.',
  NAVIGATION_INIT_FAILED: 'Failed to initialize navigation.',
  MODULE_INIT_FAILED: 'Failed to initialize module.',
  USER_ID_NOT_FOUND: 'User ID not found.',
  EVENT_HANDLER_FAILED: 'Event handler failed.',
  SECTION_TOGGLE_FAILED: 'Failed to toggle section.',
  NO_DOMAIN: 'Domain is required.',
  INVALID_DOMAIN: 'Invalid domain format.',
};

/**
 * Success message templates with context parameterization.
 * @type {Object.<string, string>}
 */
export const SUCCESS_MESSAGES = {
  DEFAULT: 'Operation successful.',
  RENDERED: context => `${context} successfully rendered.`,
  SUBMITTED: context => `${context} successfully submitted.`,
  SETTINGS_UPDATED: 'Settings successfully updated.',
};

/**
 * Initializes the constants module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Constants instance with public constants.
 */
export function initializeConstantsModule(registry) {
  const context = 'constants.js';
  log(context, 'Initializing constants module for module registry');
  return {
    ERROR_MESSAGES,
    SUCCESS_MESSAGES,
  };
}

// Initialize module with lifecycle logging
const context = 'constants.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
config/endpoints.js
// /static/js/config/endpoints.js
// Purpose: Defines API endpoints for the application, centralizing all API routes for consistent usage.

import { log } from '../core/logger.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * API endpoint definitions with parameterized routes where applicable.
 * @type {Object.<string, string|Function>}
 */
export const API_ENDPOINTS = {
  // Admin endpoints
  SETTINGS_AFFILIATE: '/settings/affiliate',
  SETTINGS_API_KEY: '/settings/api-key',
  SETTINGS_KEY: '/settings/site',
  USERS_ROLE: role => `/users/role/${role}`,
  USERS_USERID: userId => `/users/${userId}`,
  PERMISSION: '/permissions',
  DEALS: '/deals',

  // Community endpoints
  CATEGORIES: '/categories',
  SAVE_CATEGORIES: '/categories/save',
  RESET_CATEGORIES: '/categories/reset',
  CLIENT_API_SETTINGS: '/settings/client_api',
  CHECK_DOMAIN: '/check-domain',
  VISITS: userId => `/visits/${userId}`,
  ORDERS: userId => `/orders/${userId}`,

  // Partner endpoints
  CLIENT_API: '/client-api',

  // User settings endpoints
  SETTINGS_USER: '/settings/user',
  UPDATE_PASSWORD: '/update-password',

  // Site request endpoint
  SITE_REQUEST: userId => `/site-request/${userId}`,

  // Merchant endpoints
  API_KEY: '/settings/api_key',
  PRODUCTS: '/settings/products',

  // Login endpoints
  LOGIN: '/',
  RESET_PASSWORD: '/reset-password',
  VERIFY_RESET_CODE: '/verify-reset-code',
  SIGNUP: '/signup',
  VERIFY_TOKEN: '/verify-token',
};

/**
 * Initializes the endpoints module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Endpoints instance with public endpoints.
 */
export function initializeEndpointsModule(registry) {
  const context = 'endpoints.js';
  log(context, 'Initializing endpoints module for module registry');
  return {
    API_ENDPOINTS,
  };
}

// Initialize module with lifecycle logging
const context = 'endpoints.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
config/form-configs.js
// /static/js/config/form-configs.js
// Purpose: Centralizes form configurations for submission and rendering.

import { log } from '../core/logger.js';
import { validateRequiredFields, validatePassword, validatePhoneNumber } from '../utils/form-validation.js';
import { renderStyles } from '../utils/rendering.js';
import { renderCheckboxList } from '../utils/ui-components.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from './constants.js';
import { withScriptLogging } from '../utils/initialization.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Generates fields for the categories form.
 * @param {string} context - The context or module name.
 * @param {Object} options - Configuration options.
 * @returns {Array} Array of field configurations.
 */
function generateCategoryFields(context, { currentPrompt = '', deselected = [], previousDeselected = [], selected = [], categories = {} }) {
  log(context, 'Generating fields for categories form');
  return [
    {
      type: 'textarea',
      id: 'prompt',
      name: 'prompt',
      label: 'Describe your club (e.g., "We are a scout group, ages 8-16")',
      value: currentPrompt,
      required: true,
      rows: 4,
      cols: 50,
      style: renderStyles(context, { width: '100%', maxWidth: '600px' }),
    },
    {
      type: 'hidden',
      id: 'deselected',
      name: 'deselected',
      value: JSON.stringify(deselected),
    },
    {
      type: 'hidden',
      id: 'previousDeselected',
      name: 'previousDeselected',
      value: JSON.stringify(previousDeselected),
    },
    {
      type: 'hidden',
      id: 'previousSelected',
      name: 'previousSelected',
      value: JSON.stringify(selected),
    },
    {
      type: 'hidden',
      id: 'categories',
      name: 'categories',
      value: JSON.stringify(categories),
    },
  ];
}

/**
 * Generates custom fields for the categories form.
 * @param {string} context - The context or module name.
 * @param {Object} options - Configuration options.
 * @returns {Array} Array of custom field configurations.
 */
function generateCategoryCustomFields(context, { deselected = [], categories = {}, isValidCategories = false }) {
  if (!isValidCategories) return [];
  return Object.entries(categories).map(([mainCat, subcats]) => ({
    type: 'checkboxList',
    items: [
      { value: mainCat, label: mainCat },
      ...subcats.map(subcat => ({ value: `${mainCat}:${subcat}`, label: subcat })),
    ],
    name: 'selected',
    selected: [
      ...(deselected.includes(mainCat) ? [] : [mainCat]),
      ...subcats.map(subcat => `${mainCat}:${subcat}`).filter(val => !deselected.includes(val)),
    ],
    dataAttributes: { deselected: true },
    containerClass: 'category-item',
    render: (items, selected) => `
      <div style="${renderStyles(context, { minWidth: '200px', flex: '1 0 auto' })}">
        <h3 style="${renderStyles(context, { fontSize: '1.2em', marginTop: '15px' })}">
          ${renderCheckboxList(context, { items: [items[0]], name: 'selected', selected, dataAttributes: { deselected: true }, containerClass: 'main-category' }).outerHTML}
        </h3>
        <ul style="${renderStyles(context, { marginLeft: '20px', listStyleType: 'none' })}">
          ${renderCheckboxList(context, { items: items.slice(1), name: 'selected', selected, dataAttributes: { deselected: true }, containerClass: 'sub-category' }).outerHTML}
        </ul>
      </div>
    `,
  }));
}

/**
 * Generates form configuration for the categories form.
 * @param {string} context - The context or module name.
 * @param {Object} options - Configuration options.
 * @returns {Object} The form configuration.
 */
export function getCategoriesFormConfig(context, options) {
  log(context, 'Generating categories form config');
  const { currentPrompt = '', deselected = [], previousDeselected = [], selected = [], categories = {}, isValidCategories = false } = options;
  const fields = generateCategoryFields(context, { currentPrompt, deselected, previousDeselected, selected, categories });
  const customFields = generateCategoryCustomFields(context, { deselected, categories, isValidCategories });

  return {
    id: 'categoryForm',
    action: '/categories',
    method: 'POST',
    fields,
    customFields,
    submitButtonText: 'Refine Categories',
    extraButtons: [
      {
        text: 'Save Categories',
        dataAction: 'save-categories',
        style: renderStyles(context, {
          marginTop: '20px',
          padding: '10px 20px',
          backgroundColor: '#28a745',
          color: 'white',
          border: 'none',
          borderRadius: '5px',
          cursor: 'pointer',
        }),
      },
      {
        text: 'Reset Categories',
        dataAction: 'reset-categories',
        style: renderStyles(context, {
          marginTop: '20px',
          padding: '10px 20px',
          backgroundColor: '#dc3545',
          color: 'white',
          border: 'none',
          borderRadius: '5px',
          cursor: 'pointer',
        }),
      },
    ],
    wrapper: isValidCategories
      ? {
          class: 'categories-container',
          style: renderStyles(context, { display: 'flex', flexWrap: 'wrap', gap: '20px' }),
        }
      : null,
  };
}

/**
 * Form configuration registry.
 * @type {Object.<string, Object>}
 */
const FORM_CONFIGS = {
  userSettings: {
    id: 'settingsForm',
    action: '/settings/user',
    method: 'PATCH',
    submitButtonText: 'Save Settings',
    successMessage: SUCCESS_MESSAGES.SETTINGS_UPDATED,
    transform: (formData) => import('../merchant/user-settings.js').then(m => m.transformUserSettings(formData)),
    validate: (formData) => import('../merchant/user-settings.js').then(m => m.validateUserSettings(formData)),
    validationError: ERROR_MESSAGES.FORM_VALIDATION_FAILED,
  },
  categories: {
    id: 'categoryForm',
    action: '/categories',
    method: 'POST',
    submitButtonText: 'Refine Categories',
    successMessage: SUCCESS_MESSAGES.SUBMITTED('Categories'),
    transform: (formData) => import('../community/categories-data.js').then(m => m.transformCategoriesData(formData)),
    validate: (formData) => import('../community/categories-data.js').then(m => m.validateCategoriesData(formData)),
    validationError: ERROR_MESSAGES.FORM_VALIDATION_FAILED,
    fetchOptions: { credentials: 'include' },
  },
  resetCategories: {
    id: 'reset-categories-form',
    action: '/reset-categories',
    method: 'POST',
    submitButtonText: 'Reset',
    successMessage: SUCCESS_MESSAGES.SUBMITTED('Categories'),
    transform: formData => ({ userId: formData.get('userId') || localStorage.getItem('userId') }),
    validate: formData => !!formData.get('userId')?.trim() || !!localStorage.getItem('userId'),
    validationError: ERROR_MESSAGES.USER_ID_NOT_FOUND,
    fetchOptions: { credentials: 'include' },
  },
  permissions: {
    id: 'permissionsForm',
    action: '/permissions',
    method: 'PATCH',
    submitButtonText: 'Save',
    successMessage: SUCCESS_MESSAGES.SETTINGS_UPDATED,
    transform: formData => ({
      permissions: Array.from(formData.getAll('permissions')),
    }),
    validate: () => true,
    validationError: ERROR_MESSAGES.FORM_VALIDATION_FAILED,
  },
  forgotPassword: {
    id: 'forgotPasswordForm',
    action: '/reset-password',
    method: 'POST',
    submitButtonText: 'Send OTP',
    successMessage: 'A one-time password has been sent to your phone.',
    transform: formData => ({
      email: formData.get('email')?.trim(),
    }),
    validate: formData => !!formData.get('email')?.trim(),
    validationError: 'Please enter your email.',
    fetchOptions: {
      headers: { 'Content-Type': 'application/json' },
    },
  },
  verifyOtp: {
    id: 'verifyOtpForm',
    action: '/verify-reset-code',
    method: 'POST',
    submitButtonText: 'Verify OTP',
    successMessage: 'Password updated successfully!',
    transform: formData => ({
      email: formData.get('email')?.trim(),
      code: formData.get('code')?.trim(),
      new_password: formData.get('newPassword'),
    }),
    validate: formData => {
      try {
        return (
          !!formData.get('email')?.trim() &&
          !!formData.get('code')?.trim() &&
          validatePassword('verifyOtp', formData, 'newPassword', 'confirmNewPassword')
        );
      } catch (err) {
        throw new Error(err.message || ERROR_MESSAGES.FORM_VALIDATION_FAILED);
      }
    },
    validationError: 'Please fill all fields correctly.',
    fetchOptions: {
      headers: { 'Content-Type': 'application/json' },
    },
  },
  signup: {
    id: 'signupForm',
    action: '/signup',
    method: 'POST',
    submitButtonText: 'Sign Up',
    successMessage: 'OTP sent to your phone. Please enter it below.',
    transform: formData => ({
      signup_type: formData.get('signup_type'),
      contact_name: formData.get('contact_name')?.trim(),
      signup_phone: formData.get('signup_phone')?.trim() || null,
      signup_email: formData.get('signup_email')?.trim(),
      signup_password: formData.get('signup_password'),
    }),
    validate: formData => {
      try {
        return (
          !!formData.get('signup_type') &&
          !!formData.get('contact_name')?.trim() &&
          !!formData.get('signup_email')?.trim() &&
          validatePassword('signup', formData, 'signup_password', 'signup_confirm_password') &&
          validatePhoneNumber('signup', formData, 'signup_phone', 'signup_type')
        );
      } catch (err) {
        throw new Error(err.message || ERROR_MESSAGES.FORM_VALIDATION_FAILED);
      }
    },
    validationError: 'Please fill all fields correctly.',
    fetchOptions: {
      headers: { 'Content-Type': 'application/json' },
    },
  },
  verifySignupOtp: {
    id: 'signupOtpSection',
    action: '/verify-reset-code',
    method: 'POST',
    submitButtonText: 'Verify OTP',
    successMessage: 'Signup verified! Redirecting to your page...',
    transform: formData => ({
      email: document.getElementById('signup_email')?.value.trim(),
      code: document.getElementById('signupOtp')?.value.trim(),
      new_password: document.getElementById('signup_password')?.value,
    }),
    validate: formData => {
      const email = document.getElementById('signup_email')?.value.trim();
      const otp = document.getElementById('signupOtp')?.value.trim();
      return !!email && !!otp;
    },
    validationError: 'Please enter both email and OTP.',
    fetchOptions: {
      headers: { 'Content-Type': 'application/json' },
    },
  },
  providerSettings: {
    id: 'providerForm',
    action: '/settings/client_api',
    method: 'PATCH',
    submitButtonText: 'Save Settings',
    successMessage: SUCCESS_MESSAGES.SETTINGS_UPDATED,
    transform: formData => ({
      fields: Object.fromEntries(formData),
    }),
    validate: formData => [...formData.values()].every(value => value.trim()),
    validationError: ERROR_MESSAGES.FORM_VALIDATION_FAILED,
    fetchOptions: {
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
    },
  },
};

/**
 * Retrieves a form configuration by key, optionally merging with dynamic options.
 * @param {string} context - The context or module name.
 * @param {string} configKey - The key for the form configuration (e.g., 'categories', 'permissions').
 * @param {Object} [options={}] - Dynamic options to merge with the configuration.
 * @returns {Object} The form configuration.
 * @throws {Error} If the configKey is invalid.
 */
export function getFormConfig(context, configKey, options = {}) {
  log(context, `Retrieving form config for key: ${configKey}`);
  const config = FORM_CONFIGS[configKey];
  if (!config) {
    throw new Error(`Invalid form configuration key: ${configKey}`);
  }
  if (configKey === 'categories' && options) {
    return getCategoriesFormConfig(context, options);
  }
  return config;
}

/**
 * Initializes the form configs module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Form configs instance with public methods.
 */
export function initializeFormConfigsModule(registry) {
  return createModuleInitializer('form-configs.js', {
    getFormConfig,
    getCategoriesFormConfig,
  });
}

// Initialize module with lifecycle logging
const context = 'form-configs.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
config/menus.js
// /static/js/config/menus.js
// Purpose: Defines menu-related utilities using centralized role definitions.

import { log } from '../core/logger.js';
import { tokenManagerDecode, authenticatedFetch, tokenManagerSetToken } from '../core/auth.js';
import { withErrorHandling } from '../utils/error.js';
import { ROLES, ADMIN_MENU } from './roles.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Checks if the user has admin permission.
 * @param {string} context - The context or module name.
 * @returns {boolean} True if the user has admin permission, false otherwise.
 */
export function hasAdminPermission(context) {
  log(context, 'Checking admin permission');
  const decoded = tokenManagerDecode();
  const hasPermission = decoded && decoded.permissions && decoded.permissions.includes('admin');
  log(context, `Admin permission: ${hasPermission}`);
  return hasPermission;
}

/**
 * Retrieves the admin menu structure.
 * @param {string} context - The context or module name.
 * @returns {Array} The admin menu configuration.
 */
export function getAdminMenu(context) {
  log(context, 'Retrieving admin menu');
  return ADMIN_MENU;
}

/**
 * Initializes the menus module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Menus instance with public methods.
 */
export function initializeMenusModule(registry) {
  const context = 'menus.js';
  log(context, 'Initializing menus module for module registry');
  return {
    hasAdminPermission: ctx => hasAdminPermission(ctx),
    getAdminMenu: ctx => getAdminMenu(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'menus.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
config/pages.js
// /static/js/config/pages.js
// Purpose: Maps page types to their corresponding module paths for dynamic imports in main.js.

import { log } from '../core/logger.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Page module mappings for dynamic imports.
 * @type {Object.<string, string[]>}
 */
export const PAGE_MODULES = {
  admin: ['./admin/admin-page.js'],
  login: ['./login-page.js'],
  merchant: ['./merchant/category-management.js', './merchant/site-request.js', './merchant/merchant-page.js'],
  partner: ['./partner/partner-page.js'],
  community: ['./community/category-management.js', './community/site-request.js', './community/community-page.js'],
};

/**
 * Initializes the pages module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Pages instance with public mappings.
 */
export function initializePagesModule(registry) {
  const context = 'pages.js';
  log(context, 'Initializing pages module for module registry');
  return {
    PAGE_MODULES,
  };
}

// Initialize module with lifecycle logging
const context = 'pages.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
config/roles.js
// /static/js/config/roles.js
// Purpose: Centralizes role definitions, permissions, and menu structures for consistent use across the application.

import { log } from '../core/logger.js';
import { authenticatedFetch, tokenManagerSetToken } from '../core/auth.js';
import { withErrorHandling } from '../utils/error.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Role definitions with associated permissions.
 * @type {Object.<string, {permissions: string[], label: string}>}
 */
export const ROLES = {
  admin: {
    permissions: ['admin', 'validated', 'debug'],
    label: 'Admin',
  },
  partner: {
    permissions: ['partner', 'validated', 'verified'],
    label: 'Partner',
  },
  community: {
    permissions: ['community', 'validated'],
    label: 'Community',
  },
  merchant: {
    permissions: ['merchant', 'validated', 'verified'],
    label: 'Merchant',
  },
};

/**
 * Menu structure for admin role.
 * @type {Array}
 */
export const ADMIN_MENU = [
  {
    section: 'userManagementIntro',
    label: 'User Management',
    icons: ['fas fa-users'],
    submenu: [
      { section: 'user_management', label: 'Admin', icons: ['icon-admin'], role: 'admin' },
      { section: 'user_management', label: 'Partners', icons: ['icon-partner'], role: 'partner' },
      { section: 'user_management', label: 'Communities', icons: ['icon-community'], role: 'community' },
      { section: 'user_management', label: 'Merchants', icons: ['icon-merchant'], role: 'merchant' },
    ],
  },
  { section: 'affiliates', label: 'Affiliate Programs', icons: ['fas fa-link'] },
  { section: 'site_settings', label: 'Site Settings', icons: ['fas fa-cog'] },
  {
    section: 'testScriptsIntro',
    label: 'Test Scripts',
    icons: ['fas fa-vial'],
    submenu: [
      {
        section: 'test_partner',
        label: 'Test Partner',
        icons: ['icon-partner', 'fas fa-vial'],
        action: async context => {
          log(context, 'Test Partner button clicked, showing overlay and calling /set-role');
          window.showLoadingOverlay?.();
          await withErrorHandling(`${context}:testPartnerAction`, async () => {
            const response = await authenticatedFetch('/set-role', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ role: 'partner' }),
            });
            if (!response.ok) {
              throw new Error(`Failed to set role: ${response.status}`);
            }
            const data = await response.json();
            log(context, 'Successfully set x-role to partner, response:', data);

            if (data.token) {
              tokenManagerSetToken(data.token);
              log(context, 'Updated token with new x-role: partner');
            }
          }, 'Failed to set partner role');
        },
      },
    ],
  },
];

/**
 * Initializes the roles module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Roles instance with public definitions.
 */
export function initializeRolesModule(registry) {
  const context = 'roles.js';
  log(context, 'Initializing roles module for module registry');
  return {
    ROLES,
    ADMIN_MENU,
  };
}

// Initialize module with lifecycle logging
const context = 'roles.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
config/settings.js
// /static/js/config/settings.js
// Purpose: Defines centralized configuration for settings across the application.

import { log } from '../core/logger.js';
import { API_ENDPOINTS } from './endpoints.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Settings configuration registry for admin and provider settings.
 * @type {Object.<string, Object>}
 */
export const SETTINGS = {
  affiliates: {
    containerId: 'affiliate-icons',
    formId: 'affiliate-form',
    fieldsId: 'affiliate-settings-container',
    endpoint: API_ENDPOINTS.SETTINGS_AFFILIATE,
    type: 'affiliate',
    iconClass: 'fas fa-link',
  },
  apiKeys: {
    containerId: 'api-keys-icons',
    formId: 'api-keys-form',
    fieldsId: 'api-keys-fields',
    endpoint: API_ENDPOINTS.SETTINGS_API_KEY,
    type: 'api-keys',
    iconClass: 'fas fa-key',
  },
  siteSettings: {
    containerId: 'site-settings-icons',
    formId: 'site-settings-form',
    fieldsId: 'site-settings-fields',
    endpoint: API_ENDPOINTS.SETTINGS_KEY,
    type: 'site-settings',
    iconClass: 'fas fa-cog',
  },
  provider: {
    containerId: 'provider-icons',
    formId: 'providerForm',
    fieldsId: 'providerContentArea',
    endpoint: API_ENDPOINTS.CLIENT_API_SETTINGS,
    type: 'provider',
    iconClass: 'fas fa-cog',
  },
};

/**
 * Retrieves a settings configuration by type.
 * @param {string} context - The context or module name.
 * @param {string} type - The type of settings (e.g., 'affiliates', 'apiKeys', 'siteSettings', 'provider').
 * @returns {Object} The settings configuration.
 * @throws {Error} If the settings type is unknown.
 */
export function getSettingsConfig(context, type) {
  log(context, `Retrieving settings config for type: ${type}`);
  const config = SETTINGS[type];
  if (!config) {
    throw new Error(`Unknown settings type: ${type}`);
  }
  return config;
}

/**
 * Initializes the settings module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Settings instance with public methods.
 */
export function initializeSettingsModule(registry) {
  const context = 'settings.js';
  log(context, 'Initializing settings module for module registry');
  return {
    SETTINGS,
    getSettingsConfig: (ctx, ...args) => getSettingsConfig(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'settings.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
core/auth.js
// /static/js/core/auth.js
// Purpose: Manages authentication-related operations, including token handling and authenticated requests.

import { log } from './logger.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Sets the authentication token in localStorage.
 * @param {string} token - The authentication token.
 */
export function tokenManagerSetToken(token) {
  const context = 'auth.js';
  log(context, 'Setting auth token');
  localStorage.setItem('authToken', token);
}

/**
 * Decodes the authentication token from localStorage.
 * @returns {Object|null} The decoded token data or null if invalid.
 */
export function tokenManagerDecode() {
  const context = 'auth.js';
  log(context, 'Decoding auth token');
  const token = localStorage.getItem('authToken');
  if (!token) {
    log(context, 'No auth token found');
    return null;
  }
  try {
    const payload = JSON.parse(atob(token.split('.')[1]));
    log(context, 'Token decoded successfully');
    return payload;
  } catch (err) {
    log(context, 'Failed to decode token:', err.message);
    return null;
  }
}

/**
 * Performs an authenticated fetch request with the auth token.
 * @param {string} context - The context or module name.
 * @param {string} url - The API endpoint URL.
 * @param {Object} [options={}] - Fetch options.
 * @returns {Promise<Response>} The fetch response.
 */
export async function authenticatedFetch(context, url, options = {}) {
  log(context, `Performing authenticated fetch to ${url}`);
  return await withErrorHandling(`${context}:authenticatedFetch`, async () => {
    const token = localStorage.getItem('authToken');
    if (!token) {
      throw new Error('No authentication token found');
    }
    const headers = {
      ...options.headers,
      Authorization: `Bearer ${token}`,
      'Content-Type': 'application/json',
    };
    const response = await fetch(url, { ...options, headers });
    if (!response.ok) {
      throw new Error(`Fetch failed: ${response.status}`);
    }
    return response;
  }, ERROR_MESSAGES.FETCH_FAILED('authenticated request'));
}

/**
 * Initializes the auth module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Auth instance with public methods.
 */
export function initializeAuthModule(registry) {
  const context = 'auth.js';
  log(context, 'Initializing auth module for module registry');
  return {
    tokenManagerSetToken,
    tokenManagerDecode,
    authenticatedFetch: (ctx, ...args) => authenticatedFetch(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'auth.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
core/cookies.js
// /static/js/core/cookies.js
// Purpose: Manages cookie operations for the application.

import { log } from './logger.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Sets a cookie with the specified name, value, and expiration days.
 * @param {string} context - The context or module name.
 * @param {string} name - The cookie name.
 * @param {string} value - The cookie value.
 * @param {number} days - The number of days until the cookie expires.
 */
export function setCookie(context, name, value, days) {
  log(context, `Setting cookie: ${name}`);
  const expires = new Date(Date.now() + days * 864e5).toUTCString();
  document.cookie = `${name}=${encodeURIComponent(value)}; expires=${expires}; path=/; SameSite=Strict`;
}

/**
 * Initializes the cookies module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Cookies instance with public methods.
 */
export function initializeCookiesModule(registry) {
  const context = 'cookies.js';
  log(context, 'Initializing cookies module for module registry');
  return {
    setCookie: (ctx, ...args) => setCookie(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'cookies.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
core/logger.js
// /static/js/core/logger.js
// Purpose: Provides centralized logging functionality for the application.

import { withScriptLogging } from '../utils/initialization.js';

/**
 * Logs a message to the console with the specified context.
 * @param {string} context - The context or module name.
 * @param {...any} args - Arguments to log.
 */
export function log(context, ...args) {
  console.log(`[${context}]`, ...args);
}

/**
 * Logs a warning to the console with the specified context.
 * @param {string} context - The context or module name.
 * @param {...any} args - Arguments to log.
 */
export function warn(context, ...args) {
  console.warn(`[${context}]`, ...args);
}

/**
 * Logs an error to the console with the specified context.
 * @param {string} context - The context or module name.
 * @param {...any} args - Arguments to log.
 */
export function error(context, ...args) {
  console.error(`[${context}]`, ...args);
}

/**
 * Initializes the logger module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Logger instance with public methods.
 */
export function initializeLoggerModule(registry) {
  const context = 'logger.js';
  log(context, 'Initializing logger module for module registry');
  return {
    log,
    warn,
    error,
  };
}

// Initialize module with lifecycle logging
const context = 'logger.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
core/markdown.js
// /static/js/core/markdown.js
// Purpose: Provides markdown rendering functionality using marked.js.

import { log } from './logger.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Renders markdown content from a URL or string.
 * @param {string} context - The context or module name.
 * @param {string} contentOrUrl - The markdown content or URL to fetch it from.
 * @returns {Promise<string>} The rendered HTML content.
 */
export async function renderMarkdown(context, contentOrUrl) {
  log(context, `Rendering markdown from: ${contentOrUrl}`);
  return await withErrorHandling(`${context}:renderMarkdown`, async () => {
    let markdownContent;
    if (contentOrUrl.startsWith('http') || contentOrUrl.startsWith('/')) {
      const response = await fetch(contentOrUrl);
      if (!response.ok) {
        throw new Error(`Failed to fetch markdown: ${response.status}`);
      }
      markdownContent = await response.text();
    } else {
      markdownContent = contentOrUrl;
    }
    // Assume marked.js is globally available
    return window.marked ? window.marked(markdownContent) : markdownContent;
  }, ERROR_MESSAGES.MARKDOWN_RENDER_FAILED);
}

/**
 * Initializes the markdown module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Markdown instance with public methods.
 */
export function initializeMarkdownModule(registry) {
  const context = 'markdown.js';
  log(context, 'Initializing markdown module for module registry');
  return {
    renderMarkdown: (ctx, ...args) => renderMarkdown(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'markdown.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
core/mce.js
// /static/js/core/mce.js
// Purpose: Initializes TinyMCE editor for rich text editing.

import { log } from './logger.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Initializes TinyMCE editor on the specified selector.
 * @param {string} context - The context or module name.
 * @param {string} selector - The CSS selector for the textarea to initialize TinyMCE on.
 * @returns {Promise<void>}
 */
export async function initializeTinyMCE(context, selector) {
  log(context, `Initializing TinyMCE on selector: ${selector}`);
  await withErrorHandling(`${context}:initializeTinyMCE`, async () => {
    if (!window.tinymce) {
      throw new Error('TinyMCE library not loaded');
    }
    await window.tinymce.init({
      selector,
      plugins: 'lists link image table code',
      toolbar: 'undo redo | bold italic | alignleft aligncenter alignright | bullist numlist outdent indent | link image',
      menubar: false,
      statusbar: false,
      height: 300,
    });
    log(context, 'TinyMCE initialized successfully');
  }, ERROR_MESSAGES.MODULE_INIT_FAILED);
}

/**
 * Initializes the TinyMCE module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} TinyMCE instance with public methods.
 */
export function initializeMceModule(registry) {
  const context = 'mce.js';
  log(context, 'Initializing TinyMCE module for module registry');
  return {
    initializeTinyMCE: (ctx, ...args) => initializeTinyMCE(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'mce.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
core/notifications.js
// /static/js/core/notifications.js
// Purpose: Manages UI notifications for success, error, and operation results.

import { log } from './logger.js';
import { withElement, toggleViewState } from '../utils/dom-manipulation.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Displays a success notification.
 * @param {string} context - The context or module name.
 * @param {string} message - The success message.
 */
export function success(context, message) {
  log(context, `Displaying success notification: ${message}`);
  withElement(context, 'notification', element => {
    element.textContent = message;
    element.classList.remove('error');
    element.classList.add('success');
    toggleViewState(context, { notification: true });
    setTimeout(() => toggleViewState(context, { notification: false }), 3000);
  }, 10, 100, false);
}

/**
 * Displays an error notification.
 * @param {string} context - The context or module name.
 * @param {string} message - The error message.
 */
export function error(context, message) {
  log(context, `Displaying error notification: ${message}`);
  withElement(context, 'notification', element => {
    element.textContent = message;
    element.classList.remove('success');
    element.classList.add('error');
    toggleViewState(context, { notification: true });
    setTimeout(() => toggleViewState(context, { notification: false }), 5000);
  }, 10, 100, false);
}

/**
 * Notifies the result of an operation, handling success or error states.
 * @param {string} context - The context or module name.
 * @param {Object} options - Notification options.
 * @param {boolean} options.success - Whether the operation was successful.
 * @param {string} options.message - The notification message.
 * @param {string} [options.defaultSuccess] - Default success message if none provided.
 * @param {string} [options.defaultError] - Default error message if none provided.
 */
export function notifyOperationResult(context, { success, message, defaultSuccess = SUCCESS_MESSAGES.DEFAULT, defaultError = ERROR_MESSAGES.DEFAULT }) {
  log(context, `Notifying operation result: ${success ? 'success' : 'error'}, message: ${message}`);
  const notificationMessage = success ? (message || defaultSuccess) : (message || defaultError);
  if (success) {
    success(context, notificationMessage);
  } else {
    error(context, notificationMessage);
  }
}

/**
 * Initializes the notifications module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Notifications instance with public methods.
 */
export function initializeNotificationsModule(registry) {
  const context = 'notifications.js';
  log(context, 'Initializing notifications module for module registry');
  return {
    success: (ctx, ...args) => success(ctx, ...args),
    error: (ctx, ...args) => error(ctx, ...args),
    notifyOperationResult: (ctx, ...args) => notifyOperationResult(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'notifications.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
core/user.js
// /static/js/core/user.js
// Purpose: Manages user-related operations, such as fetching user data and validating user IDs.

import { log } from './logger.js';
import { authenticatedFetch } from './auth.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Fetches user data for the specified user ID.
 * @param {string} context - The context or module name.
 * @param {string} userId - The user ID.
 * @returns {Promise<Object>} The user data.
 */
export async function fetchUser(context, userId) {
  log(context, `Fetching user data for userId: ${userId}`);
  return await withErrorHandling(`${context}:fetchUser`, async () => {
    const response = await authenticatedFetch(context, API_ENDPOINTS.USERS_USERID(userId));
    const data = await response.json();
    if (data.status === 'error') {
      throw new Error(data.message || ERROR_MESSAGES.FETCH_FAILED('user'));
    }
    return data;
  }, ERROR_MESSAGES.FETCH_FAILED('user'));
}

/**
 * Validates the user ID from localStorage or DOM.
 * @param {string} context - The context or module name.
 * @returns {Promise<string>} The validated user ID.
 * @throws {Error} If no valid user ID is found.
 */
export async function validateUserId(context) {
  log(context, 'Validating user ID');
  return await withErrorHandling(`${context}:validateUserId`, async () => {
    let userId = localStorage.getItem('userId');
    if (!userId) {
      const userIdInput = document.getElementById('userId');
      userId = userIdInput?.value;
      if (!userId) {
        throw new Error(ERROR_MESSAGES.USER_ID_NOT_FOUND);
      }
      localStorage.setItem('userId', userId);
    }
    log(context, `Validated user ID: ${userId}`);
    return userId;
  }, ERROR_MESSAGES.USER_ID_NOT_FOUND);
}

/**
 * Initializes the user module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} User instance with public methods.
 */
export function initializeUserModule(registry) {
  const context = 'user.js';
  log(context, 'Initializing user module for module registry');
  return {
    fetchUser: (ctx, ...args) => fetchUser(ctx, ...args),
    validateUserId: (ctx, ...args) => validateUserId(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'user.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
login/forgot-password.js
// /static/js/login/forgot-password.js
// Purpose: Orchestrates the forgot password page, handling form submissions and UI updates.

import { log } from '../core/logger.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { setupEventListeners } from '../utils/event-listeners.js';
import { withElement, toggleViewState } from '../utils/dom-manipulation.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Initializes the forgot password page.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeForgotPassword(context) {
  log(context, 'Initializing forgot password page');
  setupForgotPasswordEvents(context);
}

/**
 * Sets up event listeners for forgot password form interactions.
 * @param {string} context - The context or module name.
 */
function setupForgotPasswordEvents(context) {
  log(context, 'Setting up forgot password event listeners');
  setupEventListeners(context, [
    {
      eventType: 'submit',
      selector: '#forgotPasswordForm',
      handler: async event => {
        event.preventDefault();
        await submitConfiguredForm(context, 'forgotPasswordForm', '/reset-password', 'forgotPassword', {
          onSuccess: async () => {
            await withElement(context, 'otpSection', async section => {
              toggleViewState(context, { otpSection: true });
            });
          },
        });
      },
    },
    {
      eventType: 'submit',
      selector: '#verifyOtpForm',
      handler: async event => {
        event.preventDefault();
        await submitConfiguredForm(context, 'verifyOtpForm', '/verify-reset-code', 'verifyOtp', {
          onSuccess: () => {
            log(context, 'OTP verified, redirecting to login');
            window.location.href = '/';
          },
        });
      },
    },
  ]);
}

/**
 * Initializes the forgot password module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Forgot password instance with public methods.
 */
export function initializeForgotPasswordModule(registry) {
  const context = 'forgot-password.js';
  log(context, 'Initializing forgot password module for module registry');
  return {
    initializeForgotPassword: ctx => initializeForgotPassword(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'forgot-password.js';
withScriptLogging(context, () => {
  initializeForgotPassword(context);
});
login/login.js
// /static/js/login/login.js
// Purpose: Orchestrates the login page, handling form submission and UI updates.

import { log } from '../core/logger.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { setCookie } from '../core/cookies.js';
import { tokenManagerSetToken } from '../core/auth.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Initializes the login page.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeLogin(context) {
  log(context, 'Initializing login page');
  setupLoginEvents(context);
}

/**
 * Sets up event listeners for login form submission.
 * @param {string} context - The context or module name.
 */
function setupLoginEvents(context) {
  log(context, 'Setting up login event listeners');
  submitConfiguredForm(context, 'loginForm', '/', 'login', {
    onSuccess: data => {
      log(context, 'Login successful, setting token and cookie');
      tokenManagerSetToken(data.token);
      if (data.user_id) localStorage.setItem('userId', data.user_id);
      setCookie(context, 'authToken', data.token, 7);
      window.location.reload();
    },
  });
}

/**
 * Initializes the login module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Login instance with public methods.
 */
export function initializeLoginModule(registry) {
  const context = 'login.js';
  log(context, 'Initializing login module for module registry');
  return {
    initializeLogin: ctx => initializeLogin(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'login.js';
withScriptLogging(context, () => {
  initializeLogin(context);
});
login/signup.js
// /static/js/login/signup.js
// Purpose: Orchestrates the signup page, handling form submissions and UI updates.

import { log } from '../core/logger.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { setupFormFieldEvents } from '../utils/event-listeners.js';
import { toggleViewState } from '../utils/dom-manipulation.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Initializes the signup page.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeSignup(context) {
  log(context, 'Initializing signup page');
  setupSignupEvents(context);
}

/**
 * Sets up event listeners for signup form interactions.
 * @param {string} context - The context or module name.
 */
function setupSignupEvents(context) {
  log(context, 'Setting up signup event listeners');

  // Form submission for signup
  submitConfiguredForm(context, 'signupForm', '/signup', 'signup', {
    onSuccess: async () => {
      log(context, 'Signup successful, showing OTP section');
      toggleViewState(context, { signupOtpSection: true });
    },
  });

  // Form submission for OTP verification
  submitConfiguredForm(context, 'signupOtpSection', '/verify-reset-code', 'verifySignupOtp', {
    onSuccess: () => {
      log(context, 'OTP verified, redirecting to login');
      window.location.href = '/';
    },
  });

  // Radio button change for signup type
  setupFormFieldEvents(context, {
    selector: 'input[name="signup_type"]',
    eventType: 'change',
    handler: e => {
      document.querySelectorAll('.option').forEach(option => {
        option.classList.toggle('selected', option.contains(e.target));
      });
      log(context, 'Selected signup type:', e.target.value);
    },
  });
}

/**
 * Initializes the signup module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Signup instance with public methods.
 */
export function initializeSignupModule(registry) {
  const context = 'signup.js';
  log(context, 'Initializing signup module for module registry');
  return {
    initializeSignup: ctx => initializeSignup(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'signup.js';
withScriptLogging(context, () => {
  initializeSignup(context);
});
login-page.js
// /static/js/login-page.js
// Purpose: Orchestrates the login page, coordinating form submission and UI updates.

import { log } from './core/logger.js';
import { initializeLogin } from './login/login.js';
import { initializeSignup } from './login/signup.js';
import { initializeForgotPassword } from './login/forgot-password.js';
import { parsePageType } from './utils/initialization.js';
import { withScriptLogging } from './utils/initialization.js';

/**
 * Initializes the login page based on the page type.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeLoginPage(context) {
  log(context, 'Initializing login page');
  const pageType = parsePageType(context, 'page', 'login');
  switch (pageType) {
    case 'login':
      await initializeLogin(context);
      break;
    case 'signup':
      await initializeSignup(context);
      break;
    case 'forgot-password':
      await initializeForgotPassword(context);
      break;
    default:
      log(context, `Unknown page type: ${pageType}`);
  }
}

/**
 * Initializes the login-page module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} LoginPage instance with public methods.
 */
export function initializeLoginPageModule(registry) {
  const context = 'login-page.js';
  log(context, 'Initializing login-page module for module registry');
  return {
    initializeLoginPage: ctx => initializeLoginPage(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'login-page.js';
withScriptLogging(context, () => {
  initializeLoginPage(context);
});
main.js
// /static/js/main.js
// Purpose: Centralizes module loading and registration for the application.

import { log } from './core/logger.js';
import { withErrorHandling } from './utils/error.js';
import { PAGE_MODULES } from './config/pages.js';
import { ERROR_MESSAGES } from './config/constants.js';
import { withScriptLogging } from './utils/initialization.js';
import { createModuleInitializer } from './utils/initialization.js';

/**
 * Module registry for managing loaded modules.
 * @type {Map<string, Object>}
 */
const moduleRegistry = new Map();

/**
 * Registers a module in the registry.
 * @param {string} name - The module name.
 * @param {Object} module - The module instance.
 */
function registerModule(name, module) {
  log('main.js', `Registering module: ${name}`);
  moduleRegistry.set(name, module);
}

/**
 * Initializes all modules for the specified page type.
 * @param {string} pageType - The type of page to initialize (e.g., 'admin', 'login').
 * @returns {Promise<void>}
 */
async function initializeModules(pageType) {
  const context = 'main.js';
  log(context, `Initializing modules for page type: ${pageType}`);
  await withErrorHandling(`${context}:initializeModules`, async () => {
    const modules = PAGE_MODULES[pageType] || [];
    for (const modulePath of modules) {
      try {
        const module = await import(modulePath);
        const moduleName = modulePath.split('/').pop().replace('.js', '');
        const initializer = Object.values(module).find(val => typeof val === 'function' && val.name.startsWith('initialize'));
        if (initializer) {
          const moduleInstance = await initializer(moduleRegistry);
          registerModule(moduleName, moduleInstance);
        } else {
          log(context, `No initializer found for module: ${moduleName}`);
        }
      } catch (err) {
        log(context, `Failed to load module: ${modulePath}`, err);
      }
    }
  }, ERROR_MESSAGES.MODULE_INIT_FAILED);
}

/**
 * Initializes the application by loading modules based on the page type.
 * @returns {Promise<void>}
 */
async function initializeApplication() {
  const context = 'main.js';
  log(context, 'Initializing application');
  const pageType = new URLSearchParams(window.location.search).get('page') || 'login';
  await initializeModules(pageType);
}

/**
 * Initializes the main module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Main instance with public methods.
 */
export function initializeMainModule(registry) {
  return createModuleInitializer('main.js', {
    initializeApplication,
    registerModule,
  });
}

// Initialize module with lifecycle logging
const context = 'main.js';
withScriptLogging(context, () => {
  initializeApplication();
});
merchant/api-keys-events.js
// /static/js/merchant/api-keys-events.js
// Purpose: Manages event listeners for API key form interactions on the merchant page.

import { log } from '../core/logger.js';
import { setupEventListeners } from '../utils/event-listeners.js';
import { fetchData } from '../utils/data-fetch.js';
import { success } from '../core/notifications.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Sets up event listeners for API key form submissions.
 * @param {string} context - The context or module name.
 * @param {string} formId - The ID of the form.
 * @param {string} endpoint - The API endpoint for submission.
 * @returns {void}
 */
export function setupApiKeyEvents(context, formId, endpoint) {
  log(context, `Setting up API key event listeners for form: ${formId}`);
  setupEventListeners(context, [
    {
      eventType: 'submit',
      selector: `#${formId}`,
      handler: async e => {
        e.preventDefault();
        await withErrorHandling(`${context}:submitApiKeyForm`, async () => {
          const keyType = e.target.dataset.keyType;
          const fields = {};
          Array.from(e.target.querySelectorAll('input')).forEach(input => {
            fields[input.name] = input.value;
          });
          await fetchData(context, `${endpoint}/${keyType}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(fields),
          });
          success(context, SUCCESS_MESSAGES.SUBMITTED(`API key for ${keyType}`));
          await import('./api-keys.js').then(module => module.loadApiKeys(context));
        }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
      },
    },
  ]);
}

/**
 * Initializes the api-keys-events module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} ApiKeysEvents instance with public methods.
 */
export function initializeApiKeysEventsModule(registry) {
  const context = 'api-keys-events.js';
  log(context, 'Initializing api-keys-events module for module registry');
  return {
    setupApiKeyEvents: (ctx, ...args) => setupApiKeyEvents(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'api-keys-events.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
merchant/api-keys.js
// /static/js/merchant/api-keys.js
// Purpose: Orchestrates the API keys settings page, coordinating data fetching, UI rendering, and event setup.

import { log } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { renderSettingsFields } from '../utils/settings-ui.js';
import { setupApiKeyEvents } from './api-keys-events.js';
import { withElement, toggleViewState } from '../utils/dom-manipulation.js';
import { notifyError } from '../core/notifications.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Loads and renders API keys data.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function loadApiKeys(context) {
  log(context, 'Loading API keys');
  await withErrorHandling(`${context}:loadApiKeys`, async () => {
    await withElement(context, 'api-keys-icons', async iconsContainer => {
      await withElement(context, 'api-keys-fields', async fieldsContainer => {
        await withElement(context, 'api-keys-form', async form => {
          const data = await fetchData(API_ENDPOINTS.API_KEY, { method: 'GET' });
          if (!data.settings || data.settings.length === 0) {
            iconsContainer.innerHTML = '<p>No API keys available.</p>';
            notifyError(context, ERROR_MESSAGES.NO_DATA('API keys'));
            return;
          }
          await displayApiKeyFields(context, data.settings[0], fieldsContainer, form);
          setupApiKeyEvents(context, 'api-keys-form', API_ENDPOINTS.API_KEY);
        });
      });
    });
  }, ERROR_MESSAGES.FETCH_FAILED('API keys'));
}

/**
 * Renders API key fields for a specific setting.
 * @param {string} context - The context or module name.
 * @param {Object} setting - The API key setting data.
 * @param {HTMLElement} fieldsContainer - The container for the fields.
 * @param {HTMLElement} form - The form element.
 * @returns {Promise<void>}
 */
async function displayApiKeyFields(context, setting, fieldsContainer, form) {
  log(context, 'Rendering API key fields');
  await renderSettingsFields(context, [setting], {
    containerId: 'api-keys-icons',
    formId: 'api-keys-form',
    fieldsId: 'api-keys-fields',
    type: 'api',
    iconClass: 'fas fa-key',
    onIconClick: (setting, fieldsContainer, form) => {
      toggleViewState(context, { 'api-keys-fields': true });
    },
    onReadmeClick: async setting => {
      await renderMarkdownContent(context, setting.readmePath, `mdContent-${setting.keyType}`);
      toggleViewState(context, { [`mdContent-${setting.keyType}`]: true });
    },
  });
}

/**
 * Initializes the API keys module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} API keys instance with public methods.
 */
export function initializeApiKeysModule(registry) {
  const context = 'api-keys.js';
  log(context, 'Initializing API keys module for module registry');
  return {
    loadApiKeys: ctx => loadApiKeys(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'api-keys.js';
withScriptLogging(context, () => {
  loadApiKeys(context);
});
merchant/documentation.js
// /static/js/merchant/documentation.js
// Purpose: Manages the rendering of documentation content for the merchant page.

import { log } from '../core/logger.js';
import { renderMarkdownContent } from '../utils/form-rendering.js';
import { withElement, toggleViewState } from '../utils/dom-manipulation.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Renders documentation content from a markdown file.
 * @param {string} context - The context or module name.
 * @param {string} markdownPath - The path to the markdown file.
 * @param {string} containerId - The ID of the container to render the content in.
 * @returns {Promise<void>}
 */
export async function renderDocumentation(context, markdownPath, containerId) {
  log(context, `Rendering documentation from: ${markdownPath}`);
  await withErrorHandling(`${context}:renderDocumentation`, async () => {
    await withElement(context, containerId, async container => {
      await renderMarkdownContent(context, markdownPath, containerId);
      toggleViewState(context, { [containerId]: true });
    });
  }, ERROR_MESSAGES.MARKDOWN_RENDER_FAILED);
}

/**
 * Initializes the documentation module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Documentation instance with public methods.
 */
export function initializeDocumentationModule(registry) {
  const context = 'documentation.js';
  log(context, 'Initializing documentation module for module registry');
  return {
    renderDocumentation: (ctx, ...args) => renderDocumentation(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'documentation.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
merchant/navigation.js
// /static/js/merchant/navigation.js
// Purpose: Defines navigation handlers for the merchant page.

import { log } from '../core/logger.js';
import { defineSectionHandlers } from '../modules/navigation.js';
import { loadApiKeys } from './api-keys.js';
import { loadProducts } from './products.js';
import { loadUserSettings } from './user-settings.js';
import { renderDocumentation } from './documentation.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Defines section handlers for the merchant page.
 * @param {string} context - The context or module name.
 * @returns {void}
 */
export function defineMerchantSectionHandlers(context) {
  log(context, 'Defining merchant section handlers');
  defineSectionHandlers(context, 'merchant', [
    {
      id: 'api_keys',
      handler: async () => {
        log(context, 'Loading API keys section');
        await loadApiKeys(context);
      },
    },
    {
      id: 'products',
      handler: async () => {
        log(context, 'Loading products section');
        await loadProducts(context);
      },
    },
    {
      id: 'user_settings',
      handler: async () => {
        log(context, 'Loading user settings section');
        await loadUserSettings(context);
      },
    },
    {
      id: 'documentation',
      handler: async () => {
        log(context, 'Loading documentation section');
        await renderDocumentation(context, '/docs/merchant.md', 'documentationContent');
      },
    },
  ]);
}

/**
 * Initializes the navigation module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Navigation instance with public methods.
 */
export function initializeNavigationModule(registry) {
  const context = 'navigation.js';
  log(context, 'Initializing navigation module for module registry');
  return {
    defineMerchantSectionHandlers: ctx => defineMerchantSectionHandlers(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'navigation.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
merchant/products.js
// /static/js/merchant/products.js
// Purpose: Manages product data fetching and rendering for the merchant page.

import { log } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { renderDataTable } from '../utils/ui-components.js';
import { withElement } from '../utils/dom-manipulation.js';
import { notifyError } from '../core/notifications.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Loads and renders product data in a table.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function loadProducts(context) {
  log(context, 'Loading products');
  await withErrorHandling(`${context}:loadProducts`, async () => {
    await withElement(context, 'productList', async productList => {
      const data = await fetchData(API_ENDPOINTS.PRODUCTS, { method: 'GET' });
      if (!data.products || data.products.length === 0) {
        productList.innerHTML = '<p>No products available.</p>';
        notifyError(context, ERROR_MESSAGES.NO_DATA('products'));
        return;
      }

      const headers = ['ID', 'Name', 'Price', 'Category', 'Stock'];
      const rowMapper = product => [
        product.id || 'N/A',
        product.name || 'N/A',
        product.price || 'N/A',
        product.category || 'N/A',
        product.stock || 'N/A',
      ];

      productList.innerHTML = renderDataTable(context, {
        data: data.products,
        headers,
        rowMapper,
        emptyMessage: ERROR_MESSAGES.NO_DATA('products'),
      });
    });
  }, ERROR_MESSAGES.FETCH_FAILED('products'));
}

/**
 * Initializes the products module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Products instance with public methods.
 */
export function initializeProductsModule(registry) {
  const context = 'products.js';
  log(context, 'Initializing products module for module registry');
  return {
    loadProducts: ctx => loadProducts(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'products.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
merchant/setup.js
// /static/js/merchant/setup.js
// Purpose: Initializes merchant-specific modules and event listeners.

import { log } from '../core/logger.js';
import { withAuthenticatedUser } from '../utils/auth.js';
import { withErrorHandling } from '../utils/error.js';
import { defineMerchantSectionHandlers } from './navigation.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Initializes merchant modules and sets up navigation.
 * @param {string} context - The context or module name.
 * @param {string} pageType - The type of page to initialize (e.g., 'products', 'api_keys').
 * @returns {Promise<void>}
 */
export async function initializeMerchantModules(context, pageType) {
  log(context, `Initializing merchant modules for page type: ${pageType}`);
  await withAuthenticatedUser(async userId => {
    await withErrorHandling(`${context}:initializeMerchantModules`, async () => {
      const userIdInput = document.getElementById('userId');
      if (userIdInput) userIdInput.value = userId;
      defineMerchantSectionHandlers(context);
      window.setupCollapsibleSections?.();
    }, ERROR_MESSAGES.MODULE_INIT_FAILED);
  });
}

/**
 * Initializes the setup module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Setup instance with public methods.
 */
export function initializeSetupModule(registry) {
  const context = 'setup.js';
  log(context, 'Initializing setup module for module registry');
  return {
    initializeMerchantModules: (ctx, ...args) => initializeMerchantModules(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'setup.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
merchant/user-settings.js
// /static/js/merchant/user-settings.js
// Purpose: Manages user settings for the merchant page, including rendering, form submission, and validation.

import { log } from '../core/logger.js';
import { renderSettingsForm } from '../utils/settings-renderer.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { setupEventListeners } from '../utils/event-listeners.js';
import { withErrorHandling } from '../utils/error.js';
import { SETTINGS } from '../config/settings.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Loads and renders user settings.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function loadUserSettings(context) {
  log(context, 'Loading user settings');
  const settingsConfig = SETTINGS.userSettings || {
    containerId: 'user-settings-icons',
    formId: 'settingsForm',
    fieldsId: 'user-settings-fields',
    endpoint: '/settings/user',
    type: 'user-settings',
    iconClass: 'fas fa-user',
  };
  await withErrorHandling(`${context}:loadUserSettings`, async () => {
    await renderSettingsForm(context, settingsConfig);
    setupUserSettingsEvents(context);
  }, ERROR_MESSAGES.RENDER_FAILED('user settings'));
}

/**
 * Sets up event listeners for user settings form submission.
 * @param {string} context - The context or module name.
 */
function setupUserSettingsEvents(context) {
  log(context, 'Setting up user settings event listeners');
  setupEventListeners(context, [
    {
      eventType: 'submit',
      selector: '#settingsForm',
      handler: async event => {
        event.preventDefault();
        await withErrorHandling(`${context}:submitUserSettings`, async () => {
          await submitConfiguredForm(context, 'settingsForm', '/settings/user', 'userSettings');
        }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
      },
    },
  ]);
}

/**
 * Transforms user settings form data for submission.
 * @param {FormData} formData - The form data.
 * @returns {Object} Transformed data for API submission.
 */
export function transformUserSettings(formData) {
  log('user-settings.js', 'Transforming user settings form data');
  return {
    contactName: formData.get('contactName')?.trim(),
    emailAddress: formData.get('emailAddress')?.trim(),
    websiteUrl: formData.get('websiteUrl')?.trim() || null,
    phoneNumber: formData.get('phoneNumber')?.trim() || null,
  };
}

/**
 * Validates user settings form data.
 * @param {FormData} formData - The form data.
 * @returns {boolean} True if valid, false otherwise.
 */
export function validateUserSettings(formData) {
  log('user-settings.js', 'Validating user settings form data');
  return formData.get('contactName')?.trim() && formData.get('emailAddress')?.trim();
}

/**
 * Initializes the user settings module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} User settings instance with public methods.
 */
export function initializeUserSettingsModule(registry) {
  return createModuleInitializer('user-settings.js', {
    loadUserSettings,
    transformUserSettings,
    validateUserSettings,
  });
}

// Initialize module with lifecycle logging
const context = 'user-settings.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
merchant-page.js
// /static/js/merchant-page.js
// Purpose: Orchestrates the merchant page, coordinating navigation, events, and module initialization.

import { log } from './core/logger.js';
import { parsePageType, initializeRolePage } from './utils/initialization.js';
import { defineMerchantSectionHandlers } from './merchant/navigation.js';
import { initializeMerchantModules } from './merchant/setup.js';
import { withScriptLogging } from './utils/initialization.js';

/**
 * Initializes the merchant page.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeMerchantPage(context) {
  log(context, 'Initializing merchant page');
  const pageType = parsePageType(context, 'page', 'products');
  await initializeRolePage(context, 'merchant', pageType, async () => {
    defineMerchantSectionHandlers(context);
    await initializeMerchantModules(context, pageType);
  });
}

/**
 * Initializes the merchant-page module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} MerchantPage instance with public methods.
 */
export function initializeMerchantPageModule(registry) {
  const context = 'merchant-page.js';
  log(context, 'Initializing merchant-page module for module registry');
  return {
    initializeMerchantPage: ctx => initializeMerchantPage(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'merchant-page.js';
withScriptLogging(context, () => {
  initializeMerchantPage(context);
});
modules/dataLoader.js
// /static/js/modules/dataLoader.js
// Purpose: Provides a centralized data loading utility for fetching data from API endpoints.

import { log } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Loads data from the specified endpoint, retained for compatibility with existing modules.
 * @param {string} context - The context or module name.
 * @param {string} endpoint - The API endpoint to fetch data from.
 * @returns {Promise<Object>} The fetched data.
 */
export async function load(context, endpoint) {
  log(context, `Loading data from endpoint: ${endpoint}`);
  return await withErrorHandling(`${context}:load`, async () => {
    const data = await fetchData(endpoint, { method: 'GET' });
    if (data.status === 'error') {
      throw new Error(ERROR_MESSAGES.FETCH_FAILED(endpoint));
    }
    return data;
  }, ERROR_MESSAGES.FETCH_FAILED(endpoint));
}

/**
 * Initializes the dataLoader module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} DataLoader instance with public methods.
 */
export function initializeDataLoaderModule(registry) {
  const context = 'dataLoader.js';
  log(context, 'Initializing dataLoader module for module registry');
  return {
    load: (ctx, ...args) => load(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'dataLoader.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
modules/navigation.js
// /static/js/modules/navigation.js
// Purpose: Provides utilities for defining navigation section handlers across pages.

import { log } from '../core/logger.js';
import { withElement, toggleViewState } from '../utils/dom-manipulation.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Defines section handlers for a specific role and triggers the appropriate handler.
 * @param {string} context - The context or module name.
 * @param {string} role - The role associated with the page (e.g., 'admin', 'partner').
 * @param {Array<{id: string, handler: Function}>} handlers - Array of section handlers.
 * @returns {void}
 */
export function defineSectionHandlers(context, role, handlers) {
  log(context, `Defining section handlers for role: ${role}`);
  withErrorHandling(`${context}:defineSectionHandlers`, () => {
    const sections = document.querySelectorAll('.section-link');
    sections.forEach(section => {
      section.addEventListener('click', async event => {
        event.preventDefault();
        const sectionId = section.dataset.section;
        const handler = handlers.find(h => h.id === sectionId)?.handler;
        if (handler) {
          log(context, `Activating section: ${sectionId} for role: ${role}`);
          await withElement(context, sectionId, async () => {
            toggleViewState(context, { [sectionId]: true });
            await handler(role);
          });
        } else {
          log(context, `No handler found for section: ${sectionId}`);
        }
      });
    });
  }, ERROR_MESSAGES.NAVIGATION_INIT_FAILED);
}

/**
 * Initializes the navigation module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Navigation instance with public methods.
 */
export function initializeNavigationModule(registry) {
  const context = 'navigation.js';
  log(context, 'Initializing navigation module for module registry');
  return {
    defineSectionHandlers: (ctx, ...args) => defineSectionHandlers(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'navigation.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
modules/pageSetup.js
// /static/js/modules/pageSetup.js
// Purpose: Provides utilities for setting up page-specific configurations and navigation.

import { log } from '../core/logger.js';
import { parsePageType } from '../utils/initialization.js';
import { withAuthenticatedUser } from '../utils/auth.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Sets up a page with role-based navigation and user authentication.
 * @param {string} context - The context or module name.
 * @param {string} role - The role associated with the page (e.g., 'admin', 'merchant').
 * @param {string} defaultSection - The default section to show.
 * @param {Function} setupCallback - Callback to execute after setup.
 * @returns {Promise<void>}
 */
export async function setupPage(context, role, defaultSection, setupCallback) {
  log(context, `Setting up page for role: ${role}, default section: ${defaultSection}`);
  await withAuthenticatedUser(async userId => {
    await withErrorHandling(`${context}:setupPage`, async () => {
      const userIdInput = document.getElementById('userId');
      if (userIdInput) userIdInput.value = userId;
      await setupCallback();
      window.setupCollapsibleSections?.();
    }, ERROR_MESSAGES.MODULE_INIT_FAILED);
  });
}

/**
 * Initializes the pageSetup module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} PageSetup instance with public methods.
 */
export function initializePageSetupModule(registry) {
  const context = 'pageSetup.js';
  log(context, 'Initializing pageSetup module for module registry');
  return {
    setupPage: (ctx, ...args) => setupPage(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'pageSetup.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
modules/site-request.js
// /static/js/modules/site-request.js
// Purpose: Manages site request form submission and UI updates.

import { log } from '../core/logger.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { setupEventListeners } from '../utils/event-listeners.js';
import { withAuthenticatedUser } from '../utils/auth.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Initializes the site request form and event listeners.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeSiteRequest(context) {
  log(context, 'Initializing site request');
  await withAuthenticatedUser(async userId => {
    await withErrorHandling(`${context}:initializeSiteRequest`, async () => {
      setupSiteRequestEvents(context, userId);
    }, ERROR_MESSAGES.MODULE_INIT_FAILED);
  });
}

/**
 * Sets up event listeners for site request form submission.
 * @param {string} context - The context or module name.
 * @param {string} userId - The user ID.
 */
function setupSiteRequestEvents(context, userId) {
  log(context, 'Setting up site request event listeners');
  setupEventListeners(context, [
    {
      eventType: 'submit',
      selector: '#siteRequestForm',
      handler: async event => {
        event.preventDefault();
        await submitConfiguredForm(context, 'siteRequestForm', API_ENDPOINTS.SITE_REQUEST(userId), 'siteRequest', {
          onSuccess: data => {
            log(context, 'Site request submitted successfully:', data);
          },
        });
      },
    },
  ]);
}

/**
 * Initializes the site-request module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} SiteRequest instance with public methods.
 */
export function initializeSiteRequestModule(registry) {
  const context = 'site-request.js';
  log(context, 'Initializing site-request module for module registry');
  return {
    initializeSiteRequest: ctx => initializeSiteRequest(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'site-request.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
modules/userSettings.js
// /static/js/modules/userSettings.js
// Purpose: Manages user settings form submission and UI rendering.

import { log } from '../core/logger.js';
import { renderSettings } from '../utils/settings-renderer.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { setupEventListeners } from '../utils/event-listeners.js';
import { SETTINGS } from '../config/settings.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Loads and renders user settings.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function loadUserSettings(context) {
  log(context, 'Loading user settings');
  const settingsConfig = SETTINGS.userSettings || {
    containerId: 'userSettingsIcons',
    formId: 'userSettingsForm',
    fieldsId: 'userSettingsFields',
    endpoint: '/settings/user',
    type: 'user-settings',
    iconClass: 'fas fa-user',
  };
  await renderSettings(context, settingsConfig);
  setupUserSettingsEvents(context);
}

/**
 * Sets up event listeners for user settings form submission.
 * @param {string} context - The context or module name.
 */
function setupUserSettingsEvents(context) {
  log(context, 'Setting up user settings event listeners');
  setupEventListeners(context, [
    {
      eventType: 'submit',
      selector: '#userSettingsForm',
      handler: async event => {
        event.preventDefault();
        await submitConfiguredForm(context, 'userSettingsForm', '/settings/user', 'userSettings');
      },
    },
  ]);
}

/**
 * Initializes the userSettings module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} UserSettings instance with public methods.
 */
export function initializeUserSettingsModule(registry) {
  const context = 'userSettings.js';
  log(context, 'Initializing userSettings module for module registry');
  return {
    loadUserSettings: ctx => loadUserSettings(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'userSettings.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
partner/initializer.js
// /static/js/partner/initializer.js
// Purpose: Initializes partner-specific modules and navigation for the partner page.

import { log } from '../core/logger.js';
import { withAuthenticatedUser } from '../utils/auth.js';
import { withErrorHandling } from '../utils/error.js';
import { definePartnerSectionHandlers } from './navigation.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Initializes partner modules and sets up navigation.
 * @param {string} context - The context or module name.
 * @param {string} pageType - The type of page to initialize (e.g., 'integrations').
 * @returns {Promise<void>}
 */
export async function initializePartnerModules(context, pageType) {
  log(context, `Initializing partner modules for page type: ${pageType}`);
  await withAuthenticatedUser(async userId => {
    await withErrorHandling(`${context}:initializePartnerModules`, async () => {
      const userIdInput = document.getElementById('userId');
      if (userIdInput) userIdInput.value = userId;
      definePartnerSectionHandlers(context);
      window.setupCollapsibleSections?.();
    }, ERROR_MESSAGES.MODULE_INIT_FAILED);
  });
}

/**
 * Initializes the initializer module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Initializer instance with public methods.
 */
export function initializeInitializerModule(registry) {
  const context = 'initializer.js';
  log(context, 'Initializing initializer module for module registry');
  return {
    initializePartnerModules: (ctx, ...args) => initializePartnerModules(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'initializer.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
partner/integrations-data.js
// /static/js/partner/integrations-data.js
// Purpose: Manages data fetching for integration settings on the partner page.

import { log } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Loads integration settings from the server.
 * @param {string} context - The context or module name.
 * @returns {Promise<Array>} The fetched integration settings.
 */
export async function loadIntegrations(context) {
  log(context, 'Loading integration settings');
  return await withErrorHandling(`${context}:loadIntegrations`, async () => {
    const data = await fetchData(context, API_ENDPOINTS.CLIENT_API);
    return data.settings || [];
  }, ERROR_MESSAGES.FETCH_FAILED('integrations'), () => []);
}

/**
 * Initializes the integrations-data module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} IntegrationsData instance with public methods.
 */
export function initializeIntegrationsDataModule(registry) {
  const context = 'integrations-data.js';
  log(context, 'Initializing integrations-data module for module registry');
  return {
    loadIntegrations: ctx => loadIntegrations(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'integrations-data.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
partner/integrations-ui.js
// /static/js/partner/integrations-ui.js
// Purpose: Manages UI rendering for integration settings on the partner page.

import { log } from '../core/logger.js';
import { renderSettingsForm } from '../utils/settings-renderer.js';
import { toggleViewState } from '../utils/dom-manipulation.js';
import { renderMarkdownContent } from '../utils/form-rendering.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Renders integration settings based on the provided data and container.
 * @param {string} context - The context or module name.
 * @param {Array} settings - The integration settings data.
 * @param {string} containerId - The ID of the container to render into.
 * @returns {Promise<void>}
 */
export async function renderIntegrations(context, settings, containerId) {
  log(context, `Rendering integration settings in container: ${containerId}`);
  await withErrorHandling(`${context}:renderIntegrations`, async () => {
    await renderSettingsForm(context, {
      containerId,
      formId: 'integrationsForm',
      fieldsId: 'integrationsFields',
      settings,
      type: 'integrations',
      endpoint: '/client-api',
      iconClass: 'fas fa-plug',
      onIconClick: (setting, fieldsContainer, form) => {
        toggleViewState(context, { integrationsFields: true });
        Array.from(document.getElementById(containerId).children).forEach(child => {
          child.style.color = child.dataset.keyType === setting.keyType ? '#007bff' : '#C0C0C0';
        });
      },
      onReadmeClick: async setting => {
        const readmeLink = setting.docLink?.find(link => link.title === 'readme')?.link;
        if (readmeLink) {
          await renderMarkdownContent(context, readmeLink, `mdContent-${setting.keyType}`);
          toggleViewState(context, { [`mdContent-${setting.keyType}`]: true });
        }
      },
    });
  }, ERROR_MESSAGES.RENDER_FAILED('integrations'));
}

/**
 * Initializes the integrations-ui module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} IntegrationsUi instance with public methods.
 */
export function initializeIntegrationsUiModule(registry) {
  return createModuleInitializer('integrations-ui.js', {
    renderIntegrations,
  });
}

// Initialize module with lifecycle logging
const context = 'integrations-ui.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
partner/integrations.js
// /static/js/partner/integrations.js
// Purpose: Orchestrates the integrations settings page, coordinating data fetching, UI rendering, and event setup.

import { log } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { loadIntegrations } from './integrations-data.js';
import { renderIntegrations } from './integrations-ui.js';
import { setupPartnerEvents } from './partner-events.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Loads and renders integration settings.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function loadIntegrationsSettings(context) {
  log(context, 'Loading integration settings');
  await withErrorHandling(`${context}:loadIntegrationsSettings`, async () => {
    const settings = await loadIntegrations(context);
    await renderIntegrations(context, settings, 'integrationsIconsBar');
    setupPartnerEvents(context);
  }, ERROR_MESSAGES.FETCH_FAILED('integrations'));
}

/**
 * Initializes the integrations module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Integrations instance with public methods.
 */
export function initializeIntegrationsModule(registry) {
  const context = 'integrations.js';
  log(context, 'Initializing integrations module for module registry');
  return {
    loadIntegrationsSettings: ctx => loadIntegrationsSettings(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'integrations.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
partner/navigation.js
// /static/js/partner/navigation.js
// Purpose: Defines navigation handlers for the partner page.

import { log } from '../core/logger.js';
import { defineSectionHandlers } from '../modules/navigation.js';
import { loadIntegrationsSettings } from './integrations.js';
import { withScriptLogging } from '../utils/initialization.js';

/**
 * Defines section handlers for the partner page.
 * @param {string} context - The context or module name.
 * @returns {void}
 */
export function definePartnerSectionHandlers(context) {
  log(context, 'Defining partner section handlers');
  defineSectionHandlers(context, 'partner', [
    {
      id: 'integrations',
      handler: async () => {
        log(context, 'Loading integrations section');
        await loadIntegrationsSettings(context);
      },
    },
  ]);
}

/**
 * Initializes the navigation module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Navigation instance with public methods.
 */
export function initializeNavigationModule(registry) {
  const context = 'navigation.js';
  log(context, 'Initializing navigation module for module registry');
  return {
    definePartnerSectionHandlers: ctx => definePartnerSectionHandlers(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'navigation.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
partner/partner-events.js
// /static/js/partner/partner-events.js
// Purpose: Manages top-level event listeners for the partner page, delegating feature-specific events.

import { log } from '../core/logger.js';
import { setupEventListeners } from '../utils/event-listeners.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { toggleViewState } from '../utils/dom-manipulation.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Sets up top-level event listeners for the partner page.
 * @param {string} context - The context or module name.
 * @returns {void}
 */
export function setupPartnerEvents(context) {
  log(context, 'Setting up partner event listeners');
  withErrorHandling(`${context}:setupPartnerEvents`, () => {
    setupEventListeners(context, [
      {
        eventType: 'submit',
        selector: '#integrationsForm',
        handler: async event => {
          event.preventDefault();
          await withErrorHandling(`${context}:submitIntegrationsForm`, async () => {
            await submitConfiguredForm(context, 'integrationsForm', '/client-api', 'integrations', {
              successMessage: SUCCESS_MESSAGES.SETTINGS_UPDATED,
              onSuccess: () => {
                log(context, 'Integration settings updated');
                toggleViewState(context, { integrationsFields: true });
              },
            });
          }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
        },
      },
      {
        eventType: 'click',
        selector: '#partnerNavToggle',
        handler: async () => {
          await withErrorHandling(`${context}:toggleNavigation`, async () => {
            log(context, 'Toggling partner navigation');
            toggleViewState(context, { partnerNav: true });
          }, ERROR_MESSAGES.SECTION_TOGGLE_FAILED);
        },
      },
    ]);
  }, ERROR_MESSAGES.EVENT_HANDLER_FAILED);
}

/**
 * Initializes the partner events module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Events instance with public methods.
 */
export function initializePartnerEventsModule(registry) {
  return createModuleInitializer('partner-events.js', {
    setupPartnerEvents,
  });
}

// Initialize module with lifecycle logging
const context = 'partner-events.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
partner-page.js
// /static/js/partner-page.js
// Purpose: Orchestrates the partner page, coordinating navigation, events, and module initialization.

import { log } from './core/logger.js';
import { parsePageType, initializeRolePage } from './utils/initialization.js';
import { definePartnerSectionHandlers } from './partner/navigation.js';
import { setupPartnerEvents } from './partner/partner-events.js';
import { initializePartnerModules } from './partner/initializer.js';
import { withScriptLogging } from './utils/initialization.js';

/**
 * Initializes the partner page.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializePartnerPage(context) {
  log(context, 'Initializing partner page');
  const pageType = parsePageType(context, 'page', 'integrations');
  await initializeRolePage(context, 'partner', pageType, async () => {
    definePartnerSectionHandlers(context);
    initializePartnerModules(context, pageType);
    setupPartnerEvents(context);
  });
}

/**
 * Initializes the partner-page module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} PartnerPage instance with public methods.
 */
export function initializePartnerPageModule(registry) {
  const context = 'partner-page.js';
  log(context, 'Initializing partner-page module for module registry');
  return {
    initializePartnerPage: ctx => initializePartnerPage(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'partner-page.js';
withScriptLogging(context, () => {
  initializePartnerPage(context);
});
utils/auth.js
// /static/js/utils/auth.js
// Purpose: Provides authentication utilities for validating user sessions and roles.

import { log } from '../core/logger.js';
import { tokenManagerDecode } from '../core/auth.js';
import { validateUserId } from '../core/user.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from './initialization.js';

/**
 * Executes a callback if the user is authenticated.
 * @param {Function} callback - The callback to execute with the user ID.
 * @returns {Promise<void>}
 */
export async function withAuthenticatedUser(callback) {
  const context = 'auth.js';
  log(context, 'Checking authenticated user');
  await withErrorHandling(`${context}:withAuthenticatedUser`, async () => {
    const userId = await validateUserId(context);
    const decoded = tokenManagerDecode();
    if (!decoded) {
      throw new Error('No valid authentication token found');
    }
    await callback(userId);
  }, ERROR_MESSAGES.USER_ID_NOT_FOUND);
}

/**
 * Initializes the auth utilities module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Auth utilities instance with public methods.
 */
export function initializeAuthModule(registry) {
  const context = 'auth.js';
  log(context, 'Initializing auth utilities module for module registry');
  return {
    withAuthenticatedUser,
  };
}

// Initialize module with lifecycle logging
const context = 'auth.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/data-fetch.js
// /static/js/utils/data-fetch.js
// Purpose: Provides a centralized utility for fetching data from API endpoints.

import { log } from '../core/logger.js';
import { authenticatedFetch } from '../core/auth.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from './initialization.js';

/**
 * Fetches data from the specified endpoint with optional fetch options.
 * @param {string} context - The context or module name.
 * @param {string} endpoint - The API endpoint URL.
 * @param {Object} [options={}] - Fetch options (e.g., method, headers, body).
 * @returns {Promise<Object>} The fetched data.
 */
export async function fetchData(context, endpoint, options = {}) {
  log(context, `Fetching data from endpoint: ${endpoint}`);
  return await withErrorHandling(`${context}:fetchData`, async () => {
    const response = await authenticatedFetch(context, endpoint, options);
    const data = await response.json();
    if (data.status === 'error') {
      throw new Error(data.message || ERROR_MESSAGES.FETCH_FAILED(endpoint));
    }
    return data;
  }, ERROR_MESSAGES.FETCH_FAILED(endpoint));
}

/**
 * Initializes the data-fetch module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} DataFetch instance with public methods.
 */
export function initializeDataFetchModule(registry) {
  const context = 'data-fetch.js';
  log(context, 'Initializing data-fetch module for module registry');
  return {
    fetchData: (ctx, ...args) => fetchData(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'data-fetch.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/dom-events.js
// /static/js/utils/dom-events.js
// Purpose: Provides utilities for managing DOM events.

import { log } from '../core/logger.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from './initialization.js';

/**
 * Registers a single DOM event listener with error handling.
 * @param {string} context - The context or module name.
 * @param {string} eventType - The event type (e.g., 'click', 'submit').
 * @param {string} selector - The CSS selector for the target element.
 * @param {Function} handler - The event handler function.
 * @returns {void}
 */
export function registerEventListener(context, eventType, selector, handler) {
  log(context, `Registering ${eventType} event listener for selector: ${selector}`);
  withErrorHandling(`${context}:registerEventListener`, () => {
    const elements = document.querySelectorAll(selector);
    if (elements.length === 0) {
      log(context, `No elements found for selector: ${selector}`);
      return;
    }
    elements.forEach(element => {
      element.addEventListener(eventType, async event => {
        await withErrorHandling(`${context}:eventHandler`, () => handler(event), ERROR_MESSAGES.EVENT_HANDLER_FAILED);
      });
    });
  }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Initializes the dom-events module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} DomEvents instance with public methods.
 */
export function initializeDomEventsModule(registry) {
  const context = 'dom-events.js';
  log(context, 'Initializing dom-events module for module registry');
  return {
    registerEventListener: (ctx, ...args) => registerEventListener(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'dom-events.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/dom-manipulation.js
// /static/js/utils/dom-manipulation.js
// Purpose: Provides utilities for DOM manipulation with retry logic and visibility toggling.

import { log } from '../core/logger.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from './initialization.js';

// Cache for DOM elements to reduce repeated queries
const elementCache = new Map();

/**
 * Executes a callback with a DOM element, retrying if the element is not found.
 * @param {string} context - The context or module name.
 * @param {string} elementId - The ID of the DOM element.
 * @param {Function} callback - The callback to execute with the element.
 * @param {number} [maxAttempts=10] - Maximum retry attempts.
 * @param {number} [retryDelay=100] - Delay between retries in milliseconds.
 * @param {boolean} [checkVisibility=false] - Whether to check element visibility.
 * @returns {Promise<void>}
 */
export async function withElement(context, elementId, callback, maxAttempts = 10, retryDelay = 100, checkVisibility = false) {
  log(context, `Accessing element: ${elementId}`);
  if (elementCache.has(elementId)) {
    log(context, `Using cached element: ${elementId}`);
    return await callback(elementCache.get(elementId));
  }
  return await withErrorHandling(`${context}:withElement`, async () => {
    const element = await waitForElement(context, elementId, maxAttempts, retryDelay);
    if (checkVisibility && element.offsetParent === null) {
      throw new Error(`Element ${elementId} is not visible`);
    }
    elementCache.set(elementId, element);
    return await callback(element);
  }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Fetches multiple DOM elements and returns them as an object.
 * @param {string} context - The context or module name.
 * @param {string[]} elementIds - Array of DOM element IDs to fetch.
 * @param {number} [maxAttempts=10] - Maximum retry attempts.
 * @param {number} [retryDelay=100] - Delay between retries in milliseconds.
 * @returns {Promise<Object>} Object mapping element IDs to DOM elements.
 */
export async function getElements(context, elementIds, maxAttempts = 10, retryDelay = 100) {
  log(context, `Fetching elements: ${elementIds.join(', ')}`);
  return await withErrorHandling(`${context}:getElements`, async () => {
    const elements = {};
    for (const id of elementIds) {
      if (elementCache.has(id)) {
        elements[id] = elementCache.get(id);
        continue;
      }
      const element = await waitForElement(context, id, maxAttempts, retryDelay);
      elementCache.set(id, element);
      elements[id] = element;
    }
    return elements;
  }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Waits for a DOM element to be available, retrying if not found.
 * @param {string} context - The context or module name.
 * @param {string} elementId - The ID of the DOM element.
 * @param {number} maxAttempts - Maximum retry attempts.
 * @param {number} retryDelay - Delay between retries in milliseconds.
 * @returns {Promise<HTMLElement>} The found element.
 */
async function waitForElement(context, elementId, maxAttempts, retryDelay) {
  log(context, `Waiting for element: ${elementId}`);
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    const element = document.getElementById(elementId);
    if (element) {
      log(context, `Element found: ${elementId}`);
      return element;
    }
    log(context, `Element not found, attempt ${attempt}/${maxAttempts}`);
    await new Promise(resolve => setTimeout(resolve, retryDelay));
  }
  throw new Error(`Element ${elementId} not found after ${maxAttempts} attempts`);
}

/**
 * Toggles the visibility of elements based on a state object.
 * @param {string} context - The context or module name.
 * @param {Object.<string, boolean>} state - Object mapping element IDs to visibility states.
 * @returns {void}
 */
export function toggleViewState(context, state) {
  log(context, 'Toggling view state:', state);
  withErrorHandling(`${context}:toggleViewState`, () => {
    Object.entries(state).forEach(([elementId, isVisible]) => {
      const element = document.getElementById(elementId);
      if (element) {
        element.style.display = isVisible ? '' : 'none';
        log(context, `Set ${elementId} display to ${isVisible ? 'visible' : 'hidden'}`);
      } else {
        log(context, `Element not found for toggle: ${elementId}`);
      }
    });
  }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Sets up event listeners for collapsible sections.
 * @param {string} context - The context or module name.
 * @returns {void}
 */
export function setupCollapsibleSections(context) {
  log(context, 'Setting up collapsible sections');
  withErrorHandling(`${context}:setupCollapsibleSections`, () => {
    const toggleSections = document.querySelectorAll('.toggle-section');
    toggleSections.forEach(section => {
      section.addEventListener('click', () => {
        const targetId = section.getAttribute('data-toggle');
        const targetContent = document.getElementById(targetId);
        if (targetContent) {
          const isOpen = targetContent.classList.contains('open');
          const parentSection = section.closest('.section');
          if (parentSection) {
            parentSection.querySelectorAll('.toggle-content.open').forEach(content => {
              content.classList.remove('open');
              content.style.display = 'none';
            });
          }
          if (!isOpen) {
            targetContent.classList.add('open');
            targetContent.style.display = 'block';
          }
        } else {
          log(context, `Target content not found for ID: ${targetId}`);
        }
      });
    });
  }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Initializes the dom-manipulation module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} DomManipulation instance with public methods.
 */
export function initializeDomManipulationModule(registry) {
  const context = 'dom-manipulation.js';
  log(context, 'Initializing dom-manipulation module for module registry');
  return {
    withElement: (ctx, ...args) => withElement(ctx, ...args),
    getElements: (ctx, ...args) => getElements(ctx, ...args),
    toggleViewState: (ctx, ...args) => toggleViewState(ctx, ...args),
    setupCollapsibleSections: (ctx) => setupCollapsibleSections(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'dom-manipulation.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/error.js
// /static/js/utils/error.js
// Purpose: Provides centralized error handling utilities.

import { log, error as logError } from '../core/logger.js';
import { notifyError } from '../core/notifications.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from './initialization.js';

/**
 * Executes a callback with error handling, logging errors and notifying the user.
 * @param {string} context - The context or module name.
 * @param {Function} callback - The callback to execute.
 * @param {string} [defaultErrorMessage=ERROR_MESSAGES.DEFAULT] - The default error message.
 * @param {Function} [onError] - Optional callback to execute on error.
 * @returns {Promise<any>} The result of the callback or default value on error.
 */
export async function withErrorHandling(context, callback, defaultErrorMessage = ERROR_MESSAGES.DEFAULT, onError) {
  log(context, `Executing with error handling`);
  try {
    return await callback();
  } catch (err) {
    const errorMessage = err.message || defaultErrorMessage;
    logError(context, `Error: ${errorMessage}`);
    notifyError(context, errorMessage);
    if (onError) {
      onError(err);
    }
    throw err;
  }
}

/**
 * Initializes the error module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Error instance with public methods.
 */
export function initializeErrorModule(registry) {
  const context = 'error.js';
  log(context, 'Initializing error module for module registry');
  return {
    withErrorHandling: (ctx, ...args) => withErrorHandling(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'error.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/event-listeners.js
// /static/js/utils/event-listeners.js
// Purpose: Provides utilities for setting up DOM event listeners.

import { log } from '../core/logger.js';
import { registerEventListener } from './dom-events.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/initialization.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Event configuration registry for common event patterns.
 * @type {Object.<string, Object>}
 */
const EVENT_CONFIGS = {
  formSubmit: {
    eventType: 'submit',
    selector: '#{formId}',
    handler: async (context, event, formId, endpoint, configKey, options) => {
      event.preventDefault();
      const { submitConfiguredForm } = await import('../utils/form-submission.js');
      await withErrorHandling(`${context}:formSubmit`, () => submitConfiguredForm(context, formId, endpoint, configKey, options), ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
    },
  },
  navigationToggle: {
    eventType: 'click',
    selector: '#{navToggleId}',
    handler: async (context, event, navId) => {
      const { toggleViewState } = await import('./dom-manipulation.js');
      await withErrorHandling(`${context}:navigationToggle`, () => {
        log(context, `Toggling navigation: ${navId}`);
        toggleViewState(context, { [navId]: true });
      }, ERROR_MESSAGES.SECTION_TOGGLE_FAILED);
    },
  },
  permissionChange: {
    eventType: 'change',
    selector: '#userList input[data-userId][data-permission]',
    handler: async (context, event) => {
      const { updateUserPermission } = await import('../admin/users-data.js');
      const { userId, permission, role } = event.target.dataset;
      const isChecked = event.target.checked;
      await withErrorHandling(`${context}:permissionChange`, async () => {
        log(context, `Processing permission change for user ${userId}, permission ${permission}, role ${role}`);
        await updateUserPermission(context, userId, permission, isChecked, role);
      }, ERROR_MESSAGES.FETCH_FAILED('permission update'), () => {
        event.target.checked = !isChecked; // Revert checkbox on error
      });
    },
  },
  modifyPermissions: {
    eventType: 'click',
    selector: '#userList .modify-permissions',
    handler: async (context, event) => {
      const { fetchUserForPermissions } = await import('../admin/users-data.js');
      const { renderPermissionsModal } = await import('../admin/users-ui.js');
      const { setupAdminEvents } = await import('../admin/admin-events.js');
      const { userId, role } = event.target.dataset;
      await withErrorHandling(`${context}:modifyPermissions`, async () => {
        log(context, `Initiating permissions modification for user ${userId}, role ${role}`);
        const userData = await fetchUserForPermissions(context, userId);
        await renderPermissionsModal(context, userId, userData, role);
        setupAdminEvents(context); // Re-apply modal events
      }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
    },
  },
  categoryCheckboxChange: {
    eventType: 'change',
    selector: 'input[data-deselected]',
    handler: async (context, event) => {
      const { updateDeselectedCategories } = await import('../community/categories-data.js');
      const { updateFormState } = await import('../utils/form-submission.js');
      const { withElement } = await import('./dom-manipulation.js');
      await withErrorHandling(`${context}:categoryCheckboxChange`, async () => {
        await withElement(context, 'deselected', async (deselectedInput) => {
          await withElement(context, 'previousDeselected', async (previousDeselectedInput) => {
            const allCategories = Array.from(document.querySelectorAll('input[name="selected"]')).map(cb => cb.value);
            const selectedCategories = Array.from(document.querySelectorAll('input[name="selected"]:checked')).map(cb => cb.value);
            const { deselected, previousDeselected } = updateDeselectedCategories(context, selectedCategories, allCategories);
            await updateFormState(context, 'categoryForm', {
              deselected: JSON.stringify(deselected),
              previousDeselected: JSON.stringify(previousDeselected),
            });
            log(context, 'Updated deselections:', deselected);
          });
        }, 10, 100, true);
      }, ERROR_MESSAGES.DATA_PROCESSING_FAILED);
    },
  },
};

/**
 * Sets up multiple event listeners based on the provided configurations.
 * @param {string} context - The context or module name.
 * @param {Array<{eventType: string, selector: string, handler: Function}>} listeners - Array of listener configurations.
 * @returns {void}
 */
export function setupEventListeners(context, listeners) {
  log(context, 'Setting up event listeners');
  withErrorHandling(`${context}:setupEventListeners`, () => {
    listeners.forEach(({ eventType, selector, handler }) => {
      registerEventListener(context, eventType, selector, async event => {
        await withErrorHandling(`${context}:eventHandler`, () => handler(event), ERROR_MESSAGES.EVENT_HANDLER_FAILED);
      });
    });
  }, ERROR_MESSAGES.EVENT_HANDLER_FAILED);
}

/**
 * Registers event listeners from the event configuration registry.
 * @param {string} context - The context or module name.
 * @param {Array<string>} configKeys - Array of event configuration keys.
 * @param {Object} [params={}] - Parameters to customize selectors and handlers.
 * @returns {void}
 */
export function registerEvents(context, configKeys, params = {}) {
  log(context, `Registering events: ${configKeys.join(', ')}`);
  withErrorHandling(`${context}:registerEvents`, () => {
    configKeys.forEach(key => {
      const config = EVENT_CONFIGS[key];
      if (!config) {
        log(context, `Event configuration not found: ${key}`);
        return;
      }
      let selector = config.selector;
      if (selector.includes('{')) {
        selector = selector.replace(/{(\w+)}/g, (_, param) => params[param] || '');
      }
      registerEventListener(context, config.eventType, selector, async event => {
        await withErrorHandling(`${context}:${key}`, () => config.handler(context, event, ...Object.values(params)), ERROR_MESSAGES.EVENT_HANDLER_FAILED);
      });
    });
  }, ERROR_MESSAGES.EVENT_HANDLER_FAILED);
}

/**
 * Sets up event listeners for form field interactions (e.g., radio buttons, checkboxes).
 * @param {string} context - The context or module name.
 * @param {Object} config - Configuration object.
 * @returns {void}
 */
export function setupFormFieldEvents(context, { selector, eventType, handler }) {
  log(context, `Setting up form field events for selector: ${selector}`);
  registerEventListener(context, eventType, selector, async event => {
    await withErrorHandling(`${context}:formFieldEvent`, () => handler(event), ERROR_MESSAGES.EVENT_HANDLER_FAILED);
  });
}

/**
 * Initializes the event-listeners module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} EventListeners instance with public methods.
 */
export function initializeEventListenersModule(registry) {
  return createModuleInitializer('event-listeners.js', {
    setupEventListeners,
    registerEvents,
    setupFormFieldEvents,
  });
}

// Initialize module with lifecycle logging
const context = 'event-listeners.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/form-rendering.js
// /static/js/utils/form-rendering.js
// Purpose: Provides utilities for rendering form elements based on configurations.

import { log } from '../core/logger.js';
import { renderMarkdown } from '../core/markdown.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from './initialization.js';

/**
 * Renders a form based on the provided configuration.
 * @param {Object} config - Form configuration object.
 * @returns {string} The rendered HTML form.
 */
export function renderForm(config) {
  const context = 'form-rendering.js';
  log(context, 'Rendering form with config:', config.id);
  return withErrorHandling(`${context}:renderForm`, () => {
    const { id, action, method = 'POST', fields = [], customFields = [], submitButtonText = 'Submit', extraButtons = [], wrapper } = config;
    const fieldHtml = fields
      .map(field => {
        switch (field.type) {
          case 'textarea':
            return `
              <div>
                <label for="${field.id}">${field.label || ''}</label>
                <textarea id="${field.id}" name="${field.name}" ${field.required ? 'required' : ''} rows="${field.rows || 4}" cols="${field.cols || 50}" style="${field.style || ''}">${field.value || ''}</textarea>
              </div>
            `;
          case 'hidden':
            return `<input type="hidden" id="${field.id}" name="${field.name}" value="${field.value || ''}">`;
          default:
            return `<input type="${field.type}" id="${field.id}" name="${field.name}" value="${field.value || ''}" ${field.required ? 'required' : ''} style="${field.style || ''}">`;
        }
      })
      .join('');

    const customFieldHtml = customFields
      .map(field => {
        if (field.type === 'checkboxList' && field.render) {
          return field.render(field.items, field.selected);
        }
        return '';
      })
      .join('');

    const buttonsHtml = `
      <button type="submit">${submitButtonText}</button>
      ${extraButtons.map(btn => `<button type="${btn.type || 'button'}" data-action="${btn.dataAction || ''}" style="${btn.style || ''}">${btn.text}</button>`).join('')}
    `;

    const wrapperStyle = wrapper ? `class="${wrapper.class || ''}" style="${wrapper.style || ''}"` : '';
    return `
      <form id="${id}" action="${action}" method="${method}" ${wrapperStyle}>
        ${fieldHtml}
        ${customFieldHtml}
        ${buttonsHtml}
      </form>
    `;
  }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
}

/**
 * Renders markdown content into a container.
 * @param {string} context - The context or module name.
 * @param {string} markdownPath - The path to the markdown file.
 * @param {string} targetId - The ID of the container to render into.
 * @returns {Promise<void>}
 */
export async function renderMarkdownContent(context, markdownPath, targetId) {
  log(context, `Rendering markdown content into: ${targetId}`);
  await withErrorHandling(`${context}:renderMarkdownContent`, async () => {
    const htmlContent = await renderMarkdown(context, markdownPath);
    const target = document.getElementById(targetId);
    if (!target) {
      throw new Error(`Target element ${targetId} not found`);
    }
    target.innerHTML = htmlContent;
  }, ERROR_MESSAGES.MARKDOWN_RENDER_FAILED);
}

/**
 * Initializes the form-rendering module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} FormRendering instance with public methods.
 */
export function initializeFormRenderingModule(registry) {
  const context = 'form-rendering.js';
  log(context, 'Initializing form-rendering module for module registry');
  return {
    renderForm,
    renderMarkdownContent: (ctx, ...args) => renderMarkdownContent(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'form-rendering.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/form-submission.js
// /static/js/utils/form-submission.js
// Purpose: Provides utilities for handling form submissions with validation and error handling.

import { log } from '../core/logger.js';
import { fetchData } from './data-fetch.js';
import { getFormConfig } from '../config/form-configs.js';
import { success, error as notifyError } from '../core/notifications.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from './initialization.js';

/**
 * Submits a form based on the provided configuration key and endpoint.
 * @param {string} context - The context or module name.
 * @param {string} formId - The ID of the form element.
 * @param {string} endpoint - The API endpoint to submit to.
 * @param {string} configKey - The form configuration key (e.g., 'login', 'userSettings').
 * @param {Object} [options={}] - Additional options (e.g., onSuccess, onError, successMessage).
 * @returns {Promise<void>}
 */
export async function submitConfiguredForm(context, formId, endpoint, configKey, options = {}) {
  log(context, `Submitting form: ${formId} with config: ${configKey}`);
  await withErrorHandling(`${context}:submitConfiguredForm`, async () => {
    const form = document.getElementById(formId);
    if (!form) {
      throw new Error(`Form ${formId} not found`);
    }

    const config = getFormConfig(context, configKey);
    const formData = new FormData(form);
    if (!config.validate(formData)) {
      notifyError(context, config.validationError || ERROR_MESSAGES.FORM_VALIDATION_FAILED);
      return;
    }

    const transformedData = config.transform ? config.transform(formData) : Object.fromEntries(formData);
    const fetchOptions = {
      method: config.method || 'POST',
      headers: config.fetchOptions?.headers || {},
      body: JSON.stringify(transformedData),
      ...config.fetchOptions,
    };

    try {
      const response = await fetchData(context, endpoint, fetchOptions);
      success(context, options.successMessage || config.successMessage || 'Form submitted successfully');
      if (options.onSuccess) {
        options.onSuccess(response);
      }
    } catch (err) {
      notifyError(context, err.message || ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
      if (options.onError) {
        options.onError(err, formData);
      }
      throw err;
    }
  }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
}

/**
 * Updates form field values dynamically.
 * @param {string} context - The context or module name.
 * @param {string} formId - The ID of the form element.
 * @param {Object} updates - Object mapping field names to values.
 * @returns {Promise<void>}
 */
export async function updateFormState(context, formId, updates) {
  log(context, `Updating form state for: ${formId}`);
  await withErrorHandling(`${context}:updateFormState`, async () => {
    const form = document.getElementById(formId);
    if (!form) {
      throw new Error(`Form ${formId} not found`);
    }
    Object.entries(updates).forEach(([name, value]) => {
      const input = form.querySelector(`[name="${name}"]`);
      if (input) {
        input.value = value;
        log(context, `Updated ${name} to: ${value}`);
      }
    });
  }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Initializes the form-submission module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} FormSubmission instance with public methods.
 */
export function initializeFormSubmissionModule(registry) {
  const context = 'form-submission.js';
  log(context, 'Initializing form-submission module for module registry');
  return {
    submitConfiguredForm: (ctx, ...args) => submitConfiguredForm(ctx, ...args),
    updateFormState: (ctx, ...args) => updateFormState(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'form-submission.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/form-validation-utils.js
// /static/js/utils/form-validation-utils.js
// Purpose: Provides helper functions for form validation.

import { log } from '../core/logger.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from './initialization.js';

/**
 * Checks if a form field is empty.
 * @param {string} context - The context or module name.
 * @param {string} value - The field value.
 * @returns {boolean} True if the field is empty, false otherwise.
 */
export function isEmpty(context, value) {
  log(context, `Checking if value is empty: ${value}`);
  return !value || value.trim() === '';
}

/**
 * Validates an email address format.
 * @param {string} context - The context or module name.
 * @param {string} email - The email address to validate.
 * @returns {boolean} True if the email is valid, false otherwise.
 */
export function isValidEmail(context, email) {
  log(context, `Validating email: ${email}`);
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return withErrorHandling(`${context}:isValidEmail`, () => emailRegex.test(email), ERROR_MESSAGES.FORM_VALIDATION_FAILED);
}

/**
 * Initializes the form-validation-utils module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} FormValidationUtils instance with public methods.
 */
export function initializeFormValidationUtilsModule(registry) {
  const context = 'form-validation-utils.js';
  log(context, 'Initializing form-validation-utils module for module registry');
  return {
    isEmpty: (ctx, ...args) => isEmpty(ctx, ...args),
    isValidEmail: (ctx, ...args) => isValidEmail(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'form-validation-utils.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/form-validation.js
// /static/js/utils/form-validation.js
// Purpose: Provides form validation utilities for common form fields.

import { log } from '../core/logger.js';
import { withErrorHandling } from './error.js';
import { isValidEmail } from './form-validation-utils.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from './initialization.js';

/**
 * Validates required fields in a form.
 * @param {string} context - The context or module name.
 * @param {FormData} formData - The form data.
 * @param {string[]} requiredFields - Array of required field names.
 * @returns {boolean} True if all required fields are valid, false otherwise.
 */
export function validateRequiredFields(context, formData, requiredFields) {
  log(context, `Validating required fields: ${requiredFields.join(', ')}`);
  return withErrorHandling(`${context}:validateRequiredFields`, () => {
    return requiredFields.every(field => {
      const value = formData.get(field)?.trim();
      if (!value) {
        log(context, `Required field missing: ${field}`);
        return false;
      }
      if (field.includes('email') && !isValidEmail(context, value)) {
        log(context, `Invalid email format: ${value}`);
        return false;
      }
      return true;
    });
  }, ERROR_MESSAGES.FORM_VALIDATION_FAILED);
}

/**
 * Validates password fields, ensuring they match and meet requirements.
 * @param {string} context - The context or module name.
 * @param {FormData} formData - The form data.
 * @param {string} passwordField - The name of the password field.
 * @param {string} confirmField - The name of the confirm password field.
 * @returns {boolean} True if passwords are valid and match, false otherwise.
 */
export function validatePassword(context, formData, passwordField, confirmField) {
  log(context, `Validating password fields: ${passwordField}, ${confirmField}`);
  return withErrorHandling(`${context}:validatePassword`, () => {
    const password = formData.get(passwordField);
    const confirmPassword = formData.get(confirmField);
    if (!password || !confirmPassword) {
      log(context, 'Password or confirm password missing');
      return false;
    }
    if (password !== confirmPassword) {
      log(context, 'Passwords do not match');
      return false;
    }
    if (password.length < 8) {
      log(context, 'Password must be at least 8 characters');
      return false;
    }
    return true;
  }, ERROR_MESSAGES.FORM_VALIDATION_FAILED);
}

/**
 * Validates a phone number based on signup type.
 * @param {string} context - The context or module name.
 * @param {FormData} formData - The form data.
 * @param {string} phoneField - The name of the phone field.
 * @param {string} typeField - The name of the signup type field.
 * @returns {boolean} True if the phone number is valid, false otherwise.
 */
export function validatePhoneNumber(context, formData, phoneField, typeField) {
  log(context, `Validating phone number: ${phoneField}`);
  return withErrorHandling(`${context}:validatePhoneNumber`, () => {
    const signupType = formData.get(typeField);
    const phone = formData.get(phoneField)?.trim();
    if (signupType === 'merchant' && !phone) {
      log(context, 'Phone number required for merchant signup');
      return false;
    }
    if (phone) {
      const phoneRegex = /^\+?[1-9]\d{1,14}$/;
      if (!phoneRegex.test(phone)) {
        log(context, `Invalid phone number format: ${phone}`);
        return false;
      }
    }
    return true;
  }, ERROR_MESSAGES.FORM_VALIDATION_FAILED);
}

/**
 * Initializes the form-validation module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} FormValidation instance with public methods.
 */
export function initializeFormValidationModule(registry) {
  const context = 'form-validation.js';
  log(context, 'Initializing form-validation module for module registry');
  return {
    validateRequiredFields: (ctx, ...args) => validateRequiredFields(ctx, ...args),
    validatePassword: (ctx, ...args) => validatePassword(ctx, ...args),
    validatePhoneNumber: (ctx, ...args) => validatePhoneNumber(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'form-validation.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/icons.js
// /static/js/utils/icons.js
// Purpose: Provides utilities for rendering icons in the UI.

import { log } from '../core/logger.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from './initialization.js';

/**
 * Creates an icon element with the specified class and attributes.
 * @param {string} context - The context or module name.
 * @param {string} iconClass - The CSS class for the icon (e.g., 'fas fa-user').
 * @param {Object} [attributes={}] - Additional attributes for the icon element.
 * @returns {HTMLElement} The created icon element.
 */
export function createIcon(context, iconClass, attributes = {}) {
  log(context, `Creating icon with class: ${iconClass}`);
  return withErrorHandling(`${context}:createIcon`, () => {
    const icon = document.createElement('i');
    icon.className = iconClass;
    Object.entries(attributes).forEach(([key, value]) => {
      icon.setAttribute(key, value);
    });
    return icon;
  }, ERROR_MESSAGES.RENDER_FAILED('icon'));
}

/**
 * Initializes the icons module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Icons instance with public methods.
 */
export function initializeIconsModule(registry) {
  const context = 'icons.js';
  log(context, 'Initializing icons module for module registry');
  return {
    createIcon: (ctx, ...args) => createIcon(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'icons.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/initialization.js
// /static/js/utils/initialization.js
// Purpose: Provides utilities for module initialization and page setup.

import { log } from '../core/logger.js';
import { withAuthenticatedUser } from './auth.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from './initialization.js';
import { createModuleInitializer } from './initialization.js';

/**
 * Wraps a module initialization function with lifecycle logging.
 * @param {string} context - The context or module name.
 * @param {Function} initFunction - The initialization function to wrap.
 * @returns {void}
 */
export function withScriptLogging(context, initFunction) {
  log(context, 'Starting module initialization');
  withErrorHandling(`${context}:withScriptLogging`, () => {
    initFunction();
    log(context, 'Module initialization completed');
  }, ERROR_MESSAGES.MODULE_INIT_FAILED);
}

/**
 * Creates a module initializer for the registry with standardized method wrapping.
 * @param {string} context - The context or module name.
 * @param {Object} methods - Object mapping method names to functions.
 * @returns {Object} Module instance with wrapped methods.
 */
export function createModuleInitializer(context, methods) {
  log(context, `Initializing ${context} module for module registry`);
  return Object.keys(methods).reduce((acc, key) => {
    acc[key] = (ctx, ...args) => methods[key](ctx, ...args);
    return acc;
  }, {});
}

/**
 * Parses the page type from a query parameter or defaults to a provided value.
 * @param {string} context - The context or module name.
 * @param {string} param - The query parameter name.
 * @param {string} defaultType - The default page type.
 * @returns {string} The parsed page type.
 */
export function parsePageType(context, param, defaultType) {
  log(context, `Parsing page type from param: ${param}`);
  return withErrorHandling(`${context}:parsePageType`, () => {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get(param) || defaultType;
  }, ERROR_MESSAGES.DEFAULT, () => defaultType);
}

/**
 * Initializes role-based navigation for a page.
 * @param {string} context - The context or module name.
 * @param {string} role - The role associated with the page (e.g., 'admin', 'merchant').
 * @param {string} defaultSection - The default section to show.
 * @returns {Promise<void>}
 */
export async function initializeRoleNavigation(context, role, defaultSection) {
  log(context, `Initializing navigation for role: ${role}, default section: ${defaultSection}`);
  await withErrorHandling(`${context}:initializeRoleNavigation`, async () => {
    const navElement = document.querySelector(`nav[data-role="${role}"]`);
    if (!navElement) {
      log(context, `Navigation element not found for role: ${role}`);
      return;
    }
    const sectionLink = navElement.querySelector(`[data-section="${defaultSection}"]`);
    if (sectionLink) {
      sectionLink.click();
    }
  }, ERROR_MESSAGES.NAVIGATION_INIT_FAILED);
}

/**
 * Initializes a role-based page with authentication, navigation, and custom setup.
 * @param {string} context - The context or module name.
 * @param {string} role - The role associated with the page (e.g., 'admin', 'merchant').
 * @param {string} pageType - The type of page to initialize (e.g., 'products', 'integrations').
 * @param {Function} callback - The callback to execute for role-specific setup.
 * @returns {Promise<void>}
 */
export async function initializeRolePage(context, role, pageType, callback) {
  log(context, `Initializing ${role} page with type: ${pageType}`);
  await withAuthenticatedUser(async userId => {
    await withErrorHandling(`${context}:initializeRolePage`, async () => {
      const userIdInput = document.getElementById('userId');
      if (userIdInput) userIdInput.value = userId;
      await initializeRoleNavigation(context, role, pageType);
      await callback();
    }, ERROR_MESSAGES.MODULE_INIT_FAILED);
  });
}

/**
 * Initializes the initialization module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Initialization instance with public methods.
 */
export function initializeInitializationModule(registry) {
  return createModuleInitializer('initialization.js', {
    withScriptLogging,
    createModuleInitializer,
    parsePageType,
    initializeRoleNavigation,
    initializeRolePage,
  });
}

// Initialize module with lifecycle logging
const context = 'initialization.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/settings-data.js
// /static/js/utils/settings-data.js
// Purpose: Provides utilities for fetching settings data.

import { log } from '../core/logger.js';
import { fetchData } from './data-fetch.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from './initialization.js';

/**
 * Loads settings data from the specified endpoint.
 * @param {string} context - The context or module name.
 * @param {string} endpoint - The API endpoint to fetch settings from.
 * @returns {Promise<Array>} The fetched settings data.
 */
export async function loadSettings(context, endpoint) {
  log(context, `Loading settings from endpoint: ${endpoint}`);
  return await withErrorHandling(`${context}:loadSettings`, async () => {
    const data = await fetchData(context, endpoint);
    return data.settings || [];
  }, ERROR_MESSAGES.FETCH_FAILED('settings'), () => []);
}

/**
 * Initializes the settings-data module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} SettingsData instance with public methods.
 */
export function initializeSettingsDataModule(registry) {
  const context = 'settings-data.js';
  log(context, 'Initializing settings-data module for module registry');
  return {
    loadSettings: (ctx, ...args) => loadSettings(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'settings-data.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/settings-events.js
// /static/js/utils/settings-events.js
// Purpose: Provides utilities for setting up settings-related event listeners.

import { log } from '../core/logger.js';
import { setupEventListeners } from './event-listeners.js';
import { fetchData } from './data-fetch.js';
import { success } from '../core/notifications.js';
import { withScriptLogging } from './initialization.js';

/**
 * Sets up event listeners for settings form submissions.
 * @param {string} context - The context or module name.
 * @param {string} formId - The ID of the form.
 * @param {string} endpoint - The API endpoint for submission.
 * @param {string} settingType - The type of setting (e.g., 'api', 'affiliate').
 * @returns {void}
 */
export function setupSettingsEvents(context, formId, endpoint, settingType) {
  log(context, `Setting up settings events for form: ${formId}`);
  setupEventListeners(context, [
    {
      eventType: 'submit',
      selector: `#${formId}`,
      handler: async e => {
        e.preventDefault();
        const fields = {};
        Array.from(e.target.querySelectorAll('input')).forEach(input => {
          fields[input.name] = input.value;
        });
        await fetchData(context, `${endpoint}/${settingType}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(fields),
        });
        success(context, `Settings for ${settingType} updated successfully`);
      },
    },
  ]);
}

/**
 * Initializes the settings-events module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} SettingsEvents instance with public methods.
 */
export function initializeSettingsEventsModule(registry) {
  const context = 'settings-events.js';
  log(context, 'Initializing settings-events module for module registry');
  return {
    setupSettingsEvents: (ctx, ...args) => setupSettingsEvents(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'settings-events.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/settings-renderer.js
// /static/js/utils/settings-renderer.js
// Purpose: Provides utilities for rendering settings UI components.

import { log } from '../core/logger.js';
import { renderSettingsFields } from './settings-ui.js';
import { setupSettingsEvents } from './settings-events.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from './initialization.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Renders a settings form based on the provided configuration.
 * @param {string} context - The context or module name.
 * @param {Object} config - Settings configuration object.
 * @returns {Promise<void>}
 */
export async function renderSettingsForm(context, config) {
  log(context, `Rendering settings form for type: ${config.type}`);
  await withErrorHandling(`${context}:renderSettingsForm`, async () => {
    await renderSettingsFields(context, config.settings || [], {
      containerId: config.containerId,
      formId: config.formId,
      fieldsId: config.fieldsId,
      type: config.type,
      iconClass: config.iconClass,
      onIconClick: config.onIconClick,
      onReadmeClick: config.onReadmeClick,
    });
    setupSettingsEvents(context, config.formId, config.endpoint || '/settings', config.type);
  }, ERROR_MESSAGES.RENDER_FAILED('settings form'));
}

/**
 * Renders settings based on the provided configuration (legacy, prefer renderSettingsForm).
 * @param {string} context - The context or module name.
 * @param {Object} config - Settings configuration object.
 * @returns {Promise<void>}
 */
export async function renderSettings(context, config) {
  log(context, `Rendering settings for type: ${config.type} (legacy)`);
  await renderSettingsForm(context, config);
}

/**
 * Initializes the settings-renderer module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} SettingsRenderer instance with public methods.
 */
export function initializeSettingsRendererModule(registry) {
  return createModuleInitializer('settings-renderer.js', {
    renderSettings,
    renderSettingsForm,
  });
}

// Initialize module with lifecycle logging
const context = 'settings-renderer.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/settings-ui.js
// /static/js/utils/settings-ui.js
// Purpose: Provides low-level utilities for rendering settings fields and UI components.

import { log } from '../core/logger.js';
import { createLinkIcons } from './ui-components.js';
import { setupSettingsEvents } from './settings-events.js';
import { withElement } from './dom-manipulation.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from './initialization.js';

/**
 * Renders settings fields based on the provided settings and configuration.
 * @param {string} context - The context or module name.
 * @param {Array} settings - Array of settings data.
 * @param {Object} config - Configuration object for rendering.
 * @returns {Promise<void>}
 */
export async function renderSettingsFields(context, settings, config) {
  log(context, `Rendering settings fields for type: ${config.type}`);
  await withErrorHandling(`${context}:renderSettingsFields`, async () => {
    await withElement(context, config.containerId, async container => {
      await withElement(context, config.fieldsId, async fieldsContainer => {
        await withElement(context, config.formId, async form => {
          container.innerHTML = '';
          fieldsContainer.innerHTML = '';
          const linkIcons = createLinkIcons(context, settings, config.type, config.onReadmeClick, config.onIconClick);
          container.append(...linkIcons);
          if (settings.length > 0) {
            fieldsContainer.innerHTML = settings[0].fields
              .map(field => `
                <div>
                  <label for="${field.name}">${field.label || field.name}</label>
                  <input type="${field.type || 'text'}" name="${field.name}" value="${field.value || ''}">
                </div>
              `)
              .join('');
            if (config.onIconClick) {
              config.onIconClick(settings[0], fieldsContainer, form);
            }
          }
          setupSettingsEvents(context, config.formId, config.endpoint || '/settings', config.type);
        });
      });
    });
  }, ERROR_MESSAGES.RENDER_FAILED('settings fields'));
}

/**
 * Initializes the settings-ui module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} SettingsUi instance with public methods.
 */
export function initializeSettingsUiModule(registry) {
  const context = 'settings-ui.js';
  log(context, 'Initializing settings-ui module for module registry');
  return {
    renderSettingsFields: (ctx, ...args) => renderSettingsFields(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'settings-ui.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/ui-components.js
// /static/js/utils/ui-components.js
// Purpose: Provides utilities for rendering reusable UI components.

import { log } from '../core/logger.js';
import { createIcon } from './icons.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from './initialization.js';

/**
 * Renders a data table based on the provided configuration.
 * @param {string} context - The context or module name.
 * @param {Object} config - Table configuration object.
 * @returns {string} The rendered HTML table.
 */
export function renderDataTable(context, { data = [], headers = [], rowMapper, emptyMessage }) {
  log(context, 'Rendering data table');
  return withErrorHandling(`${context}:renderDataTable`, () => {
    if (!data.length) {
      return `<p>${emptyMessage || 'No data available'}</p>`;
    }
    const headerHtml = headers.map(header => `<th>${header}</th>`).join('');
    const rowsHtml = data.map(item => `<tr>${rowMapper(item).map(cell => `<td>${cell}</td>`).join('')}</tr>`).join('');
    return `
      <table>
        <thead><tr>${headerHtml}</tr></thead>
        <tbody>${rowsHtml}</tbody>
      </table>
    `;
  }, ERROR_MESSAGES.RENDER_FAILED('data table'));
}

/**
 * Renders a checkbox list based on the provided configuration.
 * @param {string} context - The context or module name.
 * @param {Object} config - Checkbox list configuration object.
 * @returns {HTMLElement} The rendered checkbox list container.
 */
export function renderCheckboxList(context, { items = [], name, selected = [], dataAttributes = {}, containerClass = '' }) {
  log(context, `Rendering checkbox list for: ${name}`);
  return withErrorHandling(`${context}:renderCheckboxList`, () => {
    const container = document.createElement('div');
    if (containerClass) {
      container.className = containerClass;
    }
    items.forEach(item => {
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.name = name;
      checkbox.value = item.value;
      checkbox.checked = selected.includes(item.value);
      Object.entries(dataAttributes).forEach(([key, value]) => {
        checkbox.dataset[key] = value;
      });

      const label = document.createElement('label');
      label.textContent = item.label;
      label.prepend(checkbox);

      container.appendChild(label);
    });
    return container;
  }, ERROR_MESSAGES.RENDER_FAILED('checkbox list'));
}

/**
 * Renders a modal based on the provided configuration.
 * @param {string} context - The context or module name.
 * @param {Object} config - Modal configuration object.
 * @returns {Promise<HTMLElement>} The rendered modal element.
 */
export async function renderModal(context, { id, title, content, formId, buttons = [] }) {
  log(context, `Rendering modal: ${id}`);
  return await withErrorHandling(`${context}:renderModal`, async () => {
    const modal = document.createElement('div');
    modal.id = id;
    modal.className = 'modal';
    modal.innerHTML = `
      <div class="modal-content">
        <h2>${title}</h2>
        <form id="${formId}">
          ${typeof content === 'string' ? content : content.outerHTML}
          <div class="modal-buttons">
            ${buttons.map(btn => `<button type="${btn.type}" class="${btn.className || ''}" ${btn.onclick ? `onclick="${btn.onclick}"` : ''}>${btn.text}</button>`).join('')}
          </div>
        </form>
      </div>
    `;
    document.body.appendChild(modal);
    return modal;
  }, ERROR_MESSAGES.RENDER_FAILED('modal'));
}

/**
 * Creates link icons for settings or navigation.
 * @param {string} context - The context or module name.
 * @param {Array} links - Array of link objects with keyType and docLink.
 * @param {string} type - The type of links (e.g., 'api', 'affiliate').
 * @param {Function} onReadmeClick - Callback for readme link clicks.
 * @param {Function} onIconClick - Callback for icon clicks.
 * @returns {HTMLElement[]} Array of icon elements.
 */
export function createLinkIcons(context, links, type, onReadmeClick, onIconClick) {
  log(context, `Creating link icons for type: ${type}`);
  return withErrorHandling(`${context}:createLinkIcons`, () => {
    const icons = [];
    links.forEach(link => {
      const icon = createIcon(context, `fas fa-${type}`, { 'data-key-type': link.keyType });
      icon.addEventListener('click', () => onIconClick?.(link));
      icons.push(icon);

      const readmeLink = link.docLink?.find(l => l.title === 'readme');
      if (readmeLink) {
        const readmeIcon = createIcon(context, 'fas fa-book', { 'data-key-type': link.keyType });
        readmeIcon.addEventListener('click', () => onReadmeClick?.(link));
        icons.push(readmeIcon);
      }
    });
    return icons;
  }, ERROR_MESSAGES.RENDER_FAILED('link icons'));
}

/**
 * Initializes the ui-components module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} UiComponents instance with public methods.
 */
export function initializeUiComponentsModule(registry) {
  const context = 'ui-components.js';
  log(context, 'Initializing ui-components module for module registry');
  return {
    renderDataTable: (ctx, ...args) => renderDataTable(ctx, ...args),
    renderCheckboxList: (ctx, ...args) => renderCheckboxList(ctx, ...args),
    renderModal: (ctx, ...args) => renderModal(ctx, ...args),
    createLinkIcons: (ctx, ...args) => createLinkIcons(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'ui-components.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

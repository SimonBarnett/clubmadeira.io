+ [js]
+----[admin]
+------admin-events.js
+------deals-orchestrator.js
+------deals.js
+------initializer.js
+------navigation.js
+------settings-orchestrator.js
+------settings.js
+------users-data.js
+------users-orchestrator.js
+------users-ui.js
+----admin-page.js
+----[community]
+------categories-data.js
+------categories-events.js
+------categories-navigation.js
+------categories-page.js
+------categories-ui.js
+------community-providers.js
+------providers-data.js
+------providers-events.js
+------providers-handlers.js
+------providers-page.js
+------referrals-data.js
+------referrals-page.js
+------referrals-ui.js
+----community-page.js
+----[config]
+------constants.js
+------endpoints.js
+------form-configs.js
+------menus.js
+------messages.js
+------pages.js
+------roles.js
+------settings.js
+----[core]
+------auth.js
+------cookies.js
+------logger.js
+------markdown.js
+------mce.js
+------notifications.js
+------user.js
+----[login]
+------forgot-password.js
+------login.js
+------set-password.js
+------signup.js
+----login-page.js
+----main.js
+----[merchant]
+------api-keys-events.js
+------api-keys.js
+------documentation.js
+------navigation.js
+------products.js
+------setup.js
+------user-settings.js
+----merchant-page.js
+----[modules]
+------dataLoader.js
+------navigation.js
+------pageSetup.js
+------site-request.js
+------userSettings.js
+----[partner]
+------initializer.js
+------integrations-data.js
+------integrations-ui.js
+------integrations.js
+------navigation.js
+------partner-events.js
+----partner-page.js
+----[utils]
+------data-fetch.js
+------dom-events.js
+------dom-manipulation.js
+------error.js
+------event-listeners.js
+------form-rendering.js
+------form-submission.js
+------form-validation-utils.js
+------form-validation.js
+------icons.js
+------initialization.js
+------logging-utils.js
+------settings-data.js
+------settings-events.js
+------settings-renderer.js
+------settings-ui.js
+------ui-components.js

admin/admin-events.js

// /static/js/admin/admin-events.js
// Purpose: Centralizes event listener setup for the admin page.

import { log } from '../core/logger.js';
import { registerEvents } from '../utils/event-listeners.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Sets up all event listeners for the admin page.
 * @param {string} context - The context or module name.
 * @returns {void}
 */
export function setupAdminEvents(context) {
  log(context, 'Setting up admin event listeners');
  withErrorHandling(`${context}:setupAdminEvents`, () => {
    registerEvents(context, [
      'formSubmit',
      'navigationToggle',
      'permissionChange',
      'modifyPermissions',
    ], {
      formId: 'settingsForm',
      endpoint: '/settings/user',
      configKey: 'userSettings',
      navToggleId: 'adminNavToggle',
      navId: 'adminNav',
    });
  }, ERROR_MESSAGES.EVENT_HANDLER_FAILED);
}

/**
 * Initializes the admin events module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Events instance with public methods.
 */
export function initializeAdminEventsModule(registry) {
  return createModuleInitializer('admin-events.js', {
    setupAdminEvents,
  });
}

// Initialize module with lifecycle logging
const context = 'admin-events.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

admin/deals-orchestrator.js

// /static/js/admin/deals-orchestrator.js
// Purpose: Orchestrates deals feature initialization for the admin interface.

import { log } from '../core/logger.js';
import { loadDeals } from './deals.js';
import { getElements } from '../utils/dom-manipulation.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Initializes the deals feature by loading and rendering deals data.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeDealsOrchestrator(context) {
  log(context, 'Initializing deals orchestrator');
  await withErrorHandling(`${context}:initializeDealsOrchestrator`, async () => {
    const elements = await getElements(context, ['dealList']);
    await loadDeals(context, elements);
  }, ERROR_MESSAGES.MODULE_INIT_FAILED);
}

/**
 * Initializes the deals orchestrator module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Deals orchestrator instance with public methods.
 */
export function initializeDealsOrchestratorModule(registry) {
  return createModuleInitializer('deals-orchestrator.js', {
    initializeDealsOrchestrator,
  });
}

// Initialize module with lifecycle logging
const context = 'deals-orchestrator.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

admin/deals.js

// /static/js/admin/deals.js
// Purpose: Manages deals data, including fetching and rendering deals in a table.

import { log } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { load as dataLoaderLoad } from '../modules/dataLoader.js';
import { fetchData } from '../utils/data-fetch.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { renderDataTable } from '../utils/ui-components.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Fetches and renders deals data in a table.
 * @param {string} context - The context or module name.
 * @param {Object} elements - DOM elements configuration object.
 * @param {HTMLElement} elements.dealList - The element to render the deals table into.
 * @returns {Promise<void>}
 */
export async function loadDeals(context, { dealList }) {
  log(context, `Loading deals data at: ${new Date().toISOString()}`);
  await withErrorHandling(`${context}:loadDeals`, async () => {
    try {
      // Fetch deals data using dataLoader (retained for compatibility)
      const data = await dataLoaderLoad(context, 'initial');
      log(context, 'Deals fetched:', data);

      // Check for error status
      if (data.status === 'error') {
        throw new Error(ERROR_MESSAGES.FETCH_FAILED('deals'));
      }

      // Prepare table data
      const headers = [
        'Category',
        'Title',
        'URL',
        'Price',
        'Original',
        'Discount',
        'Image',
        'Quantity',
      ];
      const rowMapper = (deal) => [
        deal.category || 'N/A',
        deal.title || 'N/A',
        `<a href="${deal.url || '#'}" target="_blank">Link</a>`,
        deal.price || 'N/A',
        deal.original || 'N/A',
        deal.discount || 'N/A',
        `<img src="${deal.image || ''}" alt="Product Image" style="width: 50px;" onerror="this.src='/static/images/placeholder.png';">`,
        deal.quantity || 'N/A',
      ];

      // Render deals table
      dealList.innerHTML = renderDataTable(context, {
        data: data.data,
        headers,
        rowMapper,
        emptyMessage: ERROR_MESSAGES.DEALS_NO_DATA,
      });
    } catch (err) {
      dealList.innerHTML = renderDataTable(context, {
        data: [],
        headers: [],
        rowMapper: () => [ERROR_MESSAGES.FETCH_FAILED('deals')],
        emptyMessage: ERROR_MESSAGES.FETCH_FAILED('deals'),
      });
      throw err;
    }
  }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Initializes the deals module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Deals instance with public methods.
 */
export function initializeDealsModule(registry) {
  const context = 'deals.js';
  log(context, 'Initializing deals module for module registry');
  return {
    loadDeals: (ctx, ...args) => loadDeals(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'deals.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

admin/initializer.js

// /static/js/admin/initializer.js
// Purpose: Coordinates initialization of admin feature-specific orchestrators.

import { log } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { initializeDealsOrchestrator } from './deals-orchestrator.js';
import { initializeUsersOrchestrator } from './users-orchestrator.js';
import { initializeSettingsOrchestrator } from './settings-orchestrator.js';

/**
 * Initializes admin feature orchestrators for deals, users, and settings.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeAdminModules(context) {
  log(context, 'Initializing admin feature orchestrators');

  const orchestrators = [
    { name: 'deals', init: initializeDealsOrchestrator },
    { name: 'users', init: initializeUsersOrchestrator },
    { name: 'settings', init: initializeSettingsOrchestrator },
  ];

  for (const { name, init } of orchestrators) {
    await withErrorHandling(`${context}:initialize${name}`, async () => {
      await init(context);
    }, ERROR_MESSAGES.MODULE_INIT_FAILED);
  }
}

/**
 * Initializes the initializer module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Initializer instance with public methods.
 */
export function initializeInitializerModule(registry) {
  return createModuleInitializer('initializer.js', {
    initializeAdminModules,
  });
}

// Initialize module with lifecycle logging
const context = 'initializer.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

admin/navigation.js

// /static/js/admin/navigation.js
import { log } from '../core/logger.js';
import { defineSectionHandlers } from '../modules/navigation.js';
import { loadDeals } from './deals.js';
import { initializeUserManagement } from './users-orchestrator.js';
import { loadAdminSettings } from './settings.js';
import { initializeAdminModules } from './initializer.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { toggleViewState } from '../utils/dom-manipulation.js';

/**
 * Defines section handlers for the admin page.
 * @param {string} context - The context or module name.
 * @returns {void}
 */
export function defineAdminSectionHandlers(context) {
  log(context, 'Defining section handlers');
  defineSectionHandlers(context, 'admin', [
    {
      id: 'info',
      handler: async () => {
        log(context, 'Loading info section');
        toggleViewState(context, { info: true });
      },
    },
    {
      id: 'user_management',
      handler: async (role) => {
        log(context, `Calling initializeUserManagement for role: ${role}`);
        await initializeUserManagement(context, role || 'admin');
      },
    },
    {
      id: 'affiliates',
      handler: async () => {
        log(context, 'Calling loadAdminSettings for affiliates');
        await loadAdminSettings(context, 'affiliates');
      },
    },
    {
      id: 'site_settings',
      handler: async () => {
        log(context, 'Calling initializeAdminModules');
        await initializeAdminModules(context);
      },
    },
    {
      id: 'api_keys',
      handler: async () => {
        log(context, 'Calling loadAdminSettings for apiKeys');
        await loadAdminSettings(context, 'apiKeys');
      },
    },
    {
      id: 'deals',
      handler: async () => {
        log(context, 'Calling loadDeals');
        const elements = await import('../utils/dom-manipulation.js').then(m => m.getElements(context, ['dealList']));
        await loadDeals(context, elements);
      },
    },
  ]);
}

/**
 * Initializes the navigation module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Navigation instance with public methods.
 */
export function initializeNavigationModule(registry) {
  const context = 'navigation.js';
  log(context, 'Initializing navigation module for module registry');
  return {
    defineAdminSectionHandlers: ctx => defineAdminSectionHandlers(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'navigation.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

admin/settings-orchestrator.js

// /static/js/admin/settings-orchestrator.js
// Purpose: Orchestrates settings feature initialization for affiliates, site settings, and API keys in the admin interface.

import { log } from '../core/logger.js';
import { loadAdminSettings } from './settings.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Initializes the settings feature for affiliates, site settings, and API keys.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeSettingsOrchestrator(context) {
  log(context, 'Initializing settings orchestrator');
  const settingsTypes = ['affiliates', 'siteSettings', 'apiKeys'];
  for (const type of settingsTypes) {
    await withErrorHandling(`${context}:initialize${type}`, async () => {
      await loadAdminSettings(context, type);
    }, ERROR_MESSAGES.MODULE_INIT_FAILED);
  }
}

/**
 * Initializes the settings orchestrator module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Settings orchestrator instance with public methods.
 */
export function initializeSettingsOrchestratorModule(registry) {
  return createModuleInitializer('settings-orchestrator.js', {
    initializeSettingsOrchestrator,
  });
}

// Initialize module with lifecycle logging
const context = 'settings-orchestrator.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

admin/settings.js

// /static/js/admin/settings.js
// Purpose: Manages loading of admin settings for affiliates, API keys, and site settings.

import { log } from '../core/logger.js';
import { renderSettingsForm } from '../utils/settings-renderer.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { SETTINGS } from '../config/settings.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Loads admin settings for the specified type (e.g., affiliates, apiKeys, siteSettings).
 * @param {string} context - The context or module name.
 * @param {string} type - The type of settings to load (e.g., 'affiliates', 'apiKeys', 'siteSettings').
 * @returns {Promise<void>}
 * @throws {Error} If the settings type is unknown.
 */
export async function loadAdminSettings(context, type) {
  log(context, `Loading ${type} settings`);
  const settingsConfig = SETTINGS[type];
  if (!settingsConfig) {
    throw new Error(`Unknown settings type: ${type}`);
  }
  await renderSettingsForm(context, settingsConfig);
}

/**
 * Initializes the settings module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Settings instance with public methods.
 */
export function initializeSettingsModule(registry) {
  return createModuleInitializer('settings.js', {
    loadAdminSettings,
  });
}

// Initialize module with lifecycle logging
const context = 'settings.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

admin/users-data.js

// /static/js/admin/users-data.js
// Purpose: Manages user data fetching and permission updates for the admin interface.

import { authenticatedFetch } from '../core/auth.js';
import { log } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Fetches user data for a specific role.
 * @param {string} context - The context or module name.
 * @param {string} [role='admin'] - The role to fetch users for.
 * @returns {Promise<{users: Array, role: string}>} The user data and role.
 */
export async function loadUsers(context, role = 'admin') {
  log(context, `Fetching users for role: ${role} at: ${new Date().toISOString()}`);
  return await withErrorHandling(`${context}:loadUsers`, async () => {
    const response = await authenticatedFetch(API_ENDPOINTS.USERS_ROLE(role));
    const data = await response.json();
    log(context, `Users fetched for role ${role}:`, data);

    if (data.status === 'error') {
      throw new Error(ERROR_MESSAGES.FETCH_FAILED('users'));
    }

    if (!data.users || data.users.length === 0) {
      log(context, `No users found for role ${role}`);
      return { users: [], role };
    }

    return { users: data.users, role };
  }, ERROR_MESSAGES.FETCH_FAILED('users'));
}

/**
 * Updates a user's permission.
 * @param {string} context - The context or module name.
 * @param {string} userId - The user ID.
 * @param {string} permission - The permission to update.
 * @param {boolean} isChecked - Whether to add or remove the permission.
 * @param {string} role - The user role.
 * @returns {Promise<{userId: string, permission: string, isChecked: boolean, role: string, message: string}>} The update result.
 */
export async function updateUserPermission(context, userId, permission, isChecked, role) {
  log(context, `Updating permission ${permission} for user ${userId} (role: ${role}): ${isChecked ? 'add' : 'remove'}`);
  const method = isChecked ? 'PATCH' : 'DELETE';
  return await withErrorHandling(`${context}:updateUserPermission`, async () => {
    const response = await authenticatedFetch(API_ENDPOINTS.PERMISSION, {
      method,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ userId, permission }),
    });
    const data = await response.json();
    return { userId, permission, isChecked, role, message: data.message || 'Permission updated' };
  }, ERROR_MESSAGES.FETCH_FAILED('permission update'));
}

/**
 * Fetches user data for modifying permissions.
 * @param {string} context - The context or module name.
 * @param {string} userId - The user ID.
 * @returns {Promise<Object>} The user data.
 */
export async function fetchUserForPermissions(context, userId) {
  log(context, `Fetching user data for ${userId}`);
  return await withErrorHandling(`${context}:fetchUserForPermissions`, async () => {
    const response = await authenticatedFetch(API_ENDPOINTS.USERS_USERID(userId));
    const userData = await response.json();
    return userData;
  }, ERROR_MESSAGES.FETCH_FAILED('user details'));
}

/**
 * Initializes the users data module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Users data instance with public methods.
 */
export function initializeUsersDataModule(registry) {
  const context = 'users-data.js';
  log(context, 'Initializing users data module for module registry');
  return {
    loadUsers: (ctx, ...args) => loadUsers(ctx, ...args),
    updateUserPermission: (ctx, ...args) => updateUserPermission(ctx, ...args),
    fetchUserForPermissions: (ctx, ...args) => fetchUserForPermissions(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'users-data.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

admin/users-orchestrator.js

// /static/js/admin/users-orchestrator.js
// Purpose: Orchestrates user management for the admin interface, coordinating data, UI, and events.

import { log } from '../core/logger.js';
import { loadUsers } from './users-data.js';
import { renderUsersTable } from './users-ui.js';
import { setupAdminEvents } from './admin-events.js';
import { getElements } from '../utils/dom-manipulation.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Initializes user management for the admin interface.
 * @param {string} context - The context or module name.
 * @param {string} [role='admin'] - The role to manage users for.
 * @returns {Promise<void>}
 */
export async function initializeUserManagement(context, role = 'admin') {
  log(context, `Initializing user management for role: ${role}`);
  await withErrorHandling(`${context}:initializeUserManagement`, async () => {
    const userData = await loadUsers(context, role);
    const elements = await getElements(context, ['userManagement', 'userList']);
    await renderUsersTable(context, userData, elements);
    setupAdminEvents(context);
  }, ERROR_MESSAGES.MODULE_INIT_FAILED);
}

/**
 * Initializes the users-orchestrator module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} UsersOrchestrator instance with public methods.
 */
export function initializeUsersOrchestratorModule(registry) {
  return createModuleInitializer('users-orchestrator.js', {
    initializeUserManagement,
  });
}

// Initialize module with lifecycle logging
const context = 'users-orchestrator.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

admin/users-ui.js

// /static/js/admin/users-ui.js
// Purpose: Manages UI rendering for user management in the admin interface.

import { log, warn } from '../core/logger.js';
import { toggleViewState } from '../utils/dom-manipulation.js';
import { success, error as notifyError } from '../core/notifications.js';
import { renderCheckboxList, renderDataTable, renderModal } from '../utils/ui-components.js';
import { ROLES, SUCCESS_MESSAGES, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Renders user data in a table.
 * @param {string} context - The context or module name.
 * @param {Object} userData - The user data to render, containing users and role.
 * @param {Object} elements - DOM elements configuration object.
 * @param {HTMLElement} elements.userManagement - The user management section element.
 * @param {HTMLElement} elements.userList - The table body element to render into.
 * @returns {Promise<void>}
 */
export async function renderUsersTable(context, { users, role }, { userManagement, userList }) {
  log(context, `Rendering users for role: ${role}`);
  if (userList.tagName.toLowerCase() !== 'tbody') {
    throw new Error(ERROR_MESSAGES.INVALID_TABLE_BODY);
  }

  const parentTable = userList.closest('table');
  if (!parentTable) {
    throw new Error(ERROR_MESSAGES.TABLE_NOT_FOUND);
  }

  if (!users || users.length === 0) {
    warn(context, `No users found for role ${role}`);
    userList.innerHTML = renderDataTable(context, {
      data: [],
      headers: [],
      rowMapper: () => ['No users found'],
      emptyMessage: ERROR_MESSAGES.USERS_NO_DATA,
    });
    success(context, ERROR_MESSAGES.USERS_NO_DATA);
    return;
  }

  const allowedPermissions = ROLES[role]?.permissions || [];
  const headers = ['ID', 'Name', 'Website', 'Email', 'Phone', 'Permissions', 'Actions'];
  const rowMapper = (user) => {
    const userPermissions = Array.isArray(user.permissions) ? user.permissions : [];
    const permissionsContainer = renderCheckboxList(context, {
      items: allowedPermissions,
      name: 'permissions',
      selected: userPermissions,
      dataAttributes: { userId: user.userId, role },
      containerClass: 'permissions-list',
    }).outerHTML;
    return [
      user.userId,
      user.contactName || '',
      user.websiteUrl || '',
      user.emailAddress || '',
      user.phoneNumber || '',
      permissionsContainer,
      `<button class="modify-permissions" data-userId="${user.userId}" data-role="${role}">Modify Permissions</button>`,
    ];
  };

  userList.innerHTML = renderDataTable(context, {
    data: users,
    headers,
    rowMapper,
    emptyMessage: ERROR_MESSAGES.USERS_NO_DATA,
  });

  if (userList.children.length === 0) {
    warn(context, 'Table body empty after rendering');
    userList.innerHTML = renderDataTable(context, {
      data: [],
      headers: [],
      rowMapper: () => [ERROR_MESSAGES.USERS_RENDER_FAILED],
      emptyMessage: ERROR_MESSAGES.USERS_RENDER_FAILED,
    });
    notifyError(context, ERROR_MESSAGES.USERS_RENDER_FAILED);
  } else {
    log(context, `Successfully rendered ${userList.children.length} users`);
    success(context, SUCCESS_MESSAGES.USERS_RENDERED);
  }
}

/**
 * Renders a permissions modification modal.
 * @param {string} context - The context or module name.
 * @param {string} userId - The user ID.
 * @param {Object} userData - The user data containing permissions.
 * @param {string} role - The user role.
 * @param {string} [formId='permissionsForm'] - The ID of the form in the modal.
 * @returns {Promise<HTMLElement>} The rendered modal element.
 */
export async function renderPermissionsModal(context, userId, userData, role, formId = 'permissionsForm') {
  log(context, `Rendering modal for user ${userId} with role ${role}`);
  const allowedPermissions = ROLES[role]?.permissions || [];
  const currentPermissions = Array.isArray(userData.permissions) ? userData.permissions : [];

  const checkboxList = renderCheckboxList(context, {
    items: allowedPermissions,
    name: 'permissions',
    selected: currentPermissions,
    containerClass: 'permissions-checkboxes',
  }).outerHTML;

  const modal = await renderModal(context, {
    id: `permissionsModal-${userId}`,
    title: `Modify Permissions for User ${userId}`,
    content: checkboxList,
    formId,
    buttons: [
      { type: 'submit', text: 'Save', className: 'save' },
      { type: 'button', text: 'Cancel', className: 'cancel', onclick: 'this.closest(".modal").remove()' },
    ],
  });

  return modal;
}

/**
 * Initializes the users UI module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Users UI instance with public methods.
 */
export function initializeUsersUiModule(registry) {
  const context = 'users-ui.js';
  log(context, 'Initializing users UI module for module registry');
  return {
    renderUsersTable: (ctx, ...args) => renderUsersTable(ctx, ...args),
    renderPermissionsModal: (ctx, ...args) => renderPermissionsModal(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'users-ui.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

admin-page.js

// /static/js/admin-page.js
// Purpose: Orchestrates the admin page, coordinating navigation, events, and module initialization.
const context = 'admin-page.js';
import { log } from './core/logger.js';
import { parsePageType, hideOverlay } from './utils/initialization.js';
import { withScriptLogging } from './utils/logging-utils.js';
import { initializeRoleNavigation } from './admin/navigation.js';
import { ROLES } from './config/menus.js';
import { setupAdminEvents } from './admin/admin-events.js';
import { initializeAdminModules } from './admin/initializer.js';

/**
 * Defines section handlers for the admin role.
 * @param {string} context - The context or module name.
 * @returns {Object} Section handlers for admin sections.
 */
function defineAdminSectionHandlers(context) {
    log(context, 'Defining section handlers for admin role');
    return {
        info: (show) => {
            const infoSection = document.getElementById('info');
            if (infoSection) {
                infoSection.style.display = show ? 'block' : 'none';
                const userIdInput = document.getElementById('userId');
                if (userIdInput && document.getElementById('user-contact-name')) {
                    document.getElementById('user-contact-name').innerText = userIdInput.value;
                }
            } else {
                log(context, 'Warning: info section not found', 'warn');
            }
        },
        userManagementIntro: (show) => {
            const section = document.getElementById('userManagementIntro');
            if (section) {
                section.style.display = show ? 'block' : 'none';
            } else {
                log(context, 'Warning: userManagementIntro section not found', 'warn');
            }
        },
        user_management: (show) => {
            const section = document.getElementById('user_management');
            if (section) {
                section.style.display = show ? 'block' : 'none';
            } else {
                log(context, 'Warning: user_management section not found', 'warn');
            }
        },
        deals: (show) => {
            const section = document.getElementById('deals');
            if (section) {
                section.style.display = show ? 'block' : 'none';
            } else {
                log(context, 'Warning: deals section not found', 'warn');
            }
        },
        testScriptsIntro: (show) => {
            const section = document.getElementById('testScriptsIntro');
            if (section) {
                section.style.display = show ? 'block' : 'none';
            } else {
                log(context, 'Warning: testScriptsIntro section not found', 'warn');
            }
        },
        referralTestsIntro: (show) => {
            const section = document.getElementById('referralTestsIntro');
            if (section) {
                section.style.display = show ? 'block' : 'none';
            } else {
                log(context, 'Warning: referralTestsIntro section not found', 'warn');
            }
        },
        page_visit_test: (show) => {
            const section = document.getElementById('page_visit_test');
            if (section) {
                section.style.display = show ? 'block' : 'none';
            } else {
                log(context, 'Warning: page_visit_test section not found', 'warn');
            }
        },
        order_test: (show) => {
            const section = document.getElementById('order_test');
            if (section) {
                section.style.display = show ? 'block' : 'none';
            } else {
                log(context, 'Warning: order_test section not found', 'warn');
            }
        },
        test_partner: (show) => {
            const section = document.getElementById('test_partner');
            if (section) {
                section.style.display = show ? 'block' : 'none';
            } else {
                log(context, 'Warning: test_partner section not found', 'warn');
            }
        },
        test_merchant: (show) => {
            const section = document.getElementById('test_merchant');
            if (section) {
                section.style.display = show ? 'block' : 'none';
            } else {
                log(context, 'Warning: test_merchant section not found', 'warn');
            }
        },
        test_community: (show) => {
            const section = document.getElementById('test_community');
            if (section) {
                section.style.display = show ? 'block' : 'none';
            } else {
                log(context, 'Warning: test_community section not found', 'warn');
            }
        },
        api_keys: (show) => {
            const section = document.getElementById('api_keys');
            if (section) {
                section.style.display = show ? 'block' : 'none';
            } else {
                log(context, 'Warning: api_keys section not found', 'warn');
            }
        },
        site_settings: (show) => {
            const section = document.getElementById('site_settings');
            if (section) {
                section.style.display = show ? 'block' : 'none';
            } else {
                log(context, 'Warning: site_settings section not found', 'warn');
            }
        },
        settings: (show) => {
            const section = document.getElementById('settings');
            if (section) {
                section.style.display = show ? 'block' : 'none';
            } else {
                log(context, 'Warning: settings section not found', 'warn');
            }
        },
        my_account: (show) => {
            const section = document.getElementById('my-account');
            if (section) {
                section.style.display = show ? 'block' : 'none';
            } else {
                log(context, 'Warning: my-account section not found', 'warn');
            }
        },
        contact_details: (show) => {
            const section = document.getElementById('contact-details');
            if (section) {
                section.style.display = show ? 'block' : 'none';
            } else {
                log(context, 'Warning: contact-details section not found', 'warn');
            }
        },
        change_password: (show) => {
            const section = document.getElementById('change-password');
            if (section) {
                section.style.display = show ? 'block' : 'none';
            } else {
                log(context, 'Warning: change-password section not found', 'warn');
            }
        }
    };
}

/**
 * Initializes the admin page.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeAdminPage(context) {
    log(context, 'Initializing admin page');
    const pageType = parsePageType(context, 'page', 'info'); // Default to 'info' for admin
    log(context, `Parsed page type: ${pageType}`);

    // Ensure admin role and menu are defined
    const role = 'admin';
    const menu = ROLES.admin?.menu || [];
    if (!menu.length) {
        log(context, 'Error: Admin menu not defined', 'error');
        return;
    }
    log(context, 'Menu retrieved for role admin:', menu);

    // Define section handlers
    const sectionHandlers = defineAdminSectionHandlers(context);
    log(context, 'Section handlers defined:', Object.keys(sectionHandlers));

    // Initialize navigation
    await initializeRoleNavigation(role, menu, sectionHandlers, pageType);
    log(context, 'Navigation initialized for admin role');

    // Initialize admin-specific modules
    await initializeAdminModules(context);
    log(context, 'Admin modules initialized');

    // Setup admin-specific events
    await setupAdminEvents(context);
    log(context, 'Admin events setup');

    // Show layout and hide overlay
    const layoutWrapper = document.querySelector('.layout-wrapper');
    if (layoutWrapper) {
        layoutWrapper.style.display = 'block';
        log(context, 'Layout wrapper displayed');
    } else {
        log(context, 'Warning: Layout wrapper not found', 'warn');
    }
    await hideOverlay();
    log(context, 'Loading overlay hidden');
}

/**
 * Initializes the admin-page module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} AdminPage instance with public methods.
 */
export function initializeAdminPageModule(registry) {
    const context = 'admin-page.js';
    log(context, 'Initializing admin-page module for module registry');
    return {
        initializeAdminPage: ctx => initializeAdminPage(ctx || context),
    };
}

// Initialize module with lifecycle logging
withScriptLogging(context, async () => {
    log(context, 'Starting module initialization');
    await initializeAdminPage(context);
    log(context, 'Module initialized');
});

community/categories-data.js

// /static/js/community/categories-data.js
// Purpose: Manages data fetching, updates, and validation for the community categories page.

import { log } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { withErrorHandling } from '../utils/error.js';
import { validateUserId } from '../utils/auth.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { createModuleInitializer } from '../utils/initialization.js';

// Module-scoped state for cumulative deselections
const state = {
  cumulativeDeselections: [],
};

/**
 * Fetches categories from the server.
 * @param {string} context - The context or module name.
 * @param {string} userId - The user ID.
 * @param {boolean} [isAdmin=false] - Whether the user is an admin.
 * @returns {Promise<Object>} The categories data.
 */
export async function loadCategories(context, userId, isAdmin = false) {
  log(context, `Loading categories for user: ${userId}, isAdmin: ${isAdmin}`);
  return await withErrorHandling(`${context}:loadCategories`, async () => {
    await validateUserId(context);
    const data = await fetchData(API_ENDPOINTS.CATEGORIES, { method: 'GET' });
    return {
      categories: data.categories || {},
      deselected: data.deselected || [],
      previousDeselected: data.previousDeselected || [],
      prompt: data.prompt || '',
      selected: data.selected || [],
    };
  }, ERROR_MESSAGES.FETCH_FAILED('categories'), () => ({
    categories: {},
    deselected: [],
    previousDeselected: [],
    selected: [],
    prompt: '',
  }));
}

/**
 * Saves categories to the server.
 * @param {string} context - The context or module name.
 * @param {Object} data - The categories data to save.
 * @returns {Promise<Object>} The server response.
 */
export async function saveCategories(context, data) {
  log(context, 'Saving categories');
  return await withErrorHandling(`${context}:saveCategories`, async () => {
    return await fetchData(API_ENDPOINTS.SAVE_CATEGORIES, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
  }, ERROR_MESSAGES.FETCH_FAILED('categories save'));
}

/**
 * Resets categories for a user.
 * @param {string} context - The context or module name.
 * @param {string} userId - The user ID.
 * @returns {Promise<Object>} The server response.
 */
export async function resetCategories(context, userId) {
  log(context, `Resetting categories for user: ${userId}`);
  return await withErrorHandling(`${context}:resetCategories`, async () => {
    await validateUserId(context);
    return await fetchData(API_ENDPOINTS.RESET_CATEGORIES, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ userId }),
    });
  }, ERROR_MESSAGES.FETCH_FAILED('categories reset'));
}

/**
 * Merges new deselections with the cumulative state.
 * @param {string} context - The context or module name.
 * @param {string[]} newDeselections - The new deselections to merge.
 * @returns {string[]} The updated cumulative deselections.
 */
export function mergeDeselections(context, newDeselections) {
  if (Array.isArray(newDeselections)) {
    log(context, 'Merging new deselections:', newDeselections);
    state.cumulativeDeselections = [...new Set([...state.cumulativeDeselections, ...newDeselections])];
  }
  return state.cumulativeDeselections;
}

/**
 * Gets the current cumulative deselections.
 * @param {string} context - The context or module name.
 * @returns {string[]} The cumulative deselections.
 */
export function getCumulativeDeselections(context) {
  log(context, 'Retrieving cumulative deselections');
  return state.cumulativeDeselections;
}

/**
 * Updates deselected categories based on provided selections.
 * @param {string} context - The context or module name.
 * @param {string[]} selectedCategories - The currently selected categories.
 * @param {string[]} allCategories - All available categories.
 * @returns {Object} Updated deselected and previousDeselected arrays.
 */
export function updateDeselectedCategories(context, selectedCategories, allCategories) {
  log(context, 'Updating deselected categories');
  return withErrorHandling(`${context}:updateDeselectedCategories`, () => {
    const newDeselections = allCategories.filter(cat => !selectedCategories.includes(cat));
    mergeDeselections(context, newDeselections);
    return {
      deselected: newDeselections,
      previousDeselected: getCumulativeDeselections(context),
    };
  }, ERROR_MESSAGES.DATA_PROCESSING_FAILED, () => ({
    deselected: [],
    previousDeselected: [],
  }));
}

/**
 * Transforms categories form data for submission.
 * @param {FormData} formData - The form data.
 * @returns {Object} Transformed data for API submission.
 */
export function transformCategoriesData(formData) {
  log('categories-data.js', 'Transforming categories form data');
  return {
    prompt: formData.get('prompt')?.trim(),
    categories: JSON.parse(formData.get('categories') || '{}'),
    deselected: JSON.parse(formData.get('deselected') || '[]'),
    previousDeselected: JSON.parse(formData.get('previousDeselected') || '[]'),
    selected: formData.getAll ? formData.getAll('selected') : [],
  };
}

/**
 * Validates categories form data.
 * @param {FormData} formData - The form data.
 * @returns {boolean} True if valid, false otherwise.
 */
export function validateCategoriesData(formData) {
  log('categories-data.js', 'Validating categories form data');
  return !!formData.get('prompt')?.trim();
}

/**
 * Initializes the categories data module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Categories data instance with public methods.
 */
export function initializeCategoriesDataModule(registry) {
  return createModuleInitializer('categories-data.js', {
    loadCategories,
    saveCategories,
    resetCategories,
    mergeDeselections,
    getCumulativeDeselections,
    updateDeselectedCategories,
    transformCategoriesData,
    validateCategoriesData,
  });
}

// Initialize module with lifecycle logging
const context = 'categories-data.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

community/categories-events.js

// /static/js/community/categories-events.js
// Purpose: Manages event listeners for category form interactions on the community categories page.

import { log } from '../core/logger.js';
import { setupEventListeners } from '../utils/event-listeners.js';
import { submitConfiguredForm, updateFormState } from '../utils/form-submission.js';
import { updateDeselectedCategories } from './categories-data.js';
import { updateCategoriesSection } from './categories-ui.js';
import { withElement } from '../utils/dom-manipulation.js';
import { notifyOperationResult } from '../core/notifications.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Sets up event listeners for category form interactions.
 * @param {string} context - The context or module name.
 * @returns {void}
 */
export function setupCategoryEvents(context) {
  log(context, 'Setting up category form event listeners');
  withErrorHandling(`${context}:setupCategoryEvents`, () => {
    setupEventListeners(context, [
      // Form submission for refining categories
      {
        eventType: 'submit',
        selector: '#categoryForm',
        handler: async (event) => {
          event.preventDefault();
          await withErrorHandling(`${context}:submitCategoryForm`, async () => {
            await submitConfiguredForm(context, 'categoryForm', API_ENDPOINTS.CATEGORIES, 'categories', {
              successMessage: SUCCESS_MESSAGES.CATEGORIES_SUBMITTED,
              onSuccess: (data) => updateCategoriesSection(context, data),
              onError: (error, formData) => {
                updateCategoriesSection(context, {
                  categories: JSON.parse(formData.get('categories') || '{}'),
                  deselected: JSON.parse(formData.get('deselected') || '[]'),
                  previousDeselected: JSON.parse(formData.get('previousDeselected') || '[]'),
                  selected: formData.getAll ? formData.getAll('selected') : [],
                  prompt: formData.get('prompt') || '',
                  errorMessage: error.message,
                });
              },
            });
          }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
        },
      },
      // Form submission for saving categories
      {
        eventType: 'click',
        selector: '[data-action="save-categories"]',
        handler: async () => {
          await withErrorHandling(`${context}:saveCategories`, async () => {
            await submitConfiguredForm(context, 'categoryForm', API_ENDPOINTS.SAVE_CATEGORIES, 'categories', {
              onSuccess: (data) => updateCategoriesSection(context, data),
            });
          }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
        },
      },
      // Form submission for resetting categories
      {
        eventType: 'click',
        selector: '[data-action="reset-categories"]',
        handler: async () => {
          await withErrorHandling(`${context}:resetCategories`, async () => {
            await submitConfiguredForm(context, 'reset-categories-form', API_ENDPOINTS.RESET_CATEGORIES, 'resetCategories', {
              onSuccess: (data) => updateCategoriesSection(context, data),
            });
          }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
        },
      },
      // Checkbox change for deselected categories
      {
        eventType: 'change',
        selector: 'input[data-deselected]',
        handler: async () => {
          await withErrorHandling(`${context}:updateDeselections`, async () => {
            await withElement(context, 'deselected', async (deselectedInput) => {
              await withElement(context, 'previousDeselected', async (previousDeselectedInput) => {
                const allCategories = Array.from(document.querySelectorAll('input[name="selected"]')).map(cb => cb.value);
                const selectedCategories = Array.from(document.querySelectorAll('input[name="selected"]:checked')).map(cb => cb.value);
                const { deselected, previousDeselected } = updateDeselectedCategories(context, selectedCategories, allCategories);
                await updateFormState(context, 'categoryForm', {
                  deselected: JSON.stringify(deselected),
                  previousDeselected: JSON.stringify(previousDeselected),
                });
                log(context, 'Updated deselections:', deselected);
              });
            }, 10, 100, true);
          }, ERROR_MESSAGES.DATA_PROCESSING_FAILED);
        },
      },
    ]);
  }, ERROR_MESSAGES.EVENT_HANDLER_FAILED);
}

/**
 * Initializes the categories events module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Categories events instance with public methods.
 */
export function initializeCategoriesEventsModule(registry) {
  return createModuleInitializer('categories-events.js', {
    setupCategoryEvents,
  });
}

// Initialize module with lifecycle logging
const context = 'categories-events.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

community/categories-navigation.js

// /static/js/community/categories-navigation.js
import { log } from '../core/logger.js';
import { defineSectionHandlers } from '../modules/navigation.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { toggleViewState } from '../utils/dom-manipulation.js';

/**
 * Sets up navigation for the community page.
 * @param {string} context - The context or module name.
 * @param {string} role - The role associated with the page (e.g., 'community').
 * @param {string} defaultSection - The default section to show (e.g., 'info').
 * @returns {Promise<void>}
 */
export async function setupCategoriesNavigation(context, role, defaultSection) {
  log(context, `Setting up navigation for role ${role}, section ${defaultSection}`);
  await withErrorHandling(`${context}:setupCategoriesNavigation`, async () => {
    defineSectionHandlers(context, 'community', [
      {
        id: 'info',
        handler: async () => {
          log(context, 'Loading info section');
          toggleViewState(context, { info: true });
        },
      },
      {
        id: 'categories',
        handler: async () => {
          log(context, 'Loading categories section');
          await import('./categories-page.js').then(m => m.initializeCategoriesPage(context));
        },
      },
      {
        id: 'providers',
        handler: async () => {
          log(context, 'Loading providers section');
          await import('./providers-page.js').then(m => m.initializeProvidersPage(context));
        },
      },
      {
        id: 'referrals',
        handler: async () => {
          log(context, 'Loading referrals section');
          await import('./referrals-page.js').then(m => m.initializeReferralsPage(context));
        },
      },
    ]);
  }, ERROR_MESSAGES.NAVIGATION_INIT_FAILED);
}

/**
 * Initializes the categories-navigation module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} CategoriesNavigation instance with public methods.
 */
export function initializeCategoriesNavigationModule(registry) {
  const context = 'categories-navigation.js';
  log(context, 'Initializing categories-navigation module for module registry');
  return {
    setupCategoriesNavigation: (ctx, ...args) => setupCategoriesNavigation(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'categories-navigation.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

community/categories-page.js

// /static/js/community/categories-page.js
// Purpose: Orchestrates the community categories page by coordinating data, UI, and event handling.

import { log } from '../core/logger.js';
import { loadCategories } from './categories-data.js';
import { renderCategoriesSection } from './categories-ui.js';
import { setupCategoryEvents } from './categories-events.js';
import { withAuthenticatedUser } from '../utils/auth.js';
import { setupCategoriesNavigation } from './categories-navigation.js';
import { getElements } from '../utils/dom-manipulation.js';
import { initializeTinyMCE } from '../core/mce.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withErrorHandling } from '../utils/error.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Initializes the categories page.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeCategoriesPage(context) {
  log(context, 'Initializing categories page');
  await withAuthenticatedUser(async (userId) => {
    await withErrorHandling(`${context}:initializeCategoriesPage`, async () => {
      await setupCategoriesNavigation(context, 'community', 'categories');
      const data = await loadCategories(context, userId, false);
      const elements = await getElements(context, ['categoriesSection', 'categoriesForm', 'categoryError', 'promptInput']);
      await renderCategoriesSection(context, data, elements);
      setupCategoryEvents(context);
      // Initialize TinyMCE for rich text editors
      await initializeTinyMCE(context, '#aboutCommunity, #stylingDetails, #page1Content');
    }, ERROR_MESSAGES.FETCH_FAILED('categories page initialization'));
  });
}

/**
 * Initializes the categories page module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Categories page instance with public methods.
 */
export function initializeCategoriesPageModule(registry) {
  const context = 'categories-page.js';
  log(context, 'Initializing categories page module for module registry');
  return {
    initializeCategoriesPage: (ctx) => initializeCategoriesPage(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'categories-page.js';
withScriptLogging(context, () => {
  initializeCategoriesPage(context);
});

community/categories-ui.js

// /static/js/community/categories-ui.js
// Purpose: Manages UI rendering for the community categories page.

import { log, warn } from '../core/logger.js';
import { toggleViewState } from '../utils/dom-manipulation.js';
import { success, error as notifyError } from '../core/notifications.js';
import { renderForm } from '../utils/form-rendering.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { getFormConfig } from '../config/form-configs.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Validates categories data structure.
 * @param {Object} categories - The categories data.
 * @returns {boolean} True if valid, false otherwise.
 */
function isValidCategories(categories) {
  return (
    typeof categories === 'object' &&
    !Array.isArray(categories) &&
    Object.keys(categories).length > 0 &&
    Object.keys(categories).length <= 7 &&
    Object.values(categories).every(
      subcats =>
        Array.isArray(subcats) &&
        subcats.length >= 1 &&
        subcats.length <= 7 &&
        subcats.every(s => typeof s === 'string'),
    )
  );
}

/**
 * Renders the categories section UI with the provided data.
 * @param {string} context - The context or module name.
 * @param {Object} data - The categories data to render.
 * @param {Object} elements - DOM elements configuration object.
 * @param {HTMLElement} elements.categoriesSection - The categories section element.
 * @param {HTMLElement} elements.formContainer - The form container element.
 * @param {HTMLElement} elements.errorDiv - The error div element.
 * @param {HTMLElement} elements.promptInput - The prompt input element.
 * @returns {Promise<void>}
 */
export async function renderCategoriesSection(context, data, { categoriesSection, formContainer, errorDiv, promptInput }) {
  log(context, 'Rendering categories section with data:', data);
  toggleViewState(context, { [errorDiv.id]: false });
  errorDiv.textContent = '';

  if (data.errorMessage) {
    errorDiv.textContent = data.errorMessage;
    toggleViewState(context, { [errorDiv.id]: true });
    notifyError(context, data.errorMessage);
  }

  const currentPrompt = promptInput.value || data.prompt || '';
  data.categories = data.categories || {};

  const formConfig = getFormConfig(context, 'categories', {
    currentPrompt,
    deselected: data.deselected || [],
    previousDeselected: data.previousDeselected || [],
    selected: data.selected || [],
    categories: data.categories,
    isValidCategories: isValidCategories(data.categories),
  });

  formContainer.innerHTML = renderForm(formConfig);
  success(context, SUCCESS_MESSAGES.CATEGORIES_RENDERED);
}

/**
 * Updates the categories section UI with new data.
 * @param {string} context - The context or module name.
 * @param {Object} data - The categories data to update the UI with.
 * @param {Object} elements - DOM elements configuration object.
 * @param {HTMLElement} elements.categoriesSection - The categories section element.
 * @param {HTMLElement} elements.formContainer - The form container element.
 * @param {HTMLElement} elements.errorDiv - The error div element.
 * @param {HTMLElement} elements.promptInput - The prompt input element.
 * @returns {Promise<void>}
 */
export async function updateCategoriesSection(context, data, elements) {
  log(context, 'Updating categories section with data:', data);
  await renderCategoriesSection(context, data, elements);
}

/**
 * Initializes the categories UI module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Categories UI instance with public methods.
 */
export function initializeCategoriesUiModule(registry) {
  const context = 'categories-ui.js';
  log(context, 'Initializing categories UI module for module registry');
  return {
    renderCategoriesSection: (ctx, ...args) => renderCategoriesSection(ctx, ...args),
    updateCategoriesSection: (ctx, ...args) => updateCategoriesSection(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'categories-ui.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

community/community-providers.js

// /static/js/community/community-providers.js
// Purpose: Initializes the community providers sub-page.

import { log } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { withAuthenticatedUser } from '../utils/auth.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { initializeProvidersPage } from './providers-page.js';
import { setupCategoriesNavigation } from './categories-navigation.js';
import { setupCollapsibleSections } from '../utils/dom-manipulation.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Initializes the community providers page.
 * @param {string} context - The context or module name.
 * @returns {void}
 */
export function initializeProviders(context) {
  log(context, 'Initializing providers page');
  withErrorHandling(`${context}:initializeProviders`, () => {
    withAuthenticatedUser(async userId => {
      const userIdInput = document.getElementById('userId');
      if (userIdInput) userIdInput.value = userId;
      setupCategoriesNavigation(context, 'community', 'providers');
      initializeProvidersPage(context);
      setupCollapsibleSections(context);
    });
  }, ERROR_MESSAGES.FETCH_FAILED('providers page initialization'));
}

/**
 * Initializes the community providers module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Community providers instance with public methods.
 */
export function initializeCommunityProvidersModule(registry) {
  const context = 'community-providers.js';
  log(context, 'Initializing community providers module for module registry');
  return {
    initializeProviders: (ctx) => initializeProviders(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'community-providers.js';
withScriptLogging(context, () => {
  initializeProviders(context);
});

community/providers-data.js

// /static/js/community/providers-data.js
// Purpose: Manages data fetching for provider settings on the community providers page.

import { log } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Loads client API settings from the server, with a fallback to hardcoded defaults.
 * @param {string} context - The context or module name.
 * @returns {Promise<Array>} The fetched or default provider settings.
 */
export async function loadClientApiSettings(context) {
  log(context, 'Loading client API settings');
  return await withErrorHandling(`${context}:loadClientApiSettings`, async () => {
    const data = await fetchData(context, API_ENDPOINTS.CLIENT_API_SETTINGS);
    return data.settings || [];
  }, ERROR_MESSAGES.FETCH_FAILED('client API settings'), () => [
    // Hardcoded fallback settings
    {
      "comment": "Wix CMS client API settings",
      "description": "Wix is a versatile website builder, offering clubmadeira.io API tools to integrate custom features into its CMS platform.",
      "doc_link": [
        { "link": "https://dev.wix.com/api/rest/wix-stores", "title": "api" },
        { "link": "https://www.wix.com/signup", "title": "signup" },
        { "link": "https://clubmadeira.io/static/md/wix_readme.md", "title": "readme" }
      ],
      "fields": { "API_TOKEN": "", "SITE_ID": "" },
      "icon": "icon-wix",
      "key_type": "wix"
    },
    {
      "comment": "WordPress CMS client API settings",
      "description": "WordPress, a popular open-source CMS, powers clubmadeira.io with extensible plugins and APIs for dynamic content management.",
      "doc_link": [
        { "link": "https://developer.wordpress.com/docs/api/", "title": "api" },
        { "link": "https://wordpress.com/start", "title": "signup" },
        { "link": "https://clubmadeira.io/static/md/wordpress_readme.md", "title": "readme" }
      ],
      "fields": { "API_KEY": "" },
      "icon": "icon-wordpress",
      "key_type": "wordpress"
    },
    {
      "comment": "Squarespace CMS client API settings",
      "description": "Squarespace provides an elegant CMS platform, integrating with clubmadeira.io via APIs for custom site enhancements.",
      "doc_link": [
        { "link": "https://developers.squarespace.com/", "title": "api" },
        { "link": "https://www.squarespace.com/signup", "title": "signup" },
        { "link": "https://clubmadeira.io/static/md/squarespace_readme.md", "title": "readme" }
      ],
      "fields": { "API_KEY": "" },
      "icon": "icon-squarespace",
      "key_type": "squarespace"
    },
    {
      "comment": "Weebly CMS client API settings",
      "description": "Weebly offers a user-friendly CMS, enabling clubmadeira.io to add custom features through its developer API.",
      "doc_link": [
        { "link": "https://www.weebly.com/developer", "title": "api" },
        { "link": "https://www.weebly.com/signup", "title": "signup" },
        { "link": "https://clubmadeira.io/static/md/weebly_readme.md", "title": "readme" }
      ],
      "fields": { "API_KEY": "" },
      "icon": "icon-weebly",
      "key_type": "weebly"
    },
    {
      "comment": "Joomla CMS client API settings",
      "description": "Joomla, an open-source CMS, supports clubmadeira.io with robust API capabilities for custom module development.",
      "doc_link": [
        { "link": "https://docs.joomla.org/Joomla_API", "title": "api" },
        { "link": "https://www.joomla.org/download.html", "title": "signup" },
        { "link": "https://clubmadeira.io/static/md/joomla_readme.md", "title": "readme" }
      ],
      "fields": { "API_KEY": "" },
      "icon": "icon-joomla",
      "key_type": "joomla"
    }
  ]);
}

/**
 * Initializes the providers-data module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} ProvidersData instance with public methods.
 */
export function initializeProvidersDataModule(registry) {
  const context = 'providers-data.js';
  log(context, 'Initializing providers-data module for module registry');
  return {
    loadClientApiSettings: ctx => loadClientApiSettings(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'providers-data.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

community/providers-events.js

// /static/js/community/providers-events.js
// Purpose: Manages UI rendering and event setup for the community providers page.

import { log } from '../core/logger.js';
import { renderSettings } from '../utils/settings-renderer.js';
import { toggleViewState } from '../utils/dom-manipulation.js';
import { renderMarkdownContent } from '../utils/form-rendering.js';
import { setupProviderEvents } from './providers-handlers.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Renders provider settings and sets up event listeners.
 * @param {string} context - The context or module name.
 * @param {Array} settings - The provider settings.
 * @param {string} containerId - The container element ID.
 * @returns {Promise<void>}
 */
export async function renderProviderSettings(context, settings, containerId) {
  log(context, 'Rendering provider settings');
  await renderSettings(context, {
    containerId,
    formId: 'providerForm',
    fieldsId: 'providerContentArea',
    settings,
    type: 'provider',
    iconClass: 'fas fa-cog',
    onIconClick: (setting, fieldsContainer, form) => {
      toggleViewState(context, { providerContentArea: true });
      Array.from(document.getElementById('providerIconsBar').children).forEach(child => {
        child.style.color = child.dataset.keyType === setting.keyType ? '#007bff' : '#C0C0C0';
      });
    },
    onReadmeClick: async setting => {
      const readmeLink = setting.docLink?.find(link => link.title === 'readme')?.link;
      if (readmeLink) {
        await renderMarkdownContent(readmeLink, `mdContent-${setting.keyType}`);
        toggleViewState(context, { [`mdContent-${setting.keyType}`]: true });
      }
    },
  });
  setupProviderEvents(context);
}

/**
 * Initializes the providers events module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Providers events instance with public methods.
 */
export function initializeProvidersEventsModule(registry) {
  const context = 'providers-events.js';
  log(context, 'Initializing providers events module for module registry');
  return {
    renderProviderSettings: (ctx, ...args) => renderProviderSettings(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'providers-events.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

community/providers-handlers.js

// /static/js/community/providers-handlers.js
// Purpose: Manages event listeners for provider form interactions on the community providers page.

import { log } from '../core/logger.js';
import { setupEventListeners } from '../utils/event-listeners.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { renderProviderSettings } from './providers-events.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Sets up event listeners for provider form interactions.
 * @param {string} context - The context or module name.
 * @returns {void}
 */
export function setupProviderEvents(context) {
  log(context, 'Setting up provider form event listeners');
  withErrorHandling(`${context}:setupProviderEvents`, () => {
    setupEventListeners(context, [
      // Form submission for provider settings
      {
        eventType: 'submit',
        selector: '#providerForm',
        handler: async (event) => {
          event.preventDefault();
          await withErrorHandling(`${context}:submitProviderForm`, async () => {
            await submitConfiguredForm(context, 'providerForm', API_ENDPOINTS.CLIENT_API_SETTINGS, 'providerSettings', {
              successMessage: SUCCESS_MESSAGES.SETTINGS_UPDATED,
              onSuccess: async (data) => {
                await renderProviderSettings(context, data.settings || [], 'providerIconsBar');
              },
              onError: (error) => {
                log(context, `Provider settings submission failed: ${error.message}`);
              },
            });
          }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
        },
      },
      // Icon click for provider settings
      {
        eventType: 'click',
        selector: '#providerIconsBar i[data-key-type]',
        handler: async (event) => {
          await withErrorHandling(`${context}:selectProviderSetting`, async () => {
            const keyType = event.target.dataset.keyType;
            log(context, `Selected provider setting: ${keyType}`);
            // Trigger rendering of specific provider settings
            const settings = await import('./providers-data.js').then(m => m.loadClientApiSettings(context));
            await renderProviderSettings(context, settings.filter(s => s.keyType === keyType), 'providerIconsBar');
          }, ERROR_MESSAGES.EVENT_HANDLER_FAILED);
        },
      },
    ]);
  }, ERROR_MESSAGES.EVENT_HANDLER_FAILED);
}

/**
 * Initializes the providers handlers module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Providers handlers instance with public methods.
 */
export function initializeProvidersHandlersModule(registry) {
  return createModuleInitializer('providers-handlers.js', {
    setupProviderEvents,
  });
}

// Initialize module with lifecycle logging
const context = 'providers-handlers.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

community/providers-page.js

// /static/js/community/providers-page.js
// Purpose: Orchestrates the community providers sub-page.

import { log } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { withAuthenticatedUser } from '../utils/auth.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { loadClientApiSettings } from './providers-data.js';
import { renderProviderSettings } from './providers-events.js';
import { setupCategoriesNavigation } from './categories-navigation.js';
import { setupCollapsibleSections } from '../utils/dom-manipulation.js';
import { initializeTinyMCE } from '../core/mce.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Initializes the community providers page.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeProvidersPage(context) {
  log(context, 'Initializing providers page');
  await withAuthenticatedUser(async userId => {
    await withErrorHandling(`${context}:initializeProvidersPage`, async () => {
      await setupCategoriesNavigation(context, 'community', 'providers');
      const userIdInput = document.getElementById('userId');
      if (userIdInput) userIdInput.value = userId;
      const settings = await loadClientApiSettings(context);
      await renderProviderSettings(context, settings, 'providerIconsBar');
      setupCollapsibleSections(context);
      await initializeTinyMCE(context, '#aboutCommunity, #stylingDetails, #page1Content');
    }, ERROR_MESSAGES.FETCH_FAILED('providers page initialization'));
  });
}

/**
 * Initializes the providers page module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Providers page instance with public methods.
 */
export function initializeProvidersPageModule(registry) {
  const context = 'providers-page.js';
  log(context, 'Initializing providers page module for module registry');
  return {
    initializeProvidersPage: (ctx) => initializeProvidersPage(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'providers-page.js';
withScriptLogging(context, () => {
  initializeProvidersPage(context);
});

community/referrals-data.js

// /static/js/community/referrals-data.js
// Purpose: Manages data fetching and processing for the community referrals page.

import { log } from '../core/logger.js';
import { authenticatedFetch } from '../core/auth.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Processes visits and orders data, splitting them by time periods.
 * @param {string} context - The context or module name.
 * @param {string} userId - The user ID.
 * @returns {Promise<{visits: Object, orders: Object}>} The processed visits and orders data.
 */
export async function processVisitsAndOrders(context, userId) {
  log(context, `Processing visits and orders for user: ${userId}`);
  return await withErrorHandling(`${context}:processVisitsAndOrders`, async () => {
    const visitsData = await loadVisits(context, userId);
    const ordersData = await loadOrders(context, userId);

    const now = new Date();
    const thisMonth = now.getMonth();
    const thisYear = now.getFullYear();

    const visits = {
      thisMonth: [],
      lastMonth: [],
      earlier: [],
    };
    visitsData.visits.forEach(visit => {
      const visitDate = new Date(visit.timestamp);
      if (visitDate.getFullYear() === thisYear && visitDate.getMonth() === thisMonth) {
        visits.thisMonth.push(visit);
 FAMILY      } else if (
        (visitDate.getFullYear() === thisYear && visitDate.getMonth() === thisMonth - 1) ||
        (visitDate.getFullYear() === thisYear - 1 && thisMonth === 0 && visitDate.getMonth() === 11)
      ) {
        visits.lastMonth.push(visit);
      } else {
        visits.earlier.push(visit);
      }
    });

    const orders = {
      thisMonth: [],
      lastMonth: [],
      earlier: [],
    };
    ordersData.orders.forEach(order => {
      const orderDate = new Date(order.timestamp);
      if (orderDate.getFullYear() === thisYear && orderDate.getMonth() === thisMonth) {
        orders.thisMonth.push(order);
      } else if (
        (orderDate.getFullYear() === thisYear && orderDate.getMonth() === thisMonth - 1) ||
        (orderDate.getFullYear() === thisYear - 1 && thisMonth === 0 && orderDate.getMonth() === 11)
      ) {
        orders.lastMonth.push(order);
      } else {
        orders.earlier.push(order);
      }
    });

    return { visits, orders };
  }, ERROR_MESSAGES.FETCH_FAILED('visits and orders processing'));
}

/**
 * Fetches visits data for the specified user.
 * @param {string} context - The context or module name.
 * @param {string} userId - The user ID.
 * @returns {Promise<Object>} The visits data.
 */
async function loadVisits(context, userId) {
  log(context, `Fetching visits for user: ${userId}`);
  return await withErrorHandling(`${context}:loadVisits`, async () => {
    const response = await authenticatedFetch(API_ENDPOINTS.VISITS(userId));
    const data = await response.json();
    if (data.status === 'error') {
      throw new Error(data.message || ERROR_MESSAGES.FETCH_FAILED('visits'));
    }
    return data;
  }, ERROR_MESSAGES.FETCH_FAILED('visits'));
}

/**
 * Fetches orders data for the specified user.
 * @param {string} context - The context or module name.
 * @param {string} userId - The user ID.
 * @returns {Promise<Object>} The orders data.
 */
async function loadOrders(context, userId) {
  log(context, `Fetching orders for user: ${userId}`);
  return await withErrorHandling(`${context}:loadOrders`, async () => {
    const response = await authenticatedFetch(API_ENDPOINTS.ORDERS(userId));
    const data = await response.json();
    if (data.status === 'error') {
      throw new Error(data.message || ERROR_MESSAGES.FETCH_FAILED('orders'));
    }
    return data;
  }, ERROR_MESSAGES.FETCH_FAILED('orders'));
}

/**
 * Initializes the referrals data module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Referrals data instance with public methods.
 */
export function initializeReferralsDataModule(registry) {
  const context = 'referrals-data.js';
  log(context, 'Initializing referrals data module for module registry');
  return {
    processVisitsAndOrders: (ctx, ...args) => processVisitsAndOrders(ctx, ...args),
    loadVisits: (ctx, ...args) => loadVisits(ctx, ...args),
    loadOrders: (ctx, ...args) => loadOrders(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'referrals-data.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

community/referrals-page.js

// /static/js/community/referrals-page.js
// Purpose: Orchestrates the community referrals page by coordinating data and UI updates.

import { log } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { withAuthenticatedUser } from '../utils/auth.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { processVisitsAndOrders } from './referrals-data.js';
import { updateVisitsTable, updateOrdersTable } from './referrals-ui.js';
import { setupCategoriesNavigation } from './categories-navigation.js';
import { setupCollapsibleSections } from '../utils/dom-manipulation.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Initializes the referrals page.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeReferralsPage(context) {
  log(context, 'Initializing referrals page');
  await withAuthenticatedUser(async userId => {
    await withErrorHandling(`${context}:initializeReferralsPage`, async () => {
      await setupCategoriesNavigation(context, 'community', 'referrals');
      const { visits, orders } = await processVisitsAndOrders(context, userId);
      updateVisitsTable(context, { visits });
      updateOrdersTable(context, { orders });
      setupCollapsibleSections(context);
    }, ERROR_MESSAGES.FETCH_FAILED('referrals page initialization'));
  });
}

/**
 * Initializes the referrals page module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Referrals page instance with public methods.
 */
export function initializeReferralsPageModule(registry) {
  const context = 'referrals-page.js';
  log(context, 'Initializing referrals page module for module registry');
  return {
    initializeReferralsPage: (ctx) => initializeReferralsPage(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'referrals-page.js';
withScriptLogging(context, () => {
  initializeReferralsPage(context);
});

community/referrals-ui.js

// /static/js/community/referrals-ui.js
// Purpose: Manages UI rendering for the community referrals page, including visits and orders tables.

import { log } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { notifyOperationResult } from '../core/notifications.js';
import { renderDataTable } from '../utils/ui-components.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Updates the visits table with the provided data.
 * @param {string} context - The context or module name.
 * @param {Object} data - The visits data, with properties thisMonth, lastMonth, and earlier.
 * @returns {void}
 */
export function updateVisitsTable(context, data) {
  log(context, 'Updating visits table');
  withErrorHandling(`${context}:updateVisitsTable`, () => {
    const visitList = document.getElementById('visitList');
    if (!visitList) {
      throw new Error(ERROR_MESSAGES.ELEMENT_NOT_FOUND);
    }

    const headers = ['Date', 'User ID', 'Page', 'Referrer'];
    const rowMapper = visit => [
      visit.date || 'N/A',
      visit.userId || 'N/A',
      visit.page || 'N/A',
      visit.referrer || 'N/A',
    ];

    const visits = [
      ...(data.visits?.thisMonth || []),
      ...(data.visits?.lastMonth || []),
      ...(data.visits?.earlier || []),
    ];

    visitList.innerHTML = renderDataTable(context, {
      data: visits,
      headers,
      rowMapper,
      emptyMessage: ERROR_MESSAGES.NO_DATA('visits'),
    });

    notifyOperationResult(context, {
      success: true,
      message: visits.length ? `${visits.length} visits loaded` : ERROR_MESSAGES.NO_DATA('visits'),
      defaultSuccess: SUCCESS_MESSAGES.DEFAULT,
    });
  }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Updates the orders table with the provided data.
 * @param {string} context - The context or module name.
 * @param {Object} data - The orders data, with properties thisMonth, lastMonth, and earlier.
 * @returns {void}
 */
export function updateOrdersTable(context, data) {
  log(context, 'Updating orders table');
  withErrorHandling(`${context}:updateOrdersTable`, () => {
    const orderList = document.getElementById('orderList');
    if (!orderList) {
      throw new Error(ERROR_MESSAGES.ELEMENT_NOT_FOUND);
    }

    const headers = ['Order ID', 'User ID', 'Product', 'Amount', 'Date'];
    const rowMapper = order => [
      order.orderId || 'N/A',
      order.userId || 'N/A',
      order.product || 'N/A',
      order.amount || 'N/A',
      order.date || 'N/A',
    ];

    const orders = [
      ...(data.orders?.thisMonth || []),
      ...(data.orders?.lastMonth || []),
      ...(data.orders?.earlier || []),
    ];

    orderList.innerHTML = renderDataTable(context, {
      data: orders,
      headers,
      rowMapper,
      emptyMessage: ERROR_MESSAGES.NO_DATA('orders'),
    });

    notifyOperationResult(context, {
      success: true,
      message: orders.length ? `${orders.length} orders loaded` : ERROR_MESSAGES.NO_DATA('orders'),
      defaultSuccess: SUCCESS_MESSAGES.DEFAULT,
    });
  }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Initializes the referrals-ui module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} ReferralsUi instance with public methods.
 */
export function initializeReferralsUiModule(registry) {
  const context = 'referrals-ui.js';
  log(context, 'Initializing referrals-ui module for module registry');
  return {
    updateVisitsTable: (ctx, ...args) => updateVisitsTable(ctx, ...args),
    updateOrdersTable: (ctx, ...args) => updateOrdersTable(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'referrals-ui.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

community-page.js

// /static/js/community-page.js
// Purpose: Orchestrates the community page, coordinating navigation, events, and module initialization.
const context = 'community-page.js';
import { log } from './core/logger.js';
import { parsePageType, initializeRolePage } from './utils/initialization.js';
import { withScriptLogging, hideOverlay } from './utils/logging-utils.js';
import { setupCategoriesNavigation } from './community/categories-navigation.js';
import { initializeCategoriesPage } from './community/categories-page.js';
import { initializeProvidersPage } from './community/providers-page.js';
import { initializeReferralsPage } from './community/referrals-page.js';

/**
 * Initializes the community page.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeCommunityPage(context) {
  log(context, 'Initializing community page');
  const pageType = parsePageType(context, 'page', 'categories');
  await initializeRolePage(context, 'community', pageType, async () => {
    setupCategoriesNavigation(context, 'community', pageType);
    switch (pageType) {
      case 'categories':
        await initializeCategoriesPage(context);
        break;
      case 'providers':
        await initializeProvidersPage(context);
        break;
      case 'referrals':
        await initializeReferralsPage(context);
        break;
      default:
        log(context, `Unknown page type: ${pageType}`);
    }
  });
}

/**
 * Initializes the community-page module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} CommunityPage instance with public methods.
 */
export function initializeCommunityPageModule(registry) {
  const context = 'community-page.js';
  log(context, 'Initializing community-page module for module registry');
  return {
    initializeCommunityPage: ctx => initializeCommunityPage(ctx),
  };
}

// Initialize module with lifecycle logging
withScriptLogging(context, async () => {
    log(context, 'Module initialized');
    await initializeCommunityPage(context);
    hideOverlay();
});

config/constants.js

// /static/js/config/constants.js
// Purpose: Centralizes constants for the application by re-exporting from other modules.

import { log } from '../core/logger.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { API_ENDPOINTS } from './endpoints.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from './messages.js';

const context = 'constants.js';

// Export the constants for use in other modules
export { API_ENDPOINTS, ERROR_MESSAGES, SUCCESS_MESSAGES };

/**
 * Initializes the constants module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Constants instance with public constants.
 */
export function initializeConstantsModule(registry) {
    log(context, 'Initializing constants module for module registry');
    return {
        API_ENDPOINTS,
        ERROR_MESSAGES,
        SUCCESS_MESSAGES,
    };
}

// Initialize module with lifecycle logging
withScriptLogging(context, () => {
    log(context, 'Module initialized');
});

config/endpoints.js

// /static/js/config/endpoints.js
// Purpose: Defines API endpoints for the application, centralizing all API routes for consistent usage.

import { log } from '../core/logger.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * API endpoint definitions with parameterized routes where applicable.
 * @type {Object.<string, string|Function>}
 */
export const API_ENDPOINTS = {
  // Admin endpoints
  SETTINGS_AFFILIATE: '/settings/affiliate',
  SETTINGS_API_KEY: '/settings/api-key',
  SETTINGS_KEY: '/settings/site',
  USERS_ROLE: role => `/users/role/${role}`,
  USERS_USERID: userId => `/users/${userId}`,
  PERMISSION: '/permissions',
  DEALS: '/deals',

  // Community endpoints
  CATEGORIES: '/categories',
  SAVE_CATEGORIES: '/categories/save',
  RESET_CATEGORIES: '/categories/reset',
  CLIENT_API_SETTINGS: '/settings/client_api',
  CHECK_DOMAIN: '/check-domain',
  VISITS: userId => `/visits/${userId}`,
  ORDERS: userId => `/orders/${userId}`,

  // Partner endpoints
  CLIENT_API: '/client-api',

  // User settings endpoints
  SETTINGS_USER: '/settings/user',
  UPDATE_PASSWORD: '/update-password',

  // Site request endpoint
  SITE_REQUEST: userId => `/site-request/${userId}`,

  // Merchant endpoints
  API_KEY: '/settings/api_key',
  PRODUCTS: '/settings/products',

  // Login endpoints
  LOGIN: '/',
  RESET_PASSWORD: '/reset-password',
  VERIFY_RESET_CODE: '/verify-reset-code',
  SIGNUP: '/signup',
  VERIFY_TOKEN: '/verify-token',
};

/**
 * Initializes the endpoints module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Endpoints instance with public endpoints.
 */
export function initializeEndpointsModule(registry) {
  const context = 'endpoints.js';
  log(context, 'Initializing endpoints module for module registry');
  return {
    API_ENDPOINTS,
  };
}

/**
 * Initializes the endpoints module.
 */
export function initializeEndpoints() {
  withScriptLogging('endpoints.js', () => {
    log('endpoints.js', 'Module initialized');
  });
}

config/form-configs.js

// /static/js/config/form-configs.js
import { log } from '../core/logger.js';
import { validatePhoneNumber } from '../utils/form-submission.js';
import { isValidEmail } from '../utils/form-validation-utils.js';
import { renderStyles } from '../utils/form-rendering.js';
import { renderCheckboxList } from '../utils/ui-components.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from './messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { createModuleInitializer } from '../utils/initialization.js';

const context = 'form-configs.js';

/**
 * Generates fields for a category form based on provided data.
 * @param {string} context - The context or module name.
 * @param {Object} [options={}] - Options for generating fields (e.g., defaults, category data).
 * @returns {Array} Array of field configurations.
 */
function generateCategoryFields(context, options = {}) {
  log(context, 'Generating category form fields');
  const { defaults = {}, category = {} } = options;
  return [
    {
      type: 'text',
      id: 'category_name',
      name: 'category_name',
      label: 'Category Name',
      required: true,
      value: category.name || defaults.name || '',
      style: renderStyles('categories', { width: '100%', padding: '8px' }),
    },
    {
      type: 'textarea',
      id: 'category_description',
      name: 'category_description',
      label: 'Description',
      value: category.description || defaults.description || '',
      style: renderStyles('categories', { width: '100%', padding: '8px' }),
    },
  ];
}

/**
 * Generates custom fields for a category form based on provided data.
 * @param {string} context - The context or module name.
 * @param {Object} [options={}] - Options for generating fields (e.g., custom fields).
 * @returns {Array} Array of custom field configurations.
 */
function generateCategoryCustomFields(context, options = {}) {
  log(context, 'Generating category custom form fields');
  const { customFields = [] } = options;
  return customFields.map((field, index) => ({
    type: field.type || 'text',
    id: `custom_field_${index}`,
    name: `custom_field_${field.key || index}`,
    label: field.label || `Custom Field ${index + 1}`,
    required: field.required || false,
    value: field.value || '',
    style: renderStyles('categories', { width: '100%', padding: '8px' }),
  }));
}

/**
 * Generates a categories form configuration based on provided data.
 * @param {string} context - The context or module name.
 * @param {Object} [options={}] - Options for generating the form (e.g., defaults, category data).
 * @returns {Object} The categories form configuration.
 */
function getCategoriesFormConfig(context, options = {}) {
  log(context, 'Generating categories form config');
  const { defaults = {}, category = {}, customFields = [] } = options;
  return {
    id: 'categoriesForm',
    action: '/categories',
    method: 'POST',
    submitButtonText: 'Save Category',
    successMessage: 'Category saved successfully!',
    transform: formData => {
      const customFieldEntries = Array.from(formData.entries())
        .filter(([key]) => key.startsWith('custom_field_'))
        .map(([key, value]) => ({ key: key.replace('custom_field_', ''), value }));
      return {
        name: formData.get('category_name')?.trim(),
        description: formData.get('category_description')?.trim(),
        custom_fields: customFieldEntries,
      };
    },
    validate: formData => {
      try {
        return !!formData.get('category_name')?.trim();
      } catch (err) {
        throw new Error(err.message || ERROR_MESSAGES.FORM_VALIDATION_FAILED);
      }
    },
    validationError: 'Please enter a valid category name.',
    fetchOptions: {
      headers: { 'Content-Type': 'application/json' },
    },
    fields: [
      ...generateCategoryFields(context, { defaults, category }),
      ...generateCategoryCustomFields(context, { customFields }),
    ],
    requiresAuth: true,
  };
}

/**
 * Form configuration registry.
 * @type {Object.<string, Object>}
 */
const FORM_CONFIGS = {
  login: {
    id: 'loginForm',
    action: '/',
    method: 'POST',
    submitButtonText: 'Login',
    successMessage: 'Login successful!',
    transform: formData => ({
      email: formData.get('email')?.trim(),
      password: formData.get('password'),
    }),
    validate: formData => {
      try {
        return (
          !!formData.get('email')?.trim() &&
          isValidEmail('login', formData.get('email')) &&
          !!formData.get('password')
        );
      } catch (err) {
        throw new Error(err.message || ERROR_MESSAGES.FORM_VALIDATION_FAILED);
      }
    },
    validationError: 'Please enter a valid email and password.',
    fetchOptions: {
      headers: { 'Content-Type': 'application/json' },
    },
    fields: [
      {
        type: 'email',
        name: 'email',
        label: 'Email',
        required: true,
        attributes: { placeholder: 'Enter your email', id: 'loginEmail', autocomplete: 'off' },
      },
      {
        type: 'password',
        name: 'password',
        label: 'Password',
        required: true,
        attributes: {
          placeholder: 'Enter your password',
          id: 'loginPassword',
          autocomplete: 'off',
        },
        wrapper: {
          class: 'password-wrapper',
          style: 'position: relative; width: 100%;',
        },
        extraButtons: [
          {
            type: 'button',
            text: '<i class="fas fa-eye"></i>',
            className: 'toggle-password',
            style: 'position: absolute; right: 10px; top: 50%; transform: translateY(-50%); cursor: pointer; background: none; border: none; font-size: 16px; color: #666;',
          },
        ],
      },
    ],
    requiresAuth: false,
  },
  setPassword: {
    id: 'setPasswordForm',
    action: '/complete-signup',
    method: 'POST',
    submitButtonText: 'Set Password',
    successMessage: 'Password set successfully!',
    transform: formData => ({
      email: formData.get('email')?.trim(),
      password: formData.get('password'),
      confirm_password: formData.get('confirm_password'),
      set_password: formData.get('set_password'),
    }),
    validate: formData => {
      try {
        const email = formData.get('email')?.trim();
        const password = formData.get('password');
        const confirmPassword = formData.get('confirm_password');
        return (
          !!email &&
          isValidEmail('setPassword', email) &&
          !!password &&
          password === confirmPassword
        );
      } catch (err) {
        throw new Error(err.message || ERROR_MESSAGES.FORM_VALIDATION_FAILED);
      }
    },
    validationError: 'Please enter a valid email and ensure passwords match.',
    fetchOptions: {
      headers: { 'Content-Type': 'application/json' },
    },
    fields: [
      {
        type: 'email',
        name: 'email',
        label: 'Email',
        required: true,
        attributes: { id: 'email', autocomplete: 'off' },
      },
      {
        type: 'password',
        name: 'password',
        label: 'Password',
        required: true,
        attributes: { id: 'password', placeholder: 'Enter your password', autocomplete: 'new-password' },
        wrapper: {
          class: 'password-wrapper',
          style: 'position: relative; width: 100%;',
        },
        extraButtons: [
          {
            type: 'button',
            text: '<i class="fas fa-eye"></i>',
            className: 'toggle-password',
            style: 'position: absolute; right: 10px; top: 50%; transform: translateY(-50%); cursor: pointer; background: none; border: none; font-size: 16px; color: #666;',
          },
        ],
      },
      {
        type: 'password',
        name: 'confirm_password',
        label: 'Confirm Password',
        required: true,
        attributes: { id: 'confirmPassword', placeholder: 'Confirm your password', autocomplete: 'new-password' },
        wrapper: {
          class: 'password-wrapper',
          style: 'position: relative; width: 100%;',
        },
        extraButtons: [
          {
            type: 'button',
            text: '<i class="fas fa-eye"></i>',
            className: 'toggle-password',
            style: 'position: absolute; right: 10px; top: 50%; transform: translateY(-50%); cursor: pointer; background: none; border: none; font-size: 16px; color: #666;',
          },
        ],
      },
      {
        type: 'hidden',
        name: 'set_password',
        value: 'true',
      },
    ],
    requiresAuth: false,
  },
  signup: {
    id: 'signupForm',
    action: '/signup',
    method: 'POST',
    submitButtonText: 'Sign Me Up',
    successMessage: 'Signup submitted successfully!',
    transform: formData => ({
      signup_type: formData.get('signup_type')?.trim(),
    }),
    validate: formData => {
      log(context, 'Validating signup form, formData type:', formData.constructor.name);
      try {
        return !!formData.get('signup_type')?.trim();
      } catch (err) {
        throw new Error(err.message || ERROR_MESSAGES.FORM_VALIDATION_FAILED);
      }
    },
    validationError: 'Please select a signup type.',
    fetchOptions: {
      headers: { 'Content-Type': 'application/json' },
    },
    fields: [
      {
        type: 'radio',
        name: 'signup_type',
        label: 'Signup Type',
        required: true,
        attributes: { id: 'signup_type', autocomplete: 'off' },
        options: [
          { value: 'community', label: 'Community' },
          { value: 'seller', label: 'Merchant' },
          { value: 'partner', label: 'Partner' },
        ],
      },
    ],
    requiresAuth: false,
  },
  forgotPassword: {
    id: 'forgotPasswordForm',
    action: '/reset-password',
    method: 'POST',
    submitButtonText: 'Send OTP via SMS',
    successMessage: 'OTP sent successfully! Please check your SMS.',
    transform: formData => ({
      email: formData.get('email')?.trim(),
    }),
    validate: formData => {
      try {
        return !!formData.get('email')?.trim() && isValidEmail('forgotPassword', formData.get('email'));
      } catch (err) {
        throw new Error(err.message || ERROR_MESSAGES.FORM_VALIDATION_FAILED);
      }
    },
    validationError: 'Please enter a valid email.',
    fetchOptions: {
      headers: { 'Content-Type': 'application/json' },
    },
    fields: [
      {
        type: 'email',
        name: 'email',
        label: 'Email',
        required: true,
        attributes: { id: 'forgotEmail', autocomplete: 'off' },
      },
    ],
    requiresAuth: false,
  },
  verifyOtp: {
    id: 'verifyOtpForm',
    action: '/verify-signup-otp',
    method: 'POST',
    submitButtonText: 'Set Password',
    successMessage: 'Password set successfully!',
    transform: formData => ({
      email: formData.get('email')?.trim(),
      otp: formData.get('otp')?.trim(),
      new_password: formData.get('new_password'),
      otp_token: formData.get('otp_token'),
    }),
    validate: formData => {
      try {
        return (
          !!formData.get('email')?.trim() &&
          isValidEmail('verifyOtp', formData.get('email')) &&
          !!formData.get('otp')?.trim() &&
          !!formData.get('new_password') &&
          formData.get('new_password') === formData.get('confirm_new_password')
        );
      } catch (err) {
        throw new Error(err.message || ERROR_MESSAGES.FORM_VALIDATION_FAILED);
      }
    },
    validationError: 'Please complete all fields correctly and ensure passwords match.',
    fetchOptions: {
      headers: { 'Content-Type': 'application/json' },
    },
    fields: [
      {
        type: 'email',
        name: 'email',
        label: 'Email',
        required: true,
        attributes: { id: 'verifyEmail', autocomplete: 'off' },
      },
      {
        type: 'text',
        name: 'otp',
        label: 'One-Time Password',
        required: true,
        attributes: { id: 'otpCode', autocomplete: 'off' },
      },
      {
        type: 'password',
        name: 'new_password',
        label: 'New Password',
        required: true,
        attributes: { id: 'newPassword', autocomplete: 'new-password' },
        wrapper: {
          class: 'password-wrapper',
          style: 'position: relative; width: 100%;',
        },
        extraButtons: [
          {
            type: 'button',
            text: '<i class="fas fa-eye"></i>',
            className: 'toggle-password',
            style: 'position: absolute; right: 10px; top: 50%; transform: translateY(-50%); cursor: pointer; background: none; border: none; font-size: 16px; color: #666;',
          },
        ],
      },
      {
        type: 'password',
        name: 'confirm_new_password',
        label: 'Confirm New Password',
        required: true,
        attributes: { id: 'confirmNewPassword', autocomplete: 'new-password' },
        wrapper: {
          class: 'password-wrapper',
          style: 'position: relative; width: 100%;',
        },
        extraButtons: [
          {
            type: 'button',
            text: '<i class="fas fa-eye"></i>',
            className: 'toggle-password',
            style: 'position: absolute; right: 10px; top: 50%; transform: translateY(-50%); cursor: pointer; background: none; border: none; font-size: 16px; color: #666;',
          },
        ],
      },
      {
        type: 'hidden',
        name: 'otp_token',
        attributes: { id: 'otpToken' },
      },
    ],
    requiresAuth: false,
  },
  userSettings: {
    id: 'userSettingsForm',
    action: '/settings/user',
    method: 'PATCH',
    submitButtonText: 'Save Settings',
    successMessage: 'User settings updated successfully!',
    transform: formData => ({
      contact_name: formData.get('contact_name')?.trim(),
      email_address: formData.get('email_address')?.trim(),
      phone_number: formData.get('phone_number')?.trim(),
    }),
    validate: formData => {
      try {
        return (
          !!formData.get('contact_name')?.trim() &&
          !!formData.get('email_address')?.trim() &&
          isValidEmail('userSettings', formData.get('email_address')) &&
          validatePhoneNumber('userSettings', formData.get('phone_number'))
        );
      } catch (err) {
        throw new Error(err.message || ERROR_MESSAGES.FORM_VALIDATION_FAILED);
      }
    },
    validationError: 'Please complete all fields correctly.',
    fetchOptions: {
      headers: { 'Content-Type': 'application/json' },
    },
    fields: [
      {
        type: 'text',
        name: 'contact_name',
        label: 'Name',
        required: true,
        attributes: { id: 'contact_name' },
      },
      {
        type: 'email',
        name: 'email_address',
        label: 'Email',
        required: true,
        attributes: { id: 'email_address' },
      },
      {
        type: 'tel',
        name: 'phone_number',
        label: 'Phone Number',
        required: true,
        attributes: { id: 'phone_number' },
      },
    ],
    requiresAuth: true,
  },
  categories: getCategoriesFormConfig,
};

/**
 * Retrieves a form configuration by key, optionally merging with dynamic options.
 * @param {string} context - The context or module name.
 * @param {string} configKey - The key for the form configuration (e.g., 'login', 'categories').
 * @param {Object} [options={}] - Dynamic options to merge with the configuration.
 * @returns {Object} The form configuration.
 */
export function getFormConfig(context, configKey, options = {}) {
  log(context, `Retrieving form config for key: ${configKey}`);
  if (!configKey || typeof configKey !== 'string') {
    log(context, `Invalid form configuration key: ${configKey}`);
    return {};
  }
  const config = FORM_CONFIGS[configKey];
  if (!config) {
    log(context, `No form configuration found for key: ${configKey}`);
    return {};
  }
  if (typeof config === 'function') {
    return config(context, options);
  }
  if (!config.method) {
    log(context, `Invalid configuration for key: ${configKey} - missing method`);
    return {};
  }
  return { ...config, ...options };
}

/**
 * Initializes the form configs module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Form configs instance with public methods.
 */
export function initializeFormConfigsModule(registry) {
  return createModuleInitializer('form-configs.js', {
    getFormConfig,
    getCategoriesFormConfig,
  });
}

// Initialize module with lifecycle logging
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

config/menus.js

// /static/js/config/menus.js
import { log } from '../core/logger.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { ROLES } from './roles.js';

log('menus.js', 'ROLES at import:', ROLES, 'ROLES.login:', ROLES.login);

// Define menu configurations for each role using string keys
export const MENUS = {
    'admin': [
        { id: 'users', label: 'Users', section: 'usersSection' },
        { id: 'deals', label: 'Deals', section: 'dealsSection' },
        { id: 'settings', label: 'Settings', section: 'settingsSection' },
        { id: 'my-account', label: 'My Account', section: 'my-account' },
        { id: 'contact-details', label: 'Contact Details', section: 'contact-details' },
        { id: 'change-password', label: 'Change Password', section: 'change-password' },
    ],
    'merchant': [
        { id: 'store-request', label: 'Store Request', section: 'storeRequestSection' },
        { id: 'api-keys', label: 'API Keys', section: 'apiKeysSection' },
        { id: 'products', label: 'Products', section: 'productsSection' },
        { id: 'documentation', label: 'Documentation', section: 'documentationSection' },
        { id: 'my-account', label: 'My Account', section: 'my-account' },
        { id: 'contact-details', label: 'Contact Details', section: 'contact-details' },
        { id: 'change-password', label: 'Change Password', section: 'change-password' },
    ],
    'community': [
        { id: 'site-request', label: 'Site Request', section: 'siteRequestSection' },
        { id: 'categories', label: 'Categories', section: 'categoriesSection' },
        { id: 'providers', label: 'Providers', section: 'providersSection' },
        { id: 'referrals', label: 'Referrals', section: 'referralsSection' },
        { id: 'my-account', label: 'My Account', section: 'my-account' },
        { id: 'contact-details', label: 'Contact Details', section: 'contact-details' },
        { id: 'change-password', label: 'Change Password', section: 'change-password' },
    ],
    'partner': [
        { id: 'integrations', label: 'Integrations', section: 'integrationsSection' },
        { id: 'my-account', label: 'My Account', section: 'my-account' },
        { id: 'contact-details', label: 'Contact Details', section: 'contact-details' },
        { id: 'change-password', label: 'Change Password', section: 'change-password' },
    ],
    'login': [
        { id: 'forgot-password', label: 'Forgot Password', section: 'forgotPasswordContainer', icon: 'fas fa-lock' },
        { id: 'signup', label: 'Sign Up', section: 'signupContainer', icon: 'fas fa-user-plus' },
    ],
};

/**
 * Retrieves the menu configuration for a given role.
 * @param {string} role - The role for which to retrieve the menu.
 * @returns {Array} The menu configuration for the role, or an empty array if not found.
 */
export function getMenu(role) {
    log(`menus.js - Retrieving menu for role: ${role}`);
    const menu = MENUS[role] || [];
    if (!menu.length) {
        log(`menus.js - No menu found for role: ${role}`);
    }
    return menu;
}

/**
 * Initializes the menus module for use with the module registry.
 * @param {Map} registry - The module registry instance.
 * @returns {Object} Module instance with public methods.
 */
export function initializeMenusModule(registry) {
    const context = 'menus.js';
    log(context, 'Initializing menus module for module registry');
    return {
        getMenu: (role) => getMenu(role),
    };
}

// Initialize the module with lifecycle logging
const context = 'menus.js';
withScriptLogging(context, () => {
    log(context, 'Module initialized');
});

config/messages.js

// /static/js/config/messages.js
// Purpose: Defines error and success messages for consistent use across the application.

export const ERROR_MESSAGES = {
    DEFAULT: 'An unexpected error occurred. Please try again.',
    FETCH_FAILED: context => `Failed to fetch ${context} data.`,
    NO_DATA: context => `No ${context} available.`,
    RENDER_FAILED: context => `Failed to render ${context} data.`,
    ELEMENT_NOT_FOUND: 'Required DOM element not found.',
    INVALID_TABLE_BODY: 'Invalid table body element.',
    TABLE_NOT_FOUND: 'Parent table not found.',
    DATA_PROCESSING_FAILED: 'Failed to process data.',
    INVALID_SETTINGS_TYPE: 'Invalid settings type specified.',
    NO_ENDPOINT: 'No API endpoint provided.',
    INVALID_SETTINGS_DATA: 'Invalid settings data received.',
    NO_SETTINGS_FOUND: 'No settings found.',
    ALL_FIELDS_REQUIRED: 'All fields are required.',
    FORM_SUBMISSION_FAILED: 'Form submission failed.',
    FORM_VALIDATION_FAILED: 'Form validation failed.',
    CUSTOM_FIELD_RENDER_FAILED: 'Failed to render custom form fields.',
    MARKDOWN_RENDER_FAILED: 'Failed to render markdown content.',
    NAVIGATION_INIT_FAILED: 'Failed to initialize navigation.',
    MODULE_INIT_FAILED: 'Failed to initialize module.',
    USER_ID_NOT_FOUND: 'User ID not found.',
    EVENT_HANDLER_FAILED: 'Event handler failed.',
    SECTION_TOGGLE_FAILED: 'Failed to toggle section.',
    NO_DOMAIN: 'Domain is required.',
    INVALID_DOMAIN: 'Invalid domain format.',
};

export const SUCCESS_MESSAGES = {
    DEFAULT: 'Operation successful.',
    RENDERED: context => `${context} successfully rendered.`,
    SUBMITTED: context => `${context} successfully submitted.`,
    SETTINGS_UPDATED: 'Settings successfully updated.',
};

config/pages.js

// /static/js/config/pages.js
// Purpose: Maps page types to their corresponding module paths for dynamic imports in main.js.

import { log } from '../core/logger.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Page module mappings for dynamic imports.
 * @type {Object.<string, string[]>}
 */
export const PAGE_MODULES = {
  admin: ['./admin/admin-page.js'],
  login: ['./login-page.js'],
  merchant: ['./merchant/category-management.js', './merchant/site-request.js', './merchant/merchant-page.js'],
  partner: ['./partner/partner-page.js'],
  community: ['./community/category-management.js', './community/site-request.js', './community/community-page.js'],
};

/**
 * Initializes the pages module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Pages instance with public mappings.
 */
export function initializePagesModule(registry) {
  const context = 'pages.js';
  log(context, 'Initializing pages module for module registry');
  return {
    PAGE_MODULES,
  };
}

// Initialize module with lifecycle logging
const context = 'pages.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

config/roles.js

// /static/js/config/roles.js
// Purpose: Centralizes role definitions, permissions, and menu structures for consistent use across the application.

import { log } from '../core/logger.js';
import { setAuthToken } from '../core/auth.js'; // Use setAuthToken from core/auth.js
import { authenticatedFetch } from '../core/auth.js'; // authenticatedFetch is in utils/auth.js
import { withErrorHandling } from '../utils/error.js';
import { withScriptLogging } from '../utils/logging-utils.js';

const context = 'roles.js';

/**
 * Role definitions with associated permissions.
 * @type {Object.<string, {permissions: string[], label: string}>}
 */
export const ROLES = {
    admin: {
        permissions: ['admin', 'validated', 'debug'],
        label: 'Admin',
    },
    partner: {
        permissions: ['partner', 'validated', 'verified'],
        label: 'Partner',
    },
    community: {
        permissions: ['community', 'validated'],
        label: 'Community',
    },
    merchant: {
        permissions: ['merchant', 'validated', 'verified'],
        label: 'Merchant',
    },
    login: { // Added login role to match config/menus.js
        permissions: [],
        label: 'Login',
    },
};

/**
 * Menu structure for admin role.
 * @type {Array}
 */
export const ADMIN_MENU = [
    {
        section: 'userManagementIntro',
        label: 'User Management',
        icons: ['fas fa-users'],
        submenu: [
            { section: 'user_management', label: 'Admin', icons: ['icon-admin'], role: 'admin' },
            { section: 'user_management', label: 'Partners', icons: ['icon-partner'], role: 'partner' },
            { section: 'user_management', label: 'Communities', icons: ['icon-community'], role: 'community' },
            { section: 'user_management', label: 'Merchants', icons: ['icon-merchant'], role: 'merchant' },
        ],
    },
    { section: 'affiliates', label: 'Affiliate Programs', icons: ['fas fa-link'] },
    { section: 'site_settings', label: 'Site Settings', icons: ['fas fa-cog'] },
    {
        section: 'testScriptsIntro',
        label: 'Test Scripts',
        icons: ['fas fa-vial'],
        submenu: [
            {
                section: 'test_partner',
                label: 'Test Partner',
                icons: ['icon-partner', 'fas fa-vial'],
                action: async context => {
                    log(context, 'Test Partner button clicked, showing overlay and calling /set-role');
                    window.showLoadingOverlay?.();
                    await withErrorHandling(`${context}:testPartnerAction`, async () => {
                        const response = await authenticatedFetch('/set-role', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ role: 'partner' }),
                        });
                        if (!response.ok) {
                            throw new Error(`Failed to set role: ${response.status}`);
                        }
                        const data = await response.json();
                        log(context, 'Successfully set x-role to partner, response:', data);

                        if (data.token) {
                            setAuthToken(data.token); // Replaced tokenManagerSetToken with setAuthToken
                            log(context, 'Updated token with new x-role: partner');
                        }
                    }, 'Failed to set partner role');
                },
            },
        ],
    },
];

/**
 * Fetches the user's role from the server.
 * @returns {Promise<string>} The user's role.
 */
export async function fetchUserRole() {
    log(context, 'Fetching user role');
    try {
        const response = await authenticatedFetch('/api/user/role');
        const data = await response.json();
        return data.role || ROLES.LOGIN;
    } catch (error) {
        log(context, `Error fetching user role: ${error.message}`);
        return ROLES.LOGIN; // Default to login role if fetching fails
    }
}

/**
 * Initializes the roles module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Roles instance with public definitions.
 */
export function initializeRolesModule(registry) {
    log(context, 'Initializing roles module for module registry');
    return {
        ROLES,
        ADMIN_MENU,
        fetchUserRole,
    };
}

// Initialize module with lifecycle logging
withScriptLogging(context, () => {
    log(context, 'Module initialized');
});

config/settings.js

// /static/js/config/settings.js
// Purpose: Defines centralized configuration for settings across the application.

import { log } from '../core/logger.js';
import { API_ENDPOINTS } from './endpoints.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Settings configuration registry for admin and provider settings.
 * @type {Object.<string, Object>}
 */
export const SETTINGS = {
  affiliates: {
    containerId: 'affiliate-icons',
    formId: 'affiliate-form',
    fieldsId: 'affiliate-settings-container',
    endpoint: API_ENDPOINTS.SETTINGS_AFFILIATE,
    type: 'affiliate',
    iconClass: 'fas fa-link',
  },
  apiKeys: {
    containerId: 'api-keys-icons',
    formId: 'api-keys-form',
    fieldsId: 'api-keys-fields',
    endpoint: API_ENDPOINTS.SETTINGS_API_KEY,
    type: 'api-keys',
    iconClass: 'fas fa-key',
  },
  siteSettings: {
    containerId: 'site-settings-icons',
    formId: 'site-settings-form',
    fieldsId: 'site-settings-fields',
    endpoint: API_ENDPOINTS.SETTINGS_KEY,
    type: 'site-settings',
    iconClass: 'fas fa-cog',
  },
  provider: {
    containerId: 'provider-icons',
    formId: 'providerForm',
    fieldsId: 'providerContentArea',
    endpoint: API_ENDPOINTS.CLIENT_API_SETTINGS,
    type: 'provider',
    iconClass: 'fas fa-cog',
  },
};

/**
 * Retrieves a settings configuration by type.
 * @param {string} context - The context or module name.
 * @param {string} type - The type of settings (e.g., 'affiliates', 'apiKeys', 'siteSettings', 'provider').
 * @returns {Object} The settings configuration.
 * @throws {Error} If the settings type is unknown.
 */
export function getSettingsConfig(context, type) {
  log(context, `Retrieving settings config for type: ${type}`);
  const config = SETTINGS[type];
  if (!config) {
    throw new Error(`Unknown settings type: ${type}`);
  }
  return config;
}

/**
 * Initializes the settings module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Settings instance with public methods.
 */
export function initializeSettingsModule(registry) {
  const context = 'settings.js';
  log(context, 'Initializing settings module for module registry');
  return {
    SETTINGS,
    getSettingsConfig: (ctx, ...args) => getSettingsConfig(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'settings.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

core/auth.js

// /static/js/core/auth.js
// Purpose: Manages authentication tokens, authenticated requests, and user authentication checks.

import { log } from './logger.js';
import { setCookie, getCookie, removeCookie } from './cookies.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { API_ENDPOINTS } from '../config/endpoints.js';

const context = 'auth.js';

/**
 * Sets the authentication token in a cookie.
 * @param {string} token - The authentication token.
 */
export function setAuthToken(token) {
    log(context, 'Setting auth token');
    setCookie('auth_token', token, 7);
}

/**
 * Retrieves the authentication token from a cookie.
 * @returns {string|null} The authentication token, or null if not found.
 */
export function getAuthToken() {
    log(context, 'Getting auth token');
    return getCookie('auth_token');
}

/**
 * Removes the authentication token from cookies.
 */
export function removeAuthToken() {
    log(context, 'Removing auth token');
    removeCookie('auth_token');
}

/**
 * Makes an authenticated fetch request using the stored token.
 * @param {string} endpoint - The API endpoint to fetch from.
 * @param {Object} [options={}] - Fetch options.
 * @returns {Promise<Response>} The fetch response.
 */
export async function authenticatedFetch(endpoint, options = {}) {
    log(context, `Making authenticated fetch to ${endpoint}`);
    const token = getAuthToken();
    if (!token) {
        throw new Error('No auth token found');
    }

    const headers = {
        ...options.headers,
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
    };

    const response = await fetch(`${API_ENDPOINTS.BASE}${endpoint}`, {
        ...options,
        headers,
    });

    if (!response.ok) {
        throw new Error(`Authenticated fetch failed: ${response.statusText}`);
    }

    return response;
}

/**
 * Verifies the reset token and extracts the payload.
 * @param {string} token - The reset token to verify.
 * @returns {Object} The decoded token payload.
 */
export function verifyResetToken(token) {
    log(context, 'Verifying reset token');
    try {
        const payload = jwt.decode(token); // Assuming a jwt library is available
        if (!payload) {
            throw new Error('Invalid token');
        }
        return payload;
    } catch (error) {
        throw new Error('Token verification failed');
    }
}

/**
 * Wraps a function to ensure it runs only for an authenticated user.
 * @param {string} context - The context or module name.
 * @param {Function} fn - The function to execute if authenticated.
 * @param {string} operation - The operation name for logging.
 * @returns {*} The result of the function execution.
 * @throws {Error} If the user is not authenticated.
 */
export function withAuthenticatedUser(context, fn, operation) {
    log(context, `Checking authentication for ${operation || 'operation'}`);
    const token = getAuthToken();
    if (!token) {
        log(context, 'User not authenticated');
        throw new Error('User not authenticated');
    }
    return fn();
}

/**
 * Initializes the auth module.
 */
export function initializeAuth() {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
}

core/cookies.js

// /static/js/core/cookies.js
// /static/js/core/cookies.js
import { log } from './logger.js';
import { withScriptLogging } from '../utils/logging-utils.js'; // Corrected import

const context = 'cookies.js';


export function setCookie(name, value, days) {
    log(context, `Setting cookie: ${name}`);
    let expires = '';
    if (days) {
        const date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        expires = `; expires=${date.toUTCString()}`;
    }
    document.cookie = `${name}=${value}${expires}; path=/; SameSite=Strict`;
}

export function getCookie(name) {
    log(context, `Getting cookie: ${name}`);
    const nameEQ = `${name}=`;
    const ca = document.cookie.split(';');
    for (let i = 0; i < ca.length; i++) {
        let c = ca[i];
        while (c.charAt(0) === ' ') {
            c = c.substring(1, c.length);
        }
        if (c.indexOf(nameEQ) === 0) {
            return c.substring(nameEQ.length, c.length);
        }
    }
    return null;
}

export function removeCookie(name) {
    log(context, `Removing cookie: ${name}`);
    document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; SameSite=Strict`;
}

export function initializeCookies() {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
}

core/logger.js

// /static/js/core/logger.js
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Logs a message to the console with the specified context.
 * @param {string} context - The context or module name.
 * @param {...any} args - Arguments to log.
 */
export function log(context, ...args) {
    console.log(`[${context}]`, ...args);
}

/**
 * Logs a warning to the console with the specified context.
 * @param {string} context - The context or module name.
 * @param {...any} args - Arguments to log.
 */
export function warn(context, ...args) {
    console.warn(`[${context}]`, ...args);
}

/**
 * Logs an error to the console with the specified context.
 * @param {string} context - The context or module name.
 * @param {...any} args - Arguments to log.
 */
export function error(context, ...args) {
    console.error(`[${context}]`, ...args);
}

/**
 * Initializes the logger module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Logger instance with public methods.
 */
export function initializeLoggerModule(registry) {
    const context = 'logger.js';
    log(context, 'Initializing logger module for module registry');
    return {
        log,
        warn,
        error,
    };
}

// Initialize module with lifecycle logging
const context = 'logger.js';
withScriptLogging(context, () => {
    log(context, 'Module initialized');
});

core/markdown.js

// /static/js/core/markdown.js
// Purpose: Provides markdown rendering functionality using marked.js.

import { log } from './logger.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Renders markdown content from a URL or string.
 * @param {string} context - The context or module name.
 * @param {string} contentOrUrl - The markdown content or URL to fetch it from.
 * @returns {Promise<string>} The rendered HTML content.
 */
export async function renderMarkdown(context, contentOrUrl) {
  log(context, `Rendering markdown from: ${contentOrUrl}`);
  return await withErrorHandling(`${context}:renderMarkdown`, async () => {
    let markdownContent;
    if (contentOrUrl.startsWith('http') || contentOrUrl.startsWith('/')) {
      const response = await fetch(contentOrUrl);
      if (!response.ok) {
        throw new Error(`Failed to fetch markdown: ${response.status}`);
      }
      markdownContent = await response.text();
    } else {
      markdownContent = contentOrUrl;
    }
    // Assume marked.js is globally available
    return window.marked ? window.marked(markdownContent) : markdownContent;
  }, ERROR_MESSAGES.MARKDOWN_RENDER_FAILED);
}

/**
 * Initializes the markdown module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Markdown instance with public methods.
 */
export function initializeMarkdownModule(registry) {
  const context = 'markdown.js';
  log(context, 'Initializing markdown module for module registry');
  return {
    renderMarkdown: (ctx, ...args) => renderMarkdown(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'markdown.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

core/mce.js

// /static/js/core/mce.js
// Purpose: Initializes TinyMCE editor for rich text editing.

import { log } from './logger.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Initializes TinyMCE editor on the specified selector.
 * @param {string} context - The context or module name.
 * @param {string} selector - The CSS selector for the textarea to initialize TinyMCE on.
 * @returns {Promise<void>}
 */
export async function initializeTinyMCE(context, selector) {
  log(context, `Initializing TinyMCE on selector: ${selector}`);
  await withErrorHandling(`${context}:initializeTinyMCE`, async () => {
    if (!window.tinymce) {
      throw new Error('TinyMCE library not loaded');
    }
    await window.tinymce.init({
      selector,
      plugins: 'lists link image table code',
      toolbar: 'undo redo | bold italic | alignleft aligncenter alignright | bullist numlist outdent indent | link image',
      menubar: false,
      statusbar: false,
      height: 300,
    });
    log(context, 'TinyMCE initialized successfully');
  }, ERROR_MESSAGES.MODULE_INIT_FAILED);
}

/**
 * Initializes the TinyMCE module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} TinyMCE instance with public methods.
 */
export function initializeMceModule(registry) {
  const context = 'mce.js';
  log(context, 'Initializing TinyMCE module for module registry');
  return {
    initializeTinyMCE: (ctx, ...args) => initializeTinyMCE(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'mce.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

core/notifications.js

// /static/js/core/notifications.js
// Purpose: Provides notification utilities using Toastr with fallback to alerts.

import { log, error as loggerError, warn as loggerWarn } from './logger.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { createModuleInitializer } from '../utils/initialization.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/messages.js'; // Updated import

const context = 'notifications.js';

/**
 * Sets up Toastr with custom logging and configuration.
 * @param {string} context - The context or module name.
 * @returns {boolean} Whether Toastr was successfully set up.
 */
export function setupToastr(context) {
    log(context, 'Setting up Toastr');
    if (typeof toastr === 'undefined') {
        loggerError(context, 'Toastr library not loaded');
        return false;
    }

    const originalSuccess = toastr.success;
    const originalError = toastr.error;
    const originalInfo = toastr.info;
    const originalWarning = toastr.warning;

    toastr.success = (message, title, options) => {
        log(context, `Toastr Success: ${title ? title + ' - ' : ''}${message}`);
        return originalSuccess.call(toastr, message, title, options);
    };
    toastr.error = (message, title, options) => {
        log(context, `Toastr Error: ${title ? title + ' - ' : ''}${message}`);
        return originalError.call(toastr, message, title, options);
    };
    toastr.info = (message, title, options) => {
        log(context, `Toastr Info: ${title ? title + ' - ' : ''}${message}`);
        return originalInfo.call(toastr, message, title, options);
    };
    toastr.warning = (message, title, options) => {
        log(context, `Toastr Warning: ${title ? title + ' - ' : ''}${message}`);
        return originalWarning.call(toastr, message, title, options);
    };

    toastr.options = {
        closeButton: true,
        progressBar: true,
        positionClass: 'toast-top-right',
        timeOut: 5000,
        showMethod: 'slideDown',
        hideMethod: 'slideUp'
    };

    log(context, 'Toastr configured:', toastr.options);
    return true;
}

/**
 * Displays a success notification.
 * @param {string} context - The context or module name.
 * @param {string} message - The message to display.
 * @param {string} [title] - The title of the notification.
 * @param {Object} [options] - Toastr options.
 */
export function success(context, message, title, options) {
    if (typeof toastr !== 'undefined' && setupToastr(context)) {
        toastr.success(message, title, options);
    } else {
        loggerWarn(context, 'Toastr not available, fallback to alert:', message);
        alert(`Success: ${title ? title + ' - ' : ''}${message}`);
    }
}

/**
 * Displays an error notification.
 * @param {string} context - The context or module name.
 * @param {string} message - The message to display.
 * @param {string} [title] - The title of the notification.
 * @param {Object} [options] - Toastr options.
 */
export function error(context, message, title, options) {
    if (typeof toastr !== 'undefined' && setupToastr(context)) {
        toastr.error(message, title, options);
    } else {
        loggerWarn(context, 'Toastr not available, fallback to alert:', message);
        alert(`Error: ${title ? title + ' - ' : ''}${message}`);
    }
}

/**
 * Displays an info notification.
 * @param {string} context - The context or module name.
 * @param {string} message - The message to display.
 * @param {string} [title] - The title of the notification.
 * @param {Object} [options] - Toastr options.
 */
export function info(context, message, title, options) {
    if (typeof toastr !== 'undefined' && setupToastr(context)) {
        toastr.info(message, title, options);
    } else {
        loggerWarn(context, 'Toastr not available, fallback to alert:', message);
        alert(`Info: ${title ? title + ' - ' : ''}${message}`);
    }
}

/**
 * Displays a warning notification.
 * @param {string} context - The context or module name.
 * @param {string} message - The message to display.
 * @param {string} [title] - The title of the notification.
 * @param {Object} [options] - Toastr options.
 */
export function warning(context, message, title, options) {
    if (typeof toastr !== 'undefined' && setupToastr(context)) {
        toastr.warning(message, title, options);
    } else {
        loggerWarn(context, 'Toastr not available, fallback to alert:', message);
        alert(`Warning: ${title ? title + ' - ' : ''}${message}`);
    }
}

/**
 * Notifies the result of an operation with success or error.
 * @param {string} context - The context or module name.
 * @param {Object} params - Operation result parameters.
 * @param {boolean} params.success - Whether the operation was successful.
 * @param {string} [params.message] - The message to display.
 * @param {string} [params.defaultSuccess] - Default success message.
 * @param {string} [params.defaultError] - Default error message.
 */
export function notifyOperationResult(context, { success: isSuccess, message, defaultSuccess = SUCCESS_MESSAGES.DEFAULT, defaultError = ERROR_MESSAGES.DEFAULT }) {
    log(context, `Notifying operation result: ${isSuccess ? 'success' : 'error'}, message: ${message}`);
    const notificationMessage = isSuccess ? (message || defaultSuccess) : (message || defaultError);
    if (isSuccess) {
        success(context, notificationMessage);
    } else {
        error(context, notificationMessage);
    }
}

/**
 * Initializes the notifications module for use with the module registry.
 * @param {Map} registry - The module registry instance.
 * @returns {Object} Module instance with public methods.
 */
export function initializeNotificationsModule(registry) {
    log(context, 'Initializing notifications module for module registry');
    setupToastr(context);
    return {
        success: (ctx, ...args) => success(ctx, ...args),
        error: (ctx, ...args) => error(ctx, ...args),
        info: (ctx, ...args) => info(ctx, ...args),
        warning: (ctx, ...args) => warning(ctx, ...args),
        notifyOperationResult: (ctx, ...args) => notifyOperationResult(ctx, ...args),
    };
}

// Initialize module with lifecycle logging
withScriptLogging(context, () => {
    log(context, 'Module initialized');
    setupToastr(context);
});

core/user.js

// /static/js/core/user.js
// Purpose: Manages user-related operations, such as fetching user data and validating user IDs.

import { log } from './logger.js';
import { authenticatedFetch } from './auth.js';
import { withErrorHandling } from '../utils/error.js';
import {  ERROR_MESSAGES } from '../config/constants.js';
import { API_ENDPOINTS } from '../config/endpoints.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Fetches user data for the specified user ID.
 * @param {string} context - The context or module name.
 * @param {string} userId - The user ID.
 * @returns {Promise<Object>} The user data.
 */
export async function fetchUser(context, userId) {
  log(context, `Fetching user data for userId: ${userId}`);
  return await withErrorHandling(`${context}:fetchUser`, async () => {
    const response = await authenticatedFetch(context, API_ENDPOINTS.USERS_USERID(userId));
    const data = await response.json();
    if (data.status === 'error') {
      throw new Error(data.message || ERROR_MESSAGES.FETCH_FAILED('user'));
    }
    return data;
  }, ERROR_MESSAGES.FETCH_FAILED('user'));
}

/**
 * Validates the user ID from localStorage or DOM.
 * @param {string} context - The context or module name.
 * @returns {Promise<string>} The validated user ID.
 * @throws {Error} If no valid user ID is found.
 */
export async function validateUserId(context) {
  log(context, 'Validating user ID');
  return await withErrorHandling(`${context}:validateUserId`, async () => {
    let userId = localStorage.getItem('userId');
    if (!userId) {
      const userIdInput = document.getElementById('userId');
      userId = userIdInput?.value;
      if (!userId) {
        throw new Error(ERROR_MESSAGES.USER_ID_NOT_FOUND);
      }
      localStorage.setItem('userId', userId);
    }
    log(context, `Validated user ID: ${userId}`);
    return userId;
  }, ERROR_MESSAGES.USER_ID_NOT_FOUND);
}

/**
 * Initializes the user module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} User instance with public methods.
 */
export function initializeUserModule(registry) {
  const context = 'user.js';
  log(context, 'Initializing user module for module registry');
  return {
    fetchUser: (ctx, ...args) => fetchUser(ctx, ...args),
    validateUserId: (ctx, ...args) => validateUserId(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'user.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

login/forgot-password.js

// /static/js/login/forgot-password.js
import { log } from '../core/logger.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { toggleViewState, withElement } from '../utils/dom-manipulation.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Initializes the forgot password form in the specified section.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeForgotPassword(context) {
  log(context, 'Initializing forgot password form');
  await withElement(context, 'forgotPasswordContainer', async (section) => {
    // Ensure all other sections are hidden
    document.querySelectorAll('.section').forEach(s => {
      if (s.id !== 'forgotPasswordContainer') s.style.display = 'none';
    });
    // Show the target section
    section.style.display = 'block';
    toggleViewState(context, { forgotPasswordContainer: true });

    // Set up forgot password form submission
    submitConfiguredForm(context, 'forgotPasswordForm', '/reset-password', 'forgotPassword', {
      onSuccess: async (data) => {
        log(context, 'Forgot password request successful, showing OTP section');
        if (data.otp_token) {
          localStorage.setItem('resetToken', data.otp_token);  // Correctly use otp_token
          log(context, 'Stored resetToken:', data.otp_token);
        } else {
          log(context, 'No otp_token in response');
          alert('Failed to receive OTP token from server.');
          return;
        }
        await withElement(context, 'verifyOtpSection', async otpSection => {
          toggleViewState(context, { verifyOtpSection: true });
          // Populate the otpToken field with the stored token
          const otpTokenInput = document.getElementById('otpToken');
          if (otpTokenInput) {
            const token = localStorage.getItem('resetToken');
            if (token) {
              otpTokenInput.value = token;
              log(context, `Set otpToken to: ${token}`);
            } else {
              log(context, 'No reset token found in localStorage');
            }
          } else {
            log(context, 'otpToken input not found');
          }
        });
      },
      onError: (error) => {
        log(context, 'Forgot password error:', error.message);
        alert(ERROR_MESSAGES.FORM_SUBMISSION_FAILED || 'Failed to send OTP. Please try again.');
      },
    });

    // Set up verify OTP form submission
    submitConfiguredForm(context, 'verifyOtpForm', '/verify-reset-code', 'verifyOtp', {
      onSuccess: (data) => {
        log(context, 'OTP verified, redirecting to login');
        localStorage.removeItem('resetToken');
        window.location.href = '/';
      },
      onError: (error) => {
        log(context, 'OTP verification error:', error.message);
        alert(ERROR_MESSAGES.FORM_SUBMISSION_FAILED || 'Failed to verify OTP. Please try again.');
      },
    });

    // Set up password toggle for verify OTP form
    const verifyOtpSection = document.getElementById('verifyOtpSection');
    if (verifyOtpSection) {
      const toggleButtons = verifyOtpSection.querySelectorAll('.toggle-password, .toggle-password-icon');
      toggleButtons.forEach(toggleButton => {
        toggleButton.addEventListener('click', () => {
          const passwordInput = toggleButton.closest('.password-wrapper').querySelector('input[type="password"], input[type="text"]');
          const icon = toggleButton.querySelector('i') || toggleButton;
          if (passwordInput.type === 'password') {
            passwordInput.type = 'text';
            icon.classList.replace('fa-eye', 'fa-eye-slash');
          } else {
            passwordInput.type = 'password';
            icon.classList.replace('fa-eye-slash', 'fa-eye');
          }
        });
      });
    }
  });
}

/**
 * Initializes the forgot password module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Forgot password instance with public methods.
 */
export function initializeForgotPasswordModule(registry) {
  const context = 'forgot-password.js';
  log(context, 'Initializing forgot password module for module registry');
  return {
    initializeForgotPassword: ctx => initializeForgotPassword(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'forgot-password.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

login/login.js

// /static/js/login/login.js
import { log } from '../core/logger.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { setCookie } from '../core/cookies.js';
import { setAuthToken } from '../core/auth.js';
import { withElement, toggleViewState } from '../utils/dom-manipulation.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Initializes the login form in the welcome section.
 * @param {string} context - The context or module name.
 * @param {string} targetSection - The ID of the section to initialize (e.g., 'welcomeSection').
 * @returns {Promise<void>}
 */
export async function initializeLogin(context, targetSection) {
  log(context, `Initializing login form in section: ${targetSection}`);
  await withElement(context, targetSection, async (section) => {
    // Ensure all other sections are hidden
    document.querySelectorAll('.section').forEach(s => {
      if (s.id !== targetSection) s.style.display = 'none';
    });
    // Show the target section
    section.style.display = 'block';
    toggleViewState(context, { [targetSection]: true });

    // Set up form submission
    submitConfiguredForm(context, 'loginForm', '/', 'login', {
      onSuccess: data => {
        log(context, 'Login successful, setting token and cookie');
        setAuthToken(data.token);
        if (data.user_id) localStorage.setItem('userId', data.user_id);
        setCookie('authToken', data.token, 7);
        window.location.reload();
      },
    });

    // Set up password toggle
    const togglePassword = section.querySelector('.toggle-password, .toggle-password-icon');
    if (togglePassword) {
      log(context, 'Toggle-password element found, binding event listener');
      togglePassword.addEventListener('click', () => {
        log(context, 'Toggle-password clicked');
        const passwordInput = section.querySelector('#loginPassword');
        const icon = togglePassword.querySelector('i') || togglePassword;
        if (passwordInput) {
          if (passwordInput.type === 'password') {
            passwordInput.type = 'text';
            icon.classList.replace('fa-eye', 'fa-eye-slash');
            log(context, 'Password visibility toggled to text');
          } else {
            passwordInput.type = 'password';
            icon.classList.replace('fa-eye-slash', 'fa-eye');
            log(context, 'Password visibility toggled to password');
          }
        } else {
          log(context, 'Password input #loginPassword not found');
        }
      });
    } else {
      log(context, 'Toggle-password element not found in section');
    }

    // Set up existing Forgot Password button
    const forgotPasswordButton = document.getElementById('forgotPasswordButton');
    if (forgotPasswordButton) {
      log(context, 'Forgot Password button found, binding event listener');
      forgotPasswordButton.addEventListener('click', (e) => {
        e.preventDefault();
        toggleViewState(context, { forgotPasswordContainer: true });
      });
    } else {
      log(context, 'Forgot Password button not found');
    }
  });
}

/**
 * Initializes the login module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Login instance with public methods.
 */
export function initializeLoginModule(registry) {
  const context = 'login.js';
  log(context, 'Initializing login module for module registry');
  return {
    initializeLogin: (ctx, ...args) => initializeLogin(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'login.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

login/set-password.js

// /static/js/login/set-password.js
import { log } from '../core/logger.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { withElement } from '../utils/dom-manipulation.js';
import { withScriptLogging } from '../utils/logging-utils.js';

const context = 'set-password.js';

/**
 * Initializes the set password form in the specified section.
 * @param {string} context - The context or module name.
 * @param {string} sectionId - The ID of the section containing the form.
 * @returns {Promise<void>}
 */
export async function initializeSetPassword(context, sectionId) {
  log(context, `Initializing set password form in section: ${sectionId}`);
  await withElement(context, sectionId, async (section) => {
    // Hide other sections
    document.querySelectorAll('.section').forEach(s => {
      if (s.id !== sectionId) s.style.display = 'none';
    });
    // Show the target section
    section.style.display = 'block';

    // Set up form submission to the correct endpoint
    submitConfiguredForm(context, 'setPasswordForm', '/complete-signup', 'setPassword', {
      onSuccess: (data) => {
        log(context, 'Password set successfully');
        // Redirect or update UI as needed
        window.location.href = '/';
      },
      onError: (err) => {
        log(context, 'Error setting password:', err.message);
      },
    });
  });
}

/**
 * Initializes the set password module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Module instance with public methods.
 */
export function initializeSetPasswordModule(registry) {
  log(context, 'Initializing set password module');
  return {
    initializeSetPassword: (ctx, ...args) => initializeSetPassword(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

login/signup.js

// /static/js/login/signup.js
import { log } from '../core/logger.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { setupFormFieldEvents } from '../utils/event-listeners.js';
import { toggleViewState, withElement } from '../utils/dom-manipulation.js';
import { withScriptLogging } from '../utils/logging-utils.js';

const context = 'signup';

/**
 * Initializes the signup page.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeSignup(context) {
    log(context, 'Initializing signup page');

    await withElement(context, 'signupContainer', async (section) => {
        // Hide other sections and show signupContainer
        document.querySelectorAll('.section').forEach(s => {
            if (s.id !== 'signupContainer') s.style.display = 'none';
        });
        toggleViewState(context, { signupContainer: true });

        // Configure the signup form submission
        await withElement(context, 'signupForm', async (form) => {
            // Ensure "Community" is the default signup type
            document.querySelectorAll('.option').forEach(option => option.classList.remove('selected'));
            const communityOption = form.querySelector('input[value="community"]');
            if (communityOption) {
                communityOption.checked = true;
                communityOption.closest('.option').classList.add('selected');
            }

            log(context, 'Configuring signup form submission');
            submitConfiguredForm(context, 'signupForm', '/signup', 'signup', {
                onSuccess: async (response) => {
                    log(context, 'Signup successful, response:', response);
                    if (response.signup_type === 'partner') {
                        log(context, 'Showing verifyOtpSection for partner');
                        toggleViewState(context, {
                            signupContainer: false,
                            verifyOtpSection: true,
                            forgotPasswordContainer: false,
                            info: false
                        });
                        const otpTokenInput = document.getElementById('otpToken');
                        if (otpTokenInput) otpTokenInput.value = response.otp_token || '';
                        const verifyForm = document.getElementById('verifyOtpForm');
                        if (verifyForm) verifyForm.action = '/verify-signup-otp';
                    } else if (response.account_link) {
                        log(context, 'Redirecting to Stripe:', response.account_link);
                        window.location.href = response.account_link;
                    } else {
                        log(context, 'Error: account_link missing in response');
                        alert('Signup successful, but unable to redirect to Stripe. Please try again later.');
                    }
                },
                onError: (err) => {
                    log(context, 'Signup error:', err.message);
                }
            });

            // Set up radio button events for signup type selection
            setupFormFieldEvents(context, {
                selector: 'input[name="signup_type"]',
                eventType: 'change',
                handler: e => {
                    document.querySelectorAll('.option').forEach(option => {
                        option.classList.toggle('selected', option.contains(e.target));
                    });
                    log(context, 'Selected signup type:', e.target.value);
                },
            });
        }, 10, 100, false);
    }, 10, 100, false);
}

/**
 * Initializes the signup module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Signup instance with public methods.
 */
export function initializeSignupModule(registry) {
    log(context, 'Initializing signup module for module registry');
    return {
        initializeSignup: ctx => initializeSignup(ctx),
    };
}

// Initialize module with lifecycle logging
withScriptLogging(context, () => {
    log(context, 'Module initialized');
});

login-page.js

// /static/js/login-page.js
import { log } from './core/logger.js';
import { withErrorHandling } from './utils/error.js';
import { toggleViewState, withElement } from './utils/dom-manipulation.js';
import { getMenu } from './config/menus.js';
import { initializeRoleNavigation, defineSectionHandlers } from './modules/navigation.js';
import { withScriptLogging, hideOverlay } from './utils/logging-utils.js';
import { initializeLogin } from './login/login.js';
import { initializeSignup } from './login/signup.js';
import { initializeForgotPassword } from './login/forgot-password.js';
import { initializeSetPassword } from './login/set-password.js';

const context = 'login-page.js';

/**
 * Parses the page type from a meta tag, DOM element, or query parameter.
 * @param {string} param - The ID of the element or query parameter containing the page type.
 * @returns {string|Promise<string>} The parsed page type or a Promise resolving to it.
 */
export function parsePageType(param) {
    return withErrorHandling(context, () => {
        log(context, `Parsing page type from param: ${param}`);
        // Prioritize meta tag
        const metaPageType = document.querySelector('meta[name="page-type"]')?.content;
        if (metaPageType && ['admin', 'community', 'merchant', 'partner', 'login'].includes(metaPageType)) {
            log(context, `Page type resolved from meta tag: ${metaPageType}`);
            return metaPageType;
        }
        // Fallback to DOM element
        const pageTypeElement = document.getElementById(param);
        if (pageTypeElement) {
            const pageType = pageTypeElement.value || 'info';
            log(context, `Page type resolved from DOM element: ${pageType}`);
            return pageType;
        }
        // Fallback to query parameter
        const urlParams = new URLSearchParams(window.location.search);
        const pageType = urlParams.get(param) || 'info';
        log(context, `Page type resolved from query parameter: ${pageType}`);
        return pageType;
    }, 'parsePageType');
}

/**
 * Initializes the login page, setting up navigation and form handling.
 * @param {Object} options - Options object containing the module registry.
 * @param {Map} options.registry - The module registry instance.
 */
export async function initializeLoginPage({ registry }) {
    log(context, 'Initializing login page');

    // Resolve the page type
    const pageTypeElement = parsePageType('page');
    const pageType = typeof pageTypeElement === 'string' ? pageTypeElement : await pageTypeElement;
    log(context, `Page type resolved: ${pageType}`);

    // Exit early if not a login page
    if (pageType !== 'login') {
        log(context, `Skipping login page initialization for page type: ${pageType}`);
        return;
    }

    // Set up navigation for the login role
    const role = 'login';
    const defaultSection = pageType === 'login' ? 'info' : pageType;
    log(context, `Initializing navigation for role: ${role}, default section: ${defaultSection}`);

    // Define section handlers for the login role
    const sectionHandlers = defineSectionHandlers(context, role, [
        {
            id: 'info',
            handler: async () => {
                log(context, 'Loading info section with form');
                await withElement(context, 'info', async (infoSection) => {
                    log(context, `Info section found, ensuring visibility`);
                    infoSection.style.display = 'block';
                    toggleViewState(context, {
                        info: true,
                        forgotPasswordContainer: false,
                        verifyOtpSection: false,
                        signupContainer: false,
                    });

                    // Dynamically detect which form is present
                    const loginForm = document.getElementById('loginForm');
                    const setPasswordForm = document.getElementById('setPasswordForm');

                    if (loginForm) {
                        log(context, 'Found loginForm, initializing login');
                        await initializeLogin(context, 'info');
                    } else if (setPasswordForm) {
                        log(context, 'Found setPasswordForm, initializing set password');
                        await initializeSetPassword(context, 'info');
                    } else {
                        log(context, 'No form found in info section');
                    }
                }, 10, 100, false);
            },
        },
        {
            id: 'signup',
            handler: async () => {
                log(context, 'Loading signup section');
                await withElement(context, 'signupContainer', async (signupSection) => {
                    signupSection.style.display = 'block';
                    toggleViewState(context, {
                        info: false,
                        forgotPasswordContainer: false,
                        verifyOtpSection: false,
                        signupContainer: true,
                    });
                    await initializeSignup(context);
                }, 10, 100, false);
            },
        },
        {
            id: 'forgot-password',
            handler: async () => {
                log(context, 'Loading forgot-password section');
                await withElement(context, 'forgotPasswordContainer', async (forgotPasswordSection) => {
                    forgotPasswordSection.style.display = 'block';
                    toggleViewState(context, {
                        info: false,
                        forgotPasswordContainer: true,
                        verifyOtpSection: false,
                        signupContainer: false,
                    });
                    await initializeForgotPassword(context);
                }, 10, 100, false);
            },
        },
    ]);
    log(context, 'Section handlers defined:', Object.keys(sectionHandlers));

    // Retrieve the menu configuration
    const menu = getMenu(role);
    log(context, `Menu retrieved for role ${role}:`, menu);

    // Ensure the menu container exists and render the navigation buttons
    await withElement(context, 'menu', async (menuElement) => {
        if (!menuElement) {
            log(context, 'Menu element not found, creating it');
            menuElement = document.createElement('div');
            menuElement.id = 'menu';
            menuElement.className = 'menu';
            const contentElement = document.querySelector('.content');
            if (contentElement) {
                contentElement.prepend(menuElement);
            } else {
                log(context, 'Error: .content element not found', 'error');
                return;
            }
        }

        if (!menu || menu.length === 0) {
            log(context, `No menu found for role: ${role}, rendering default buttons`);
            menuElement.innerHTML = `
                <button data-section="forgot-password">
                    <i class="fas fa-lock"></i> Forgot Password
                </button>
                <button data-section="signup">
                    <i class="fas fa-user-plus"></i> Sign Up
                </button>
            `;
            menuElement.querySelectorAll('button').forEach(button => {
                const sectionId = button.getAttribute('data-section');
                button.addEventListener('click', () => {
                    log(context, `Navigating to section: ${sectionId}`);
                    const handler = sectionHandlers[sectionId];
                    if (handler) {
                        handler();
                    } else {
                        log(context, `No handler found for section: ${sectionId}`, 'warn');
                    }
                });
            });
        } else {
            log(context, `Setting up navigation with menu:`, menu);
            const navigationOptions = { sectionHandlers, defaultSection };
            await withErrorHandling(context, () => initializeRoleNavigation(menuElement, menu, navigationOptions), 'initializeRoleNavigation')();
        }

        // Show layout and hide overlay
        const layoutWrapper = document.querySelector('.layout-wrapper');
        if (layoutWrapper) {
            layoutWrapper.style.display = 'block';
            log(context, 'Layout wrapper displayed');
        } else {
            log(context, 'Warning: Layout wrapper not found', 'warn');
        }
        await hideOverlay();
        log(context, 'Loading overlay hidden');
    }, 10, 100, false);
}

/**
 * Initializes the login page module for use with the module registry.
 * @param {Map} registry - The module registry instance.
 * @returns {Object} Module instance with public methods.
 */
export function initializeLoginPageModule(registry) {
    log(context, 'Initializing login page for module registry');
    return {
        initializeLoginPage: (options) => initializeLoginPage(options),
    };
}

// Initialize module with lifecycle logging
withScriptLogging(context, async () => {
    log(context, 'Starting module initialization');
    await initializeLoginPage({ registry: new Map() });
    log(context, 'Module initialized');
});

main.js

// /static/js/main.js
// Purpose: Centralizes module loading and registration for the application.

import { log } from './core/logger.js';
import { withErrorHandling } from './utils/error.js';
import { PAGE_MODULES } from './config/pages.js';
import { ERROR_MESSAGES } from './config/messages.js';
import { withScriptLogging } from './utils/initialization.js';
import { createModuleInitializer } from './utils/initialization.js';

/**
 * Module registry for managing loaded modules.
 * @type {Map<string, Object>}
 */
const moduleRegistry = new Map();

/**
 * Registers a module in the registry.
 * @param {string} name - The module name.
 * @param {Object} module - The module instance.
 */
function registerModule(name, module) {
    log('main.js', `Registering module: ${name}`);
    moduleRegistry.set(name, module);
}

/**
 * Initializes core modules that are required by all pages.
 * @returns {Promise<void>}
 */
export async function initializeCoreModules() {
    const context = 'main.js';
    log(context, 'Initializing core modules');
    await withErrorHandling(`${context}:initializeCoreModules`, async () => {
        // Initialize logger
        const loggerModule = await import('./core/logger.js');
        await loggerModule.initializeLogger();
        registerModule('logger', loggerModule.initializeLoggerModule(moduleRegistry));

        // Initialize cookies
        const cookiesModule = await import('./core/cookies.js');
        await cookiesModule.initializeCookies();
        registerModule('cookies', {
            setCookie: cookiesModule.setCookie,
            getCookie: cookiesModule.getCookie,
            removeCookie: cookiesModule.removeCookie,
        });

        // Initialize endpoints
        const endpointsModule = await import('./config/endpoints.js');
        await endpointsModule.initializeEndpoints();
        registerModule('endpoints', endpointsModule.initializeEndpointsModule(moduleRegistry));

        // Initialize auth
        const authModule = await import('./core/auth.js');
        await authModule.initializeAuth();
        registerModule('auth', {
            setAuthToken: authModule.setAuthToken,
            getAuthToken: authModule.getAuthToken,
            removeAuthToken: authModule.removeAuthToken,
            authenticatedFetch: authModule.authenticatedFetch,
            withAuthenticatedUser: authModule.withAuthenticatedUser,
        });
    }, ERROR_MESSAGES.MODULE_INIT_FAILED);
}

/**
 * Initializes all modules for the specified page type.
 * @param {string} pageType - The type of page to initialize (e.g., 'admin', 'login').
 * @returns {Promise<void>}
 */
async function initializeModules(pageType) {
    const context = 'main.js';
    log(context, `Initializing modules for page type: ${pageType}`);
    await withErrorHandling(`${context}:initializeModules`, async () => {
        const modules = PAGE_MODULES[pageType] || [];
        for (const modulePath of modules) {
            try {
                const module = await import(modulePath);
                const moduleName = modulePath.split('/').pop().replace('.js', '');
                const initializer = Object.values(module).find(val => typeof val === 'function' && val.name.startsWith('initialize'));
                if (initializer) {
                    const moduleInstance = await initializer(moduleRegistry);
                    registerModule(moduleName, moduleInstance);
                } else {
                    log(context, `No initializer found for module: ${moduleName}`);
                }
            } catch (err) {
                log(context, `Failed to load module: ${modulePath}`, err);
            }
        }
    }, ERROR_MESSAGES.MODULE_INIT_FAILED);
}

/**
 * Initializes the application by loading modules based on the page type.
 * @returns {Promise<void>}
 */
async function initializeApplication() {
    const context = 'main.js';
    log(context, 'Initializing application');
    await initializeCoreModules();
    const pageType = new URLSearchParams(window.location.search).get('page') || 'login';
    await initializeModules(pageType);
}

/**
 * Initializes the main module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Main instance with public methods.
 */
export function initializeMainModule(registry) {
    return createModuleInitializer('main.js', {
        initializeApplication,
        registerModule,
    });
}

// Initialize module with lifecycle logging
withScriptLogging('main.js', () => {
    initializeApplication();
});

merchant/api-keys-events.js

// /static/js/merchant/api-keys-events.js
// Purpose: Manages event listeners for API key form interactions on the merchant page.

import { log } from '../core/logger.js';
import { setupEventListeners } from '../utils/event-listeners.js';
import { fetchData } from '../utils/data-fetch.js';
import { success } from '../core/notifications.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Sets up event listeners for API key form submissions.
 * @param {string} context - The context or module name.
 * @param {string} formId - The ID of the form.
 * @param {string} endpoint - The API endpoint for submission.
 * @returns {void}
 */
export function setupApiKeyEvents(context, formId, endpoint) {
  log(context, `Setting up API key event listeners for form: ${formId}`);
  setupEventListeners(context, [
    {
      eventType: 'submit',
      selector: `#${formId}`,
      handler: async e => {
        e.preventDefault();
        await withErrorHandling(`${context}:submitApiKeyForm`, async () => {
          const keyType = e.target.dataset.keyType;
          const fields = {};
          Array.from(e.target.querySelectorAll('input')).forEach(input => {
            fields[input.name] = input.value;
          });
          await fetchData(context, `${endpoint}/${keyType}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(fields),
          });
          success(context, SUCCESS_MESSAGES.SUBMITTED(`API key for ${keyType}`));
          await import('./api-keys.js').then(module => module.loadApiKeys(context));
        }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
      },
    },
  ]);
}

/**
 * Initializes the api-keys-events module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} ApiKeysEvents instance with public methods.
 */
export function initializeApiKeysEventsModule(registry) {
  const context = 'api-keys-events.js';
  log(context, 'Initializing api-keys-events module for module registry');
  return {
    setupApiKeyEvents: (ctx, ...args) => setupApiKeyEvents(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'api-keys-events.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

merchant/api-keys.js

// /static/js/merchant/api-keys.js
// Purpose: Orchestrates the API keys settings page, coordinating data fetching, UI rendering, and event setup.

import { log } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { renderSettingsFields } from '../utils/settings-ui.js';
import { setupApiKeyEvents } from './api-keys-events.js';
import { withElement, toggleViewState } from '../utils/dom-manipulation.js';
import { notifyError } from '../core/notifications.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Loads and renders API keys data.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function loadApiKeys(context) {
  log(context, 'Loading API keys');
  await withErrorHandling(`${context}:loadApiKeys`, async () => {
    await withElement(context, 'api-keys-icons', async iconsContainer => {
      await withElement(context, 'api-keys-fields', async fieldsContainer => {
        await withElement(context, 'api-keys-form', async form => {
          const data = await fetchData(API_ENDPOINTS.API_KEY, { method: 'GET' });
          if (!data.settings || data.settings.length === 0) {
            iconsContainer.innerHTML = '<p>No API keys available.</p>';
            notifyError(context, ERROR_MESSAGES.NO_DATA('API keys'));
            return;
          }
          await displayApiKeyFields(context, data.settings[0], fieldsContainer, form);
          setupApiKeyEvents(context, 'api-keys-form', API_ENDPOINTS.API_KEY);
        });
      });
    });
  }, ERROR_MESSAGES.FETCH_FAILED('API keys'));
}

/**
 * Renders API key fields for a specific setting.
 * @param {string} context - The context or module name.
 * @param {Object} setting - The API key setting data.
 * @param {HTMLElement} fieldsContainer - The container for the fields.
 * @param {HTMLElement} form - The form element.
 * @returns {Promise<void>}
 */
async function displayApiKeyFields(context, setting, fieldsContainer, form) {
  log(context, 'Rendering API key fields');
  await renderSettingsFields(context, [setting], {
    containerId: 'api-keys-icons',
    formId: 'api-keys-form',
    fieldsId: 'api-keys-fields',
    type: 'api',
    iconClass: 'fas fa-key',
    onIconClick: (setting, fieldsContainer, form) => {
      toggleViewState(context, { 'api-keys-fields': true });
    },
    onReadmeClick: async setting => {
      await renderMarkdownContent(context, setting.readmePath, `mdContent-${setting.keyType}`);
      toggleViewState(context, { [`mdContent-${setting.keyType}`]: true });
    },
  });
}

/**
 * Initializes the API keys module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} API keys instance with public methods.
 */
export function initializeApiKeysModule(registry) {
  const context = 'api-keys.js';
  log(context, 'Initializing API keys module for module registry');
  return {
    loadApiKeys: ctx => loadApiKeys(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'api-keys.js';
withScriptLogging(context, () => {
  loadApiKeys(context);
});

merchant/documentation.js

// /static/js/merchant/documentation.js
// Purpose: Handles rendering of documentation content and submenu for the merchant page.

import { log } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { renderMarkdownContent } from '../utils/form-rendering.js';
import { withElement, toggleViewState } from '../utils/dom-manipulation.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { API_ENDPOINTS } from '../config/api-endpoints.js';

/**
 * Renders documentation content and populates the submenu with API key settings.
 * @param {string} context - The context or module name.
 * @param {string} defaultPath - The default markdown file path to render.
 * @param {string} containerId - The ID of the container to render markdown content.
 * @returns {Promise<void>}
 */
export async function renderDocumentation(context, defaultPath, containerId) {
  log(context, `Rendering documentation for path: ${defaultPath}`);
  await withErrorHandling(`${context}:renderDocumentation`, async () => {
    await withElement(context, containerId, async (container) => {
      // Fetch API key settings for submenu
      const settings = await fetchData(context, API_ENDPOINTS.API_KEY);
      const submenu = document.getElementById('documentation-submenu');
      if (submenu && settings) {
        submenu.innerHTML = settings.map(setting => `
          <button class="md-link" data-md-path="${setting.readme_path}">
            ${setting.name}
          </button>
        `).join('');
      } else {
        log(context, 'No submenu or settings found, rendering default content only');
      }

      // Render default markdown content
      await renderMarkdownContent(context, defaultPath, container);

      // Show the documentation section
      toggleViewState(context, { [containerId]: true });
    });
  }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Initializes the documentation module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Documentation instance with public methods.
 */
export function initializeDocumentationModule(registry) {
  const context = 'documentation.js';
  log(context, 'Initializing documentation module for module registry');
  return {
    renderDocumentation: (ctx, ...args) => renderDocumentation(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'documentation.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

merchant/navigation.js

// /static/js/merchant/navigation.js
import { log } from '../core/logger.js';
import { defineSectionHandlers } from '../modules/navigation.js';
import { loadApiKeys } from './api-keys.js';
import { loadProducts } from './products.js';
import { loadUserSettings } from './user-settings.js';
import { renderDocumentation } from './documentation.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { toggleViewState } from '../utils/dom-manipulation.js';

/**
 * Defines section handlers for the merchant page.
 * @param {string} context - The context or module name.
 * @returns {void}
 */
export function defineMerchantSectionHandlers(context) {
  log(context, 'Defining merchant section handlers');
  defineSectionHandlers(context, 'merchant', [
    {
      id: 'info',
      handler: async () => {
        log(context, 'Loading info section');
        toggleViewState(context, { info: true });
      },
    },
    {
      id: 'api_keys',
      handler: async () => {
        log(context, 'Loading API keys section');
        await loadApiKeys(context);
      },
    },
    {
      id: 'products',
      handler: async () => {
        log(context, 'Loading products section');
        await loadProducts(context);
      },
    },
    {
      id: 'user_settings',
      handler: async () => {
        log(context, 'Loading user settings section');
        await loadUserSettings(context);
      },
    },
    {
      id: 'documentation',
      handler: async () => {
        log(context, 'Loading documentation section');
        await renderDocumentation(context, '/docs/merchant.md', 'documentationContent');
      },
    },
    {
      id: 'store-request',
      handler: async () => {
        log(context, 'Loading store request section');
        await import('../modules/site-request.js').then(m => m.initializeSiteRequest(context, 'store-request'));
      },
    },
  ]);
}

/**
 * Initializes the navigation module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Navigation instance with public methods.
 */
export function initializeNavigationModule(registry) {
  const context = 'navigation.js';
  log(context, 'Initializing navigation module for module registry');
  return {
    defineMerchantSectionHandlers: ctx => defineMerchantSectionHandlers(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'navigation.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

merchant/products.js

// /static/js/merchant/products.js
// Purpose: Manages product data fetching and rendering for the merchant page.

import { log } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { renderDataTable } from '../utils/ui-components.js';
import { withElement } from '../utils/dom-manipulation.js';
import { notifyError } from '../core/notifications.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Loads and renders product data in a table.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function loadProducts(context) {
  log(context, 'Loading products');
  await withErrorHandling(`${context}:loadProducts`, async () => {
    await withElement(context, 'productList', async productList => {
      const data = await fetchData(API_ENDPOINTS.PRODUCTS, { method: 'GET' });
      if (!data.products || data.products.length === 0) {
        productList.innerHTML = '<p>No products available.</p>';
        notifyError(context, ERROR_MESSAGES.NO_DATA('products'));
        return;
      }

      const headers = ['ID', 'Name', 'Price', 'Category', 'Stock'];
      const rowMapper = product => [
        product.id || 'N/A',
        product.name || 'N/A',
        product.price || 'N/A',
        product.category || 'N/A',
        product.stock || 'N/A',
      ];

      productList.innerHTML = renderDataTable(context, {
        data: data.products,
        headers,
        rowMapper,
        emptyMessage: ERROR_MESSAGES.NO_DATA('products'),
      });
    });
  }, ERROR_MESSAGES.FETCH_FAILED('products'));
}

/**
 * Initializes the products module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Products instance with public methods.
 */
export function initializeProductsModule(registry) {
  const context = 'products.js';
  log(context, 'Initializing products module for module registry');
  return {
    loadProducts: ctx => loadProducts(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'products.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

merchant/setup.js

// /static/js/merchant/setup.js
// Purpose: Handles additional initialization tasks for the merchant page.

import { log } from '../core/logger.js';
import { hasAdminPermission } from '../config/menus.js';
import { toggleViewState } from '../utils/dom-manipulation.js';
import { initializeSiteRequest } from '../modules/site-request.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Initializes merchant-specific modules and performs additional setup tasks.
 * @param {string} context - The context or module name.
 * @param {string} pageType - The type of page to initialize (e.g., 'info', 'store-request').
 * @returns {Promise<void>}
 */
export async function initializeMerchantModules(context, pageType) {
  log(context, `Initializing merchant modules for pageType: ${pageType}`);
  await withErrorHandling(`${context}:initializeMerchantModules`, async () => {
    // Check admin permission and toggle back button visibility
    if (hasAdminPermission(context)) {
      log(context, 'Admin permission detected, showing back button');
      toggleViewState(context, { 'button[data-role="admin"]': true });
    } else {
      toggleViewState(context, { 'button[data-role="admin"]': false });
    }

    // Initialize site request if pageType is store-request
    if (pageType === 'store-request') {
      log(context, 'Initializing site request module');
      await initializeSiteRequest(context, 'store-request');
    }

    // Additional setup (e.g., collapsible sections, other modules)
    if (typeof window.setupCollapsibleSections === 'function') {
      window.setupCollapsibleSections();
    }
  }, ERROR_MESSAGES.MODULE_INIT_FAILED);
}

/**
 * Initializes the setup module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Setup instance with public methods.
 */
export function initializeSetupModule(registry) {
  const context = 'setup.js';
  log(context, 'Initializing setup module for module registry');
  return {
    initializeMerchantModules: (ctx, ...args) => initializeMerchantModules(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'setup.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

merchant/user-settings.js

// /static/js/merchant/user-settings.js
// Purpose: Manages user settings for the merchant page, including rendering, form submission, and validation.

import { log } from '../core/logger.js';
import { renderSettingsForm } from '../utils/settings-renderer.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { setupEventListeners } from '../utils/event-listeners.js';
import { withErrorHandling } from '../utils/error.js';
import { SETTINGS } from '../config/settings.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Loads and renders user settings.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function loadUserSettings(context) {
  log(context, 'Loading user settings');
  const settingsConfig = SETTINGS.userSettings || {
    containerId: 'user-settings-icons',
    formId: 'settingsForm',
    fieldsId: 'user-settings-fields',
    endpoint: '/settings/user',
    type: 'user-settings',
    iconClass: 'fas fa-user',
  };
  await withErrorHandling(`${context}:loadUserSettings`, async () => {
    await renderSettingsForm(context, settingsConfig);
    setupUserSettingsEvents(context);
  }, ERROR_MESSAGES.RENDER_FAILED('user settings'));
}

/**
 * Sets up event listeners for user settings form submission.
 * @param {string} context - The context or module name.
 */
function setupUserSettingsEvents(context) {
  log(context, 'Setting up user settings event listeners');
  setupEventListeners(context, [
    {
      eventType: 'submit',
      selector: '#settingsForm',
      handler: async event => {
        event.preventDefault();
        await withErrorHandling(`${context}:submitUserSettings`, async () => {
          await submitConfiguredForm(context, 'settingsForm', '/settings/user', 'userSettings');
        }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
      },
    },
  ]);
}

/**
 * Transforms user settings form data for submission.
 * @param {FormData} formData - The form data.
 * @returns {Object} Transformed data for API submission.
 */
export function transformUserSettings(formData) {
  log('user-settings.js', 'Transforming user settings form data');
  return {
    contactName: formData.get('contactName')?.trim(),
    emailAddress: formData.get('emailAddress')?.trim(),
    websiteUrl: formData.get('websiteUrl')?.trim() || null,
    phoneNumber: formData.get('phoneNumber')?.trim() || null,
  };
}

/**
 * Validates user settings form data.
 * @param {FormData} formData - The form data.
 * @returns {boolean} True if valid, false otherwise.
 */
export function validateUserSettings(formData) {
  log('user-settings.js', 'Validating user settings form data');
  return formData.get('contactName')?.trim() && formData.get('emailAddress')?.trim();
}

/**
 * Initializes the user settings module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} User settings instance with public methods.
 */
export function initializeUserSettingsModule(registry) {
  return createModuleInitializer('user-settings.js', {
    loadUserSettings,
    transformUserSettings,
    validateUserSettings,
  });
}

// Initialize module with lifecycle logging
const context = 'user-settings.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

merchant-page.js

// /static/js/merchant-page.js
// Purpose: Orchestrates the merchant page, coordinating navigation, events, and module initialization.
const context = 'merchant-page.js';
import { log } from './core/logger.js';
import { parsePageType, initializeRolePage } from './utils/initialization.js';
import { withScriptLogging, hideOverlay } from './utils/logging-utils.js';
import { defineMerchantSectionHandlers } from './merchant/navigation.js';
import { initializeMerchantModules } from './merchant/setup.js';

/**
 * Initializes the merchant page.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeMerchantPage(context) {
  log(context, 'Initializing merchant page');
  const pageType = parsePageType(context, 'page', 'products');
  await initializeRolePage(context, 'merchant', pageType, async () => {
    defineMerchantSectionHandlers(context);
    await initializeMerchantModules(context, pageType);
  });
}

/**
 * Initializes the merchant-page module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} MerchantPage instance with public methods.
 */
export function initializeMerchantPageModule(registry) {
  const context = 'merchant-page.js';
  log(context, 'Initializing merchant-page module for module registry');
  return {
    initializeMerchantPage: ctx => initializeMerchantPage(ctx),
  };
}

// Initialize module with lifecycle logging
withScriptLogging(context, async () => {
    log(context, 'Module initialized');
    await initializeMerchantPage(context);
    hideOverlay();
});

modules/dataLoader.js

// /static/js/modules/dataLoader.js
// Purpose: Provides a centralized data loading utility for fetching data from API endpoints.

import { log } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Loads data from the specified endpoint, retained for compatibility with existing modules.
 * @param {string} context - The context or module name.
 * @param {string} endpoint - The API endpoint to fetch data from.
 * @returns {Promise<Object>} The fetched data.
 */
export async function load(context, endpoint) {
  log(context, `Loading data from endpoint: ${endpoint}`);
  return await withErrorHandling(`${context}:load`, async () => {
    const data = await fetchData(endpoint, { method: 'GET' });
    if (data.status === 'error') {
      throw new Error(ERROR_MESSAGES.FETCH_FAILED(endpoint));
    }
    return data;
  }, ERROR_MESSAGES.FETCH_FAILED(endpoint));
}

/**
 * Initializes the dataLoader module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} DataLoader instance with public methods.
 */
export function initializeDataLoaderModule(registry) {
  const context = 'dataLoader.js';
  log(context, 'Initializing dataLoader module for module registry');
  return {
    load: (ctx, ...args) => load(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'dataLoader.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

modules/navigation.js

// /static/js/modules/navigation.js
import { log } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { toggleViewState, withElement } from '../utils/dom-manipulation.js';
import { getMenu } from '../config/menus.js';
import { withScriptLogging } from '../utils/logging-utils.js';

const context = 'navigation.js';

/**
 * Defines section handlers for a given role.
 * @param {string} context - The context or module name.
 * @param {string} role - The role for which to define section handlers.
 * @param {Array} handlers - Array of handler configurations.
 * @returns {Object} An object mapping section IDs to handler functions.
 */
export function defineSectionHandlers(context, role, handlers = []) {
    log(context, `Defining section handlers for role: ${role}`);
    const menu = getMenu(role);
    const sectionHandlers = {};

    // Map menu items to handlers based on section IDs
    menu.forEach(item => {
        // Find the handler whose ID matches the menu item's ID
        const handlerConfig = handlers.find(h => h.id === item.id);
        if (handlerConfig && handlerConfig.handler) {
            // Map the section from the menu to the handler
            sectionHandlers[item.section] = async () => {
                log(context, `Navigating to section ${item.section}, hiding others`);
                // Hide all other sections and show the target section
                toggleViewState(context, {
                    [item.section]: true,
                    ...menu.reduce((acc, menuItem) => {
                        if (menuItem.section !== item.section) {
                            acc[menuItem.section] = false;
                        }
                        return acc;
                    }, {}),
                    info: item.section === 'info' ? true : false,
                });
                await handlerConfig.handler();
            };
        }
    });

    // Add a handler for the 'info' section if not already present
    if (!sectionHandlers['info']) {
        const infoHandler = handlers.find(h => h.id === 'info');
        if (infoHandler) {
            sectionHandlers['info'] = async () => {
                log(context, `Navigating to section info, hiding others`);
                toggleViewState(context, {
                    info: true,
                    forgotPasswordContainer: false,
                    signupContainer: false,
                });
                await infoHandler.handler();
            };
        }
    }

    // Log the defined handlers for debugging
    log(context, `Section handlers defined for role ${role}:`, Object.keys(sectionHandlers));
    return sectionHandlers;
}

/**
 * Initializes navigation for a role by rendering the menu and setting up section handlers.
 * @param {HTMLElement} element - The DOM element to render the menu into.
 * @param {Array} menu - The menu configuration for the role.
 * @param {Object} options - Options for navigation setup.
 * @param {Object} options.sectionHandlers - Section handler functions.
 * @param {string} options.defaultSection - The default section to display.
 */
export function initializeRoleNavigation(element, menu, { sectionHandlers, defaultSection }) {
    log(context, `Initializing role navigation with menu:`, menu);

    if (!element) {
        log(context, 'Navigation element not provided');
        return;
    }

    // Render menu buttons with icons sized to 16x16 pixels
    element.innerHTML = menu.map(item => `
        <button data-section="${item.section}">
            ${item.icon ? `<i class="${item.icon}" style="width: 16px; height: 16px; font-size: 16px; margin-right: 5px;"></i>` : ''} ${item.label}
        </button>
    `).join('');

    // Set up click event listeners for menu buttons
    menu.forEach(item => {
        const button = element.querySelector(`[data-section="${item.section}"]`);
        if (button) {
            button.addEventListener('click', () => {
                log(context, `Navigating to section: ${item.section}`);
                const handler = sectionHandlers[item.section];
                if (handler) {
                    handler();
                } else {
                    log(context, `No handler found for section: ${item.section}`);
                }
            });
        }
    });

    // Activate the default section
    if (defaultSection) {
        log(context, `Activating default section: ${defaultSection}`);
        const defaultHandler = sectionHandlers[defaultSection];
        if (defaultHandler) {
            defaultHandler();
        } else {
            log(context, `No handler found for default section: ${defaultSection}`);
        }
    }
}

/**
 * Initializes the navigation module for use with the module registry.
 * @param {Map} registry - The module registry instance.
 * @returns {Object} Module instance with public methods.
 */
export function initializeNavigationModule(registry) {
    log(context, 'Initializing navigation module for module registry');
    return {
        defineSectionHandlers: (ctx, role, handlers) => defineSectionHandlers(ctx, role, handlers),
        initializeRoleNavigation: (element, menu, options) => initializeRoleNavigation(element, menu, options),
    };
}

// Initialize the module with lifecycle logging
withScriptLogging(context, () => {
    log(context, 'Module initialized');
});

modules/pageSetup.js

// /static/js/modules/pageSetup.js
// Purpose: Provides utilities for setting up page-specific configurations and navigation.

import { log } from '../core/logger.js';
import { parsePageType } from '../utils/initialization.js';
import { withAuthenticatedUser } from '../utils/auth.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Sets up a page with role-based navigation and user authentication.
 * @param {string} context - The context or module name.
 * @param {string} role - The role associated with the page (e.g., 'admin', 'merchant').
 * @param {string} defaultSection - The default section to show.
 * @param {Function} setupCallback - Callback to execute after setup.
 * @returns {Promise<void>}
 */
export async function setupPage(context, role, defaultSection, setupCallback) {
  log(context, `Setting up page for role: ${role}, default section: ${defaultSection}`);
  await withAuthenticatedUser(async userId => {
    await withErrorHandling(`${context}:setupPage`, async () => {
      const userIdInput = document.getElementById('userId');
      if (userIdInput) userIdInput.value = userId;
      await setupCallback();
      window.setupCollapsibleSections?.();
    }, ERROR_MESSAGES.MODULE_INIT_FAILED);
  });
}

/**
 * Initializes the pageSetup module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} PageSetup instance with public methods.
 */
export function initializePageSetupModule(registry) {
  const context = 'pageSetup.js';
  log(context, 'Initializing pageSetup module for module registry');
  return {
    setupPage: (ctx, ...args) => setupPage(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'pageSetup.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

modules/site-request.js

// /static/js/modules/site-request.js
// Purpose: Manages site request form submission, loading, and UI updates for merchant and community roles.

import { log } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { setupEventListeners } from '../utils/event-listeners.js';
import { withAuthenticatedUser } from '../utils/auth.js';
import { withElement, toggleViewState } from '../utils/dom-manipulation.js';
import { initializeTinyMCE } from '../core/mce.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Initializes the site request form, including loading data and setting up event listeners.
 * @param {string} context - The context or module name.
 * @param {string} sectionId - The ID of the section to initialize (e.g., 'store-request', 'site-request').
 * @returns {Promise<void>}
 */
export async function initializeSiteRequest(context, sectionId = 'store-request') {
  log(context, `Initializing site request for section: ${sectionId}`);
  await withAuthenticatedUser(async userId => {
    await withErrorHandling(`${context}:initializeSiteRequest`, async () => {
      await loadSiteRequest(context, sectionId, userId);
      setupSiteRequestEvents(context, sectionId, userId);
    }, ERROR_MESSAGES.MODULE_INIT_FAILED);
  });
}

/**
 * Loads and populates the site request form with data from the server.
 * @param {string} context - The context or module name.
 * @param {string} sectionId - The ID of the section to populate (e.g., 'store-request', 'site-request').
 * @param {string} userId - The user ID.
 * @returns {Promise<void>}
 */
async function loadSiteRequest(context, sectionId, userId) {
  log(context, `Loading site request data for section: ${sectionId}`);
  await withErrorHandling(`${context}:loadSiteRequest`, async () => {
    await withElement(context, sectionId, async (section) => {
      // Fetch site request data
      const data = await fetchData(context, `${API_ENDPOINTS.SITE_REQUEST}/${userId}`);
      if (!data) {
        log(context, 'No site request data available');
        return;
      }

      // Determine role-specific field IDs (merchant or community)
      const fieldIds = {
        storeName: sectionId === 'store-request' ? 'storeName' : 'communityStoreName',
        aboutStore: sectionId === 'store-request' ? 'aboutStore' : 'communityAboutStore',
        colorPreference: sectionId === 'store-request' ? 'colorPreference' : 'communityColorPreference',
        stylingDetails: sectionId === 'store-request' ? 'stylingDetails' : 'communityStylingDetails',
        domain: sectionId === 'store-request' ? 'domain' : 'communityDomain',
        emailsContainer: sectionId === 'store-request' ? 'emailsContainer' : 'communityEmailsContainer',
        pagesContainer: sectionId === 'store-request' ? 'pagesContainer' : 'communityPagesContainer',
      };

      // Populate form fields
      document.getElementById(fieldIds.storeName)?.setAttribute('value', data.storeName || '');
      document.getElementById(fieldIds.aboutStore)?.setAttribute('value', data.about || '');
      document.getElementById(fieldIds.colorPreference)?.setAttribute('value', data.colorPreference || '');
      document.getElementById(fieldIds.stylingDetails)?.setAttribute('value', data.stylingDetails || '');
      document.getElementById(fieldIds.domain)?.setAttribute('value', data.domain || '');

      // Populate emails
      const emailsContainer = document.getElementById(fieldIds.emailsContainer);
      if (emailsContainer && data.emails) {
        emailsContainer.innerHTML = data.emails.map((email, index) => `
          <div class="email-entry">
            <input type="email" name="email_${index}" value="${email}">
            <button type="button" class="remove-email" data-index="${index}">Remove</button>
          </div>
        `).join('');
      }

      // Populate pages
      const pagesContainer = document.getElementById(fieldIds.pagesContainer);
      if (pagesContainer && data.pages) {
        pagesContainer.innerHTML = data.pages.map((page, index) => `
          <div class="page-entry">
            <input type="text" name="page_${index}_title" value="${page.title}">
            <textarea name="page_${index}_content">${page.content}</textarea>
            <button type="button" class="remove-page" data-index="${index}">Remove</button>
          </div>
        `).join('');
      }

      // Initialize TinyMCE for rich text fields
      await initializeTinyMCE(context, [
        fieldIds.aboutStore,
        ...data.pages.map((_, i) => `page_${i}_content`),
      ]);

      // Update domain preview if function exists
      if (typeof window.updateDomainPreview === 'function') {
        window.updateDomainPreview(data.domain);
      }

      // Show the section
      toggleViewState(context, { [sectionId]: true });
    });
  }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Sets up event listeners for site request form submission and UI interactions.
 * @param {string} context - The context or module name.
 * @param {string} sectionId - The ID of the section (e.g., 'store-request', 'site-request').
 * @param {string} userId - The user ID.
 */
function setupSiteRequestEvents(context, sectionId, userId) {
  log(context, `Setting up site request event listeners for section: ${sectionId}`);
  setupEventListeners(context, [
    {
      eventType: 'submit',
      selector: '#siteRequestForm',
      handler: async event => {
        event.preventDefault();
        await submitConfiguredForm(context, 'siteRequestForm', API_ENDPOINTS.SITE_REQUEST(userId), 'siteRequest', {
          onSuccess: data => {
            log(context, 'Site request submitted successfully:', data);
          },
        });
      },
    },
    {
      eventType: 'click',
      selector: '.remove-email',
      handler: event => {
        const index = event.target.dataset.index;
        const emailEntry = document.querySelector(`.email-entry:nth-child(${parseInt(index) + 1})`);
        if (emailEntry) emailEntry.remove();
        log(context, `Removed email entry at index: ${index}`);
      },
    },
    {
      eventType: 'click',
      selector: '.remove-page',
      handler: event => {
        const index = event.target.dataset.index;
        const pageEntry = document.querySelector(`.page-entry:nth-child(${parseInt(index) + 1})`);
        if (emailEntry) pageEntry.remove();
        log(context, `Removed page entry at index: ${index}`);
      },
    },
  ]);
}

/**
 * Initializes the site-request module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} SiteRequest instance with public methods.
 */
export function initializeSiteRequestModule(registry) {
  const context = 'site-request.js';
  log(context, 'Initializing site-request module for module registry');
  return {
    initializeSiteRequest: (ctx, ...args) => initializeSiteRequest(ctx, ...args),
    loadSiteRequest: (ctx, ...args) => loadSiteRequest(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'site-request.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

modules/userSettings.js

// /static/js/modules/userSettings.js
// Purpose: Manages user settings form submission and UI rendering.

import { log } from '../core/logger.js';
import { renderSettings } from '../utils/settings-renderer.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { setupEventListeners } from '../utils/event-listeners.js';
import { SETTINGS } from '../config/settings.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Loads and renders user settings.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function loadUserSettings(context) {
  log(context, 'Loading user settings');
  const settingsConfig = SETTINGS.userSettings || {
    containerId: 'userSettingsIcons',
    formId: 'userSettingsForm',
    fieldsId: 'userSettingsFields',
    endpoint: '/settings/user',
    type: 'user-settings',
    iconClass: 'fas fa-user',
  };
  await renderSettings(context, settingsConfig);
  setupUserSettingsEvents(context);
}

/**
 * Sets up event listeners for user settings form submission.
 * @param {string} context - The context or module name.
 */
function setupUserSettingsEvents(context) {
  log(context, 'Setting up user settings event listeners');
  setupEventListeners(context, [
    {
      eventType: 'submit',
      selector: '#userSettingsForm',
      handler: async event => {
        event.preventDefault();
        await submitConfiguredForm(context, 'userSettingsForm', '/settings/user', 'userSettings');
      },
    },
  ]);
}

/**
 * Initializes the userSettings module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} UserSettings instance with public methods.
 */
export function initializeUserSettingsModule(registry) {
  const context = 'userSettings.js';
  log(context, 'Initializing userSettings module for module registry');
  return {
    loadUserSettings: ctx => loadUserSettings(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'userSettings.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

partner/initializer.js

// /static/js/partner/initializer.js
// Purpose: Initializes partner-specific modules and navigation for the partner page.

import { log } from '../core/logger.js';
import { withAuthenticatedUser } from '../utils/auth.js';
import { withErrorHandling } from '../utils/error.js';
import { definePartnerSectionHandlers } from './navigation.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Initializes partner modules and sets up navigation.
 * @param {string} context - The context or module name.
 * @param {string} pageType - The type of page to initialize (e.g., 'integrations').
 * @returns {Promise<void>}
 */
export async function initializePartnerModules(context, pageType) {
  log(context, `Initializing partner modules for page type: ${pageType}`);
  await withAuthenticatedUser(async userId => {
    await withErrorHandling(`${context}:initializePartnerModules`, async () => {
      const userIdInput = document.getElementById('userId');
      if (userIdInput) userIdInput.value = userId;
      definePartnerSectionHandlers(context);
      window.setupCollapsibleSections?.();
    }, ERROR_MESSAGES.MODULE_INIT_FAILED);
  });
}

/**
 * Initializes the initializer module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Initializer instance with public methods.
 */
export function initializeInitializerModule(registry) {
  const context = 'initializer.js';
  log(context, 'Initializing initializer module for module registry');
  return {
    initializePartnerModules: (ctx, ...args) => initializePartnerModules(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'initializer.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

partner/integrations-data.js

// /static/js/partner/integrations-data.js
// Purpose: Manages data fetching for integration settings on the partner page.

import { log } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Loads integration settings from the server.
 * @param {string} context - The context or module name.
 * @returns {Promise<Array>} The fetched integration settings.
 */
export async function loadIntegrations(context) {
  log(context, 'Loading integration settings');
  return await withErrorHandling(`${context}:loadIntegrations`, async () => {
    const data = await fetchData(context, API_ENDPOINTS.CLIENT_API);
    return data.settings || [];
  }, ERROR_MESSAGES.FETCH_FAILED('integrations'), () => []);
}

/**
 * Initializes the integrations-data module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} IntegrationsData instance with public methods.
 */
export function initializeIntegrationsDataModule(registry) {
  const context = 'integrations-data.js';
  log(context, 'Initializing integrations-data module for module registry');
  return {
    loadIntegrations: ctx => loadIntegrations(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'integrations-data.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

partner/integrations-ui.js

// /static/js/partner/integrations-ui.js
// Purpose: Manages UI rendering for integration settings on the partner page.

import { log } from '../core/logger.js';
import { renderSettingsForm } from '../utils/settings-renderer.js';
import { toggleViewState } from '../utils/dom-manipulation.js';
import { renderMarkdownContent } from '../utils/form-rendering.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Renders integration settings based on the provided data and container.
 * @param {string} context - The context or module name.
 * @param {Array} settings - The integration settings data.
 * @param {string} containerId - The ID of the container to render into.
 * @returns {Promise<void>}
 */
export async function renderIntegrations(context, settings, containerId) {
  log(context, `Rendering integration settings in container: ${containerId}`);
  await withErrorHandling(`${context}:renderIntegrations`, async () => {
    await renderSettingsForm(context, {
      containerId,
      formId: 'integrationsForm',
      fieldsId: 'integrationsFields',
      settings,
      type: 'integrations',
      endpoint: '/client-api',
      iconClass: 'fas fa-plug',
      onIconClick: (setting, fieldsContainer, form) => {
        toggleViewState(context, { integrationsFields: true });
        Array.from(document.getElementById(containerId).children).forEach(child => {
          child.style.color = child.dataset.keyType === setting.keyType ? '#007bff' : '#C0C0C0';
        });
      },
      onReadmeClick: async setting => {
        const readmeLink = setting.docLink?.find(link => link.title === 'readme')?.link;
        if (readmeLink) {
          await renderMarkdownContent(context, readmeLink, `mdContent-${setting.keyType}`);
          toggleViewState(context, { [`mdContent-${setting.keyType}`]: true });
        }
      },
    });
  }, ERROR_MESSAGES.RENDER_FAILED('integrations'));
}

/**
 * Initializes the integrations-ui module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} IntegrationsUi instance with public methods.
 */
export function initializeIntegrationsUiModule(registry) {
  return createModuleInitializer('integrations-ui.js', {
    renderIntegrations,
  });
}

// Initialize module with lifecycle logging
const context = 'integrations-ui.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

partner/integrations.js

// /static/js/partner/integrations.js
// Purpose: Orchestrates the integrations settings page, coordinating data fetching, UI rendering, and event setup.

import { log } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { loadIntegrations } from './integrations-data.js';
import { renderIntegrations } from './integrations-ui.js';
import { setupPartnerEvents } from './partner-events.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Loads and renders integration settings.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function loadIntegrationsSettings(context) {
  log(context, 'Loading integration settings');
  await withErrorHandling(`${context}:loadIntegrationsSettings`, async () => {
    const settings = await loadIntegrations(context);
    await renderIntegrations(context, settings, 'integrationsIconsBar');
    setupPartnerEvents(context);
  }, ERROR_MESSAGES.FETCH_FAILED('integrations'));
}

/**
 * Initializes the integrations module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Integrations instance with public methods.
 */
export function initializeIntegrationsModule(registry) {
  const context = 'integrations.js';
  log(context, 'Initializing integrations module for module registry');
  return {
    loadIntegrationsSettings: ctx => loadIntegrationsSettings(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'integrations.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

partner/navigation.js

// /static/js/partner/navigation.js
import { log } from '../core/logger.js';
import { defineSectionHandlers } from '../modules/navigation.js';
import { loadIntegrationsSettings } from './integrations.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { toggleViewState } from '../utils/dom-manipulation.js';

/**
 * Defines section handlers for the partner page.
 * @param {string} context - The context or module name.
 * @returns {void}
 */
export function definePartnerSectionHandlers(context) {
  log(context, 'Defining partner section handlers');
  defineSectionHandlers(context, 'partner', [
    {
      id: 'info',
      handler: async () => {
        log(context, 'Loading info section');
        toggleViewState(context, { info: true });
      },
    },
    {
      id: 'integrations',
      handler: async () => {
        log(context, 'Loading integrations section');
        await loadIntegrationsSettings(context);
      },
    },
  ]);
}

/**
 * Initializes the navigation module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Navigation instance with public methods.
 */
export function initializeNavigationModule(registry) {
  const context = 'navigation.js';
  log(context, 'Initializing navigation module for module registry');
  return {
    definePartnerSectionHandlers: ctx => definePartnerSectionHandlers(ctx),
  };
}
import { withScriptLogging } from './logging-utils.js';
// Initialize module with lifecycle logging
const context = 'navigation.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

partner/partner-events.js

// /static/js/partner/partner-events.js
// Purpose: Manages top-level event listeners for the partner page, delegating feature-specific events.

import { log } from '../core/logger.js';
import { setupEventListeners } from '../utils/event-listeners.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { toggleViewState } from '../utils/dom-manipulation.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Sets up top-level event listeners for the partner page.
 * @param {string} context - The context or module name.
 * @returns {void}
 */
export function setupPartnerEvents(context) {
  log(context, 'Setting up partner event listeners');
  withErrorHandling(`${context}:setupPartnerEvents`, () => {
    setupEventListeners(context, [
      {
        eventType: 'submit',
        selector: '#integrationsForm',
        handler: async event => {
          event.preventDefault();
          await withErrorHandling(`${context}:submitIntegrationsForm`, async () => {
            await submitConfiguredForm(context, 'integrationsForm', '/client-api', 'integrations', {
              successMessage: SUCCESS_MESSAGES.SETTINGS_UPDATED,
              onSuccess: () => {
                log(context, 'Integration settings updated');
                toggleViewState(context, { integrationsFields: true });
              },
            });
          }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
        },
      },
import { withScriptLogging } from './logging-utils.js';
        eventType: 'click',
        selector: '#partnerNavToggle',
        handler: async () => {
          await withErrorHandling(`${context}:toggleNavigation`, async () => {
            log(context, 'Toggling partner navigation');
            toggleViewState(context, { partnerNav: true });
          }, ERROR_MESSAGES.SECTION_TOGGLE_FAILED);
        },
      },
    ]);
  }, ERROR_MESSAGES.EVENT_HANDLER_FAILED);
}

/**
 * Initializes the partner events module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Events instance with public methods.
 */
export function initializePartnerEventsModule(registry) {
  return createModuleInitializer('partner-events.js', {
    setupPartnerEvents,
  });
}

// Initialize module with lifecycle logging
const context = 'partner-events.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

partner-page.js

// /static/js/partner-page.js
// Purpose: Orchestrates the partner page, coordinating navigation, events, and module initialization.
const context = 'partner-page.js';
import { log } from './core/logger.js';
import { parsePageType, initializeRolePage } from './utils/initialization.js';
import { withScriptLogging, hideOverlay } from './utils/logging-utils.js';
import { definePartnerSectionHandlers } from './partner/navigation.js';
import { setupPartnerEvents } from './partner/partner-events.js';
import { initializePartnerModules } from './partner/initializer.js';

/**
 * Initializes the partner page.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializePartnerPage(context) {
  log(context, 'Initializing partner page');
  const pageType = parsePageType(context, 'page', 'integrations');
import { withScriptLogging } from './logging-utils.js'; async () => {
    definePartnerSectionHandlers(context);
    initializePartnerModules(context, pageType);
    setupPartnerEvents(context);
  });
}

/**
 * Initializes the partner-page module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} PartnerPage instance with public methods.
 */
export function initializePartnerPageModule(registry) {
  const context = 'partner-page.js';
  log(context, 'Initializing partner-page module for module registry');
  return {
    initializePartnerPage: ctx => initializePartnerPage(ctx),
  };
}

// Initialize module with lifecycle logging
withScriptLogging(context, async () => {
    log(context, 'Module initialized');
    await initializePartnerPage(context);
    hideOverlay();
});

utils/data-fetch.js

// /static/js/utils/data-fetch.js
// Purpose: Provides a centralized utility for fetching data from API endpoints.

import { log } from '../core/logger.js';
import { authenticatedFetch } from '../core/auth.js'; // Updated import to core/auth.js
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/messages.js'; // Updated import to messages.js
import { withScriptLogging } from './initialization.js';

const context = 'data-fetch.js';

/**
 * Fetches data from the specified endpoint with optional fetch options.
 * @param {string} context - The context or module name.
 * @param {string} endpoint - The API endpoint URL.
 * @param {Object} [options={}] - Fetch options (e.g., method, headers, body).
 * @param {boolean} [useAuth=true] - Whether to use authenticated fetch (default: true).
 * @returns {Promise<Object>} The fetched data.
 */
export async function fetchData(context, endpoint, options = {}, useAuth = true) {
  log(context, `Fetching data from endpoint: ${endpoint}, useAuth: ${useAuth}`);
  const fetchFunction = useAuth ? authenticatedFetch : fetch; // Use authenticatedFetch or regular fetch
  const response = await fetchFunction(endpoint, options);
  const data = await response.json();
  if (data.status === 'error') {
    throw new Error(data.message || ERROR_MESSAGES.FETCH_FAILED(endpoint));
  }
  return data;
}

/**
 * Initializes the data-fetch module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} DataFetch instance with public methods.
 */
export function initializeDataFetchModule(registry) {
  log(context, 'Initializing data-fetch module for module registry');
  return {
    fetchData: (ctx, ...args) => fetchData(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

utils/dom-events.js

// /static/js/utils/dom-events.js
// Purpose: Provides utilities for managing DOM events.

import { log } from '../core/logger.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from './initialization.js';

/**
 * Registers a single DOM event listener with error handling.
 * @param {string} context - The context or module name.
 * @param {string} eventType - The event type (e.g., 'click', 'submit').
 * @param {string} selector - The CSS selector for the target element.
 * @param {Function} handler - The event handler function.
 * @returns {void}
 */
export function registerEventListener(context, eventType, selector, handler) {
  log(context, `Registering ${eventType} event listener for selector: ${selector}`);
  withErrorHandling(`${context}:registerEventListener`, () => {
    const elements = document.querySelectorAll(selector);
    if (elements.length === 0) {
      log(context, `No elements found for selector: ${selector}`);
      return;
    }
    elements.forEach(element => {
      element.addEventListener(eventType, async event => {
        await withErrorHandling(`${context}:eventHandler`, () => handler(event), ERROR_MESSAGES.EVENT_HANDLER_FAILED);
      });
    });
  }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Initializes the dom-events module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} DomEvents instance with public methods.
 */
export function initializeDomEventsModule(registry) {
  const context = 'dom-events.js';
  log(context, 'Initializing dom-events module for module registry');
  return {
    registerEventListener: (ctx, ...args) => registerEventListener(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'dom-events.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

utils/dom-manipulation.js

// /static/js/utils/dom-manipulation.js
// Purpose: Provides utilities for DOM manipulation with retry logic and visibility toggling.

import { log } from '../core/logger.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from './initialization.js';

// Cache for DOM elements to reduce repeated queries
const elementCache = new Map();

/**
 * Executes a callback with a DOM element, retrying if the element is not found.
 * @param {string} context - The context or module name.
 * @param {string} elementId - The ID of the DOM element.
 * @param {Function} callback - The callback to execute with the element.
 * @param {number} [maxAttempts=10] - Maximum retry attempts.
 * @param {number} [retryDelay=100] - Delay between retries in milliseconds.
 * @param {boolean} [checkVisibility=false] - Whether to check element visibility.
 * @returns {Promise<void>}
 */
export async function withElement(context, elementId, callback, maxAttempts = 10, retryDelay = 100, checkVisibility = false) {
  log(context, `Accessing element: ${elementId}`);
  if (elementCache.has(elementId)) {
    log(context, `Using cached element: ${elementId}`);
    return await callback(elementCache.get(elementId));
  }
  return await withErrorHandling(`${context}:withElement`, async () => {
    const element = await waitForElement(context, elementId, maxAttempts, retryDelay);
    if (checkVisibility && element.offsetParent === null) {
      throw new Error(`Element ${elementId} is not visible`);
    }
    elementCache.set(elementId, element);
    return await callback(element);
  }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Fetches multiple DOM elements and returns them as an object.
 * @param {string} context - The context or module name.
 * @param {string[]} elementIds - Array of DOM element IDs to fetch.
 * @param {number} [maxAttempts=10] - Maximum retry attempts.
 * @param {number} [retryDelay=100] - Delay between retries in milliseconds.
 * @returns {Promise<Object>} Object mapping element IDs to DOM elements.
 */
export async function getElements(context, elementIds, maxAttempts = 10, retryDelay = 100) {
  log(context, `Fetching elements: ${elementIds.join(', ')}`);
  return await withErrorHandling(`${context}:getElements`, async () => {
    const elements = {};
    for (const id of elementIds) {
      if (elementCache.has(id)) {
        elements[id] = elementCache.get(id);
        continue;
      }
      const element = await waitForElement(context, id, maxAttempts, retryDelay);
      elementCache.set(id, element);
      elements[id] = element;
    }
    return elements;
  }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Waits for a DOM element to be available, retrying if not found.
 * @param {string} context - The context or module name.
 * @param {string} elementId - The ID of the DOM element.
 * @param {number} maxAttempts - Maximum retry attempts.
 * @param {number} retryDelay - Delay between retries in milliseconds.
 * @returns {Promise<HTMLElement>} The found element.
 */
async function waitForElement(context, elementId, maxAttempts, retryDelay) {
  log(context, `Waiting for element: ${elementId}`);
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    const element = document.getElementById(elementId);
    if (element) {
      log(context, `Element found: ${elementId}`);
      return element;
    }
    log(context, `Element not found, attempt ${attempt}/${maxAttempts}`);
    await new Promise(resolve => setTimeout(resolve, retryDelay));
  }
  throw new Error(`Element ${elementId} not found after ${maxAttempts} attempts`);
}

/**
 * Toggles the visibility of elements based on a state object, hiding all other sections with class '.section'.
 * @param {string} context - The context or module name.
 * @param {Object.<string, boolean>} state - Object mapping element IDs to visibility states.
 * @returns {void}
 */
export function toggleViewState(context, state) {
  log(context, 'Toggling view state:', state);
  withErrorHandling(`${context}:toggleViewState`, () => {
    const allSections = document.querySelectorAll('.section');
    allSections.forEach(section => {
      const id = section.id;
      if (state.hasOwnProperty(id)) {
        section.style.display = state[id] ? 'block' : 'none';
        log(context, `Set ${id} display to ${state[id] ? 'visible' : 'hidden'}`);
      } else {
        section.style.display = 'none';
        log(context, `Hid section ${id} as it's not in the state object`);
      }
    });
  }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Sets up event listeners for collapsible sections.
 * @param {string} context - The context or module name.
 * @returns {void}
 */
export function setupCollapsibleSections(context) {
  log(context, 'Setting up collapsible sections');
  withErrorHandling(`${context}:setupCollapsibleSections`, () => {
    const toggleSections = document.querySelectorAll('.toggle-section');
    toggleSections.forEach(section => {
      section.addEventListener('click', () => {
        const targetId = section.getAttribute('data-toggle');
        const targetContent = document.getElementById(targetId);
        if (targetContent) {
          const isOpen = targetContent.classList.contains('open');
          const parentSection = section.closest('.section');
          if (parentSection) {
            parentSection.querySelectorAll('.toggle-content.open').forEach(content => {
              content.classList.remove('open');
              content.style.display = 'none';
            });
          }
          if (!isOpen) {
            targetContent.classList.add('open');
            targetContent.style.display = 'block';
          }
        } else {
          log(context, `Target content not found for ID: ${targetId}`);
        }
      });
    });
  }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Initializes the dom-manipulation module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} DomManipulation instance with public methods.
 */
export function initializeDomManipulationModule(registry) {
  const context = 'dom-manipulation.js';
  log(context, 'Initializing dom-manipulation module for module registry');
  return {
    withElement: (ctx, ...args) => withElement(ctx, ...args),
    getElements: (ctx, ...args) => getElements(ctx, ...args),
    toggleViewState: (ctx, ...args) => toggleViewState(ctx, ...args),
    setupCollapsibleSections: (ctx) => setupCollapsibleSections(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'dom-manipulation.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

utils/error.js

// /static/js/utils/error.js
// Purpose: Provides error handling utilities.

import { log } from '../core/logger.js';
import { ERROR_MESSAGES } from '../config/messages.js';

const context = 'error.js';

/**
 * Wraps a function with error handling, logging errors and throwing a default message if needed.
 * @param {string} context - The context or module name.
 * @param {Function} fn - The function to execute.
 * @param {string} operation - The operation name for logging.
 * @returns {*} The result of the function execution.
 * @throws {Error} If the function fails and no default message is provided.
 */
export function withErrorHandling(context, fn, operation) {
    log(context, `Executing ${operation || 'operation'} with error handling`);
    try {
        return fn();
    } catch (error) {
        log(context, `Error during ${operation || 'operation'}: ${error.message}`);
        throw new Error(error.message || ERROR_MESSAGES.DEFAULT);
    }
}

// Removed lifecycle logging to break circular dependency
// withScriptLogging(context, () => {
//     log(context, 'Module initialized');
// });s

utils/event-listeners.js

// /static/js/utils/event-listeners.js
// Purpose: Provides utilities for setting up DOM event listeners.

import { log } from '../core/logger.js';
import { registerEventListener } from './dom-events.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Event configuration registry for common event patterns.
 * @type {Object.<string, Object>}
 */
const EVENT_CONFIGS = {
  formSubmit: {
    eventType: 'submit',
    selector: '#{formId}',
    handler: async (context, event, formId, endpoint, configKey, options) => {
      event.preventDefault();
      const { submitConfiguredForm } = await import('../utils/form-submission.js');
      await withErrorHandling(`${context}:formSubmit`, () => submitConfiguredForm(context, formId, endpoint, configKey, options), ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
    },
  },
  navigationToggle: {
    eventType: 'click',
    selector: '#{navToggleId}',
    handler: async (context, event, navId) => {
      const { toggleViewState } = await import('./dom-manipulation.js');
      await withErrorHandling(`${context}:navigationToggle`, () => {
        log(context, `Toggling navigation: ${navId}`);
        toggleViewState(context, { [navId]: true });
      }, ERROR_MESSAGES.SECTION_TOGGLE_FAILED);
import { withScriptLogging } from './logging-utils.js';
  },
  permissionChange: {
    eventType: 'change',
    selector: '#userList input[data-userId][data-permission]',
    handler: async (context, event) => {
      const { updateUserPermission } = await import('../admin/users-data.js');
      const { userId, permission, role } = event.target.dataset;
      const isChecked = event.target.checked;
      await withErrorHandling(`${context}:permissionChange`, async () => {
        log(context, `Processing permission change for user ${userId}, permission ${permission}, role ${role}`);
        await updateUserPermission(context, userId, permission, isChecked, role);
      }, ERROR_MESSAGES.FETCH_FAILED('permission update'), () => {
        event.target.checked = !isChecked; // Revert checkbox on error
      });
    },
  },
  modifyPermissions: {
    eventType: 'click',
    selector: '#userList .modify-permissions',
    handler: async (context, event) => {
      const { fetchUserForPermissions } = await import('../admin/users-data.js');
      const { renderPermissionsModal } = await import('../admin/users-ui.js');
      const { setupAdminEvents } = await import('../admin/admin-events.js');
      const { userId, role } = event.target.dataset;
      await withErrorHandling(`${context}:modifyPermissions`, async () => {
        log(context, `Initiating permissions modification for user ${userId}, role ${role}`);
        const userData = await fetchUserForPermissions(context, userId);
        await renderPermissionsModal(context, userId, userData, role);
        setupAdminEvents(context); // Re-apply modal events
      }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
    },
  },
  categoryCheckboxChange: {
    eventType: 'change',
    selector: 'input[data-deselected]',
    handler: async (context, event) => {
      const { updateDeselectedCategories } = await import('../community/categories-data.js');
      const { updateFormState } = await import('../utils/form-submission.js');
      const { withElement } = await import('./dom-manipulation.js');
      await withErrorHandling(`${context}:categoryCheckboxChange`, async () => {
        await withElement(context, 'deselected', async (deselectedInput) => {
          await withElement(context, 'previousDeselected', async (previousDeselectedInput) => {
            const allCategories = Array.from(document.querySelectorAll('input[name="selected"]')).map(cb => cb.value);
            const selectedCategories = Array.from(document.querySelectorAll('input[name="selected"]:checked')).map(cb => cb.value);
            const { deselected, previousDeselected } = updateDeselectedCategories(context, selectedCategories, allCategories);
            await updateFormState(context, 'categoryForm', {
              deselected: JSON.stringify(deselected),
              previousDeselected: JSON.stringify(previousDeselected),
            });
            log(context, 'Updated deselections:', deselected);
          });
        }, 10, 100, true);
      }, ERROR_MESSAGES.DATA_PROCESSING_FAILED);
    },
  },
};

/**
 * Sets up multiple event listeners based on the provided configurations.
 * @param {string} context - The context or module name.
 * @param {Array<{eventType: string, selector: string, handler: Function}>} listeners - Array of listener configurations.
 * @returns {void}
 */
export function setupEventListeners(context, listeners) {
  log(context, 'Setting up event listeners');
  withErrorHandling(`${context}:setupEventListeners`, () => {
    listeners.forEach(({ eventType, selector, handler }) => {
      registerEventListener(context, eventType, selector, async event => {
        await withErrorHandling(`${context}:eventHandler`, () => handler(event), ERROR_MESSAGES.EVENT_HANDLER_FAILED);
      });
    });
  }, ERROR_MESSAGES.EVENT_HANDLER_FAILED);
}

/**
 * Registers event listeners from the event configuration registry.
 * @param {string} context - The context or module name.
 * @param {Array<string>} configKeys - Array of event configuration keys.
 * @param {Object} [params={}] - Parameters to customize selectors and handlers.
 * @returns {void}
 */
export function registerEvents(context, configKeys, params = {}) {
  log(context, `Registering events: ${configKeys.join(', ')}`);
  withErrorHandling(`${context}:registerEvents`, () => {
    configKeys.forEach(key => {
      const config = EVENT_CONFIGS[key];
      if (!config) {
        log(context, `Event configuration not found: ${key}`);
        return;
      }
      let selector = config.selector;
      if (selector.includes('{')) {
        selector = selector.replace(/{(\w+)}/g, (_, param) => params[param] || '');
      }
      registerEventListener(context, config.eventType, selector, async event => {
        await withErrorHandling(`${context}:${key}`, () => config.handler(context, event, ...Object.values(params)), ERROR_MESSAGES.EVENT_HANDLER_FAILED);
      });
    });
  }, ERROR_MESSAGES.EVENT_HANDLER_FAILED);
}

/**
 * Sets up event listeners for form field interactions (e.g., radio buttons, checkboxes).
 * @param {string} context - The context or module name.
 * @param {Object} config - Configuration object.
 * @returns {void}
 */
export function setupFormFieldEvents(context, { selector, eventType, handler }) {
  log(context, `Setting up form field events for selector: ${selector}`);
  registerEventListener(context, eventType, selector, async event => {
    await withErrorHandling(`${context}:formFieldEvent`, () => handler(event), ERROR_MESSAGES.EVENT_HANDLER_FAILED);
  });
}

/**
 * Initializes the event-listeners module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} EventListeners instance with public methods.
 */
export function initializeEventListenersModule(registry) {
  return createModuleInitializer('event-listeners.js', {
    setupEventListeners,
    registerEvents,
    setupFormFieldEvents,
  });
}

// Initialize module with lifecycle logging
const context = 'event-listeners.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

utils/form-rendering.js

// /static/js/utils/form-rendering.js
// Purpose: Provides utilities for rendering form elements based on configurations.

import { log } from '../core/logger.js';
import { renderMarkdown } from '../core/markdown.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from './initialization.js';
import { getFormConfig } from '../config/form-configs.js';

/**
 * Generates a style string or object for form elements.
 * @param {string} type - The type of form element (e.g., 'categories').
 * @param {Object} styles - Style properties to apply.
 * @returns {string} A CSS style string.
 */
export function renderStyles(type, styles) {
    const context = 'form-rendering.js';
    log(context, `Rendering styles for type: ${type}`);
    return Object.entries(styles)
        .map(([key, value]) => `${key.replace(/([A-Z])/g, '-$1').toLowerCase()}: ${value}`)
        .join('; ');
}

/**
 * Renders a form based on the provided configuration and either appends it to the container or returns the HTML.
 * @param {Object} formConfig - The form configuration object (must contain id, action, method, etc.).
 * @param {Object} [config={}] - Additional rendering configuration options.
 * @param {HTMLElement|null} [container=null] - The container element to render the form in. If null, returns the HTML as a string.
 * @returns {string|void} Returns the rendered form HTML as a string if container is null; otherwise, appends to the container.
 */
export function renderForm(formConfig, config = {}, container = null) {
    const context = 'form-rendering.js';
    log(context, 'Rendering form with formId:', formConfig, 'config:', config, 'container:', container);
    return withErrorHandling(`${context}:renderForm`, () => {
        // Validate formConfig
        if (!formConfig || typeof formConfig !== 'object' || !formConfig.id) {
import { withScriptLogging } from './logging-utils.js'; formConfig must be an object with an id property');
        }

        const { id = formConfig.id, action = '', method = 'POST', fields = [], customFields = [], submitButtonText = 'Submit', extraButtons = [], wrapper } = formConfig;

        // Validate fields array
        if (!Array.isArray(fields)) {
            throw new Error('Form configuration must include a fields array');
        }

        // Render form fields
        const fieldHtml = fields
            .map(field => {
                if (!field.name || !field.type) {
                    log(context, `Warning: Field missing name or type: ${JSON.stringify(field)}`);
                    return '';
                }
                let inputHtml;
                switch (field.type) {
                    case 'textarea':
                        inputHtml = `
                            <textarea id="${field.id || field.name}" name="${field.name}" ${field.required ? 'required' : ''} rows="${field.rows || 4}" cols="${field.cols || 50}" style="${field.style || ''}">${field.value || ''}</textarea>
                        `;
                        break;
                    case 'hidden':
                        inputHtml = `<input type="hidden" id="${field.id || field.name}" name="${field.name}" value="${field.value || ''}">`;
                        break;
                    default:
                        inputHtml = `
                            <input type="${field.type}" id="${field.id || field.name}" name="${field.name}" value="${field.value || ''}" ${field.required ? 'required' : ''} style="${field.style || ''}" ${field.attributes ? Object.entries(field.attributes).map(([k, v]) => `${k}="${v}"`).join(' ') : ''}>
                        `;
                }
                const extraButtonsHtml = field.extraButtons
                    ? field.extraButtons.map(btn => {
                          const btnAttributes = Object.entries(btn)
                              .filter(([key]) => key !== 'text')
                              .map(([key, value]) => `${key}="${value}"`)
                              .join(' ');
                          return `<button ${btnAttributes}>${btn.text}</button>`;
                      }).join('')
                    : '';
                const fieldWrapperStyle = field.wrapper ? `class="${field.wrapper.class || ''}" style="${field.wrapper.style || ''}"` : '';
                return `
                    <div ${fieldWrapperStyle}>
                        <label for="${field.id || field.name}">${field.label || ''}</label>
                        ${inputHtml}
                        ${extraButtonsHtml}
                    </div>
                `;
            })
            .join('');

        // Render custom fields (e.g., checkbox lists)
        const customFieldHtml = customFields
            .map(field => {
                if (field.type === 'checkboxList' && field.render) {
                    return field.render(field.items, field.selected);
                }
                return '';
            })
            .join('');

        // Render form-level buttons
        const buttonsHtml = `
            <button type="submit">${submitButtonText}</button>
            ${extraButtons.map(btn => `<button type="${btn.type || 'button'}" data-action="${btn.dataAction || ''}" style="${btn.style || ''}">${btn.text}</button>`).join('')}
        `;

        // Apply form wrapper styles
        const wrapperStyle = wrapper ? `class="${wrapper.class || ''}" style="${wrapper.style || ''}"` : '';

        // Combine HTML
        const formHtml = `
            <form id="${id}" action="${action}" method="${method}">
                <div ${wrapperStyle}>
                    ${fieldHtml}
                    ${customFieldHtml}
                    ${buttonsHtml}
                </div>
            </form>
        `;

        // If container is provided, append the form to it; otherwise, return the HTML
        if (container && container instanceof HTMLElement) {
            container.innerHTML = formHtml;
            log(context, `Form ${id} rendered successfully in container with ${fields.length} fields`);
            return;
        }

        log(context, `Form ${id} rendered as HTML string with ${fields.length} fields`);
        return formHtml;
    }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
}

/**
 * Renders markdown content into a container.
 * @param {string} context - The context or module name.
 * @param {string} markdownPath - The path to the markdown file.
 * @param {string} targetId - The ID of the container to render into.
 * @returns {Promise<void>}
 */
export async function renderMarkdownContent(context, markdownPath, targetId) {
    log(context, `Rendering markdown content into: ${targetId}`);
    await withErrorHandling(`${context}:renderMarkdownContent`, async () => {
        const htmlContent = await renderMarkdown(context, markdownPath);
        const target = document.getElementById(targetId);
        if (!target) {
            throw new Error(`Target element ${targetId} not found`);
        }
        target.innerHTML = htmlContent;
    }, ERROR_MESSAGES.MARKDOWN_RENDER_FAILED);
}

/**
 * Initializes the form-rendering module for use with the module registry.
 * @param {Map} registry - The module registry instance.
 * @returns {Object} FormRendering instance with public methods.
 */
export function initializeFormRenderingModule(registry) {
    const context = 'form-rendering.js';
    log(context, 'Initializing form-rendering module for module registry');
    return {
        renderForm: (formConfig, config, container) => renderForm(formConfig, config, container),
        renderMarkdownContent: (ctx, ...args) => renderMarkdownContent(ctx, ...args),
    };
}

/**
 * Initializes the form-rendering module.
 */
export function initializeFormRendering() {
    withScriptLogging('form-rendering.js', () => {
        log('form-rendering.js', 'Module initialized');
    });
}

utils/form-submission.js

// /static/js/utils/form-submission.js
import { log } from '../core/logger.js';
import { fetchData } from './data-fetch.js';
import { getFormConfig } from '../config/form-configs.js';
import { success, error as notifyError } from '../core/notifications.js';
import { withErrorHandling } from './error.js';
import { withScriptLogging } from './logging-utils.js';
import { withScriptLogging } from './initialization.js';

/**
 * Validates the phone number from FormData for signup forms.
 * @param {FormData} formData - The FormData object containing form fields.
 * @throws {Error} If the phone number is invalid.
 */
export function validatePhoneNumber(formData) {
  return withErrorHandling('form-submission', () => {
    log('form-submission', 'Type of formData:', formData.constructor.name);
    const phone = formData.get('signup_phone');
    log('form-submission', `Validating phone number: ${phone}`);
    if (!phone || !/^[0-9]{10,11}$/.test(phone)) {
      throw new Error('Invalid UK phone number (10 or 11 digits required)');
    }
  }, 'validatePhoneNumber');
}

/**
 * Configures a form for submission based on the provided configuration key and endpoint.
 * @param {string} context - The context or module name.
 * @param {string} formId - The ID of the form element.
 * @param {string} endpoint - The API endpoint to submit to.
 * @param {string} configKey - The form configuration key (e.g., 'login', 'signup').
 * @param {Object} [options={}] - Additional options (e.g., onSuccess, onError, successMessage).
 * @returns {void}
 */
export function submitConfiguredForm(context, formId, endpoint, configKey, options = {}) {
  log(context, `Configuring form submission for: ${formId} with config: ${configKey}`);
  withErrorHandling(`${context}:submitConfiguredForm`, () => {
    const form = document.getElementById(formId);
    if (!form) {
      log(context, `Form element ${formId} not found`);
      notifyError(context, 'Form not found. Please try again.');
      throw new Error(`Form ${formId} not found`);
    }

    const config = getFormConfig(context, configKey);
    if (!config) {
      log(context, `No form configuration found for key: ${configKey}`);
      notifyError(context, 'Invalid form configuration.');
      throw new Error(`No form configuration for key: ${configKey}`);
    }

    // Remove any existing submit listeners to prevent duplicates
    const newForm = form.cloneNode(true);
    form.parentNode.replaceChild(newForm, form);

    // Set up form submission event listener
    newForm.addEventListener('submit', async (event) => {
      event.preventDefault();
import { withScriptLogging } from './logging-utils.js';int}`);

      let formData;
      try {
        formData = new FormData(newForm);
        log(context, 'FormData initialized:', Array.from(formData.entries()));
        if (config.validate) {
          log(context, 'Running validation with FormData');
          config.validate(formData);
        }

        const transformedData = config.transform ? config.transform(formData) : Object.fromEntries(formData);
        log(context, 'Transformed data:', transformedData);
        const useAuth = config.requiresAuth !== false;

        const fetchOptions = {
          method: config.method || 'POST',
          headers: config.fetchOptions?.headers || { 'Content-Type': 'application/json' },
          body: JSON.stringify(transformedData),
          ...config.fetchOptions,
        };

        const response = await fetchData(context, endpoint, fetchOptions, useAuth);
        success(context, options.successMessage || config.successMessage || 'Form submitted successfully');
        if (options.onSuccess) {
          options.onSuccess(response);
        }
      } catch (err) {
        log(context, `Submission error: ${err.message}`);
        notifyError(context, err.message || ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
        if (options.onError && formData) {
          options.onError(err, formData);
        }
      }
    });

    log(context, `Form ${formId} submission configured`);
  }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
}

/**
 * Updates form field values dynamically.
 * @param {string} context - The context or module name.
 * @param {string} formId - The ID of the form element.
 * @param {Object} updates - Object mapping field names to values.
 * @returns {Promise<void>}
 */
export async function updateFormState(context, formId, updates) {
  log(context, `Updating form state for: ${formId}`);
  await withErrorHandling(`${context}:updateFormState`, async () => {
    const form = document.getElementById(formId);
    if (!form) {
      throw new Error(`Form ${formId} not found`);
    }
    Object.entries(updates).forEach(([name, value]) => {
      const input = form.querySelector(`[name="${name}"]`);
      if (input) {
        input.value = value;
        log(context, `Updated ${name} to: ${value}`);
      }
    });
  }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Initializes the form-submission module for use with the module registry.
 * @param {Map} registry - The module registry instance.
 * @returns {Object} FormSubmission instance with public methods.
 */
export function initializeFormSubmissionModule(registry) {
  const context = 'form-submission.js';
  log(context, 'Initializing form-submission module for module registry');
  return {
    submitConfiguredForm: (ctx, formId, endpoint, configKey, options) => submitConfiguredForm(ctx, formId, endpoint, configKey, options),
    updateFormState: (ctx, formId, updates) => updateFormState(ctx, formId, updates),
  };
}

/**
 * Initializes the form-submission module.
 */
export function initializeFormSubmission() {
  withScriptLogging('form-submission.js', () => {
    log('form-submission.js', 'Module initialized');
  });
}

utils/form-validation-utils.js

// /static/js/utils/form-validation-utils.js
// Purpose: Provides helper functions for form validation.

import { log } from '../core/logger.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from './initialization.js';

/**
 * Checks if a form field is empty.
 * @param {string} context - The context or module name.
 * @param {string} value - The field value.
 * @returns {boolean} True if the field is empty, false otherwise.
 */
export function isEmpty(context, value) {
  log(context, `Checking if value is empty: ${value}`);
  return !value || value.trim() === '';
}

/**
 * Validates an email address format.
 * @param {string} context - The context or module name.
 * @param {string} email - The email address to validate.
 * @returns {boolean} True if the email is valid, false otherwise.
 */
export function isValidEmail(context, email) {
  log(context, `Validating email: ${email}`);
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return withErrorHandling(`${context}:isValidEmail`, () => emailRegex.test(email), ERROR_MESSAGES.FORM_VALIDATION_FAILED);
}

/**
 * Initializes the form-validation-utils module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} FormValidationUtils instance with public methods.
 */
export function initializeFormValidationUtilsModule(registry) {
  const context = 'form-validation-utils.js';
  log(context, 'Initializing form-validation-utils module for module registry');
  return {
    isEmpty: (ctx, ...args) => isEmpty(ctx, ...args),
    isValidEmail: (ctx, ...args) => isValidEmail(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'form-validation-utils.js';
import { withScriptLogging } from './logging-utils.js';
  log(context, 'Module initialized');
});

utils/form-validation.js

// /static/js/utils/form-validation.js
// Purpose: Provides form validation utilities for common form fields.

import { log } from '../core/logger.js';
import { withErrorHandling } from './error.js';
import { isValidEmail } from './form-validation-utils.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from './initialization.js';

/**
 * Validates required fields in a form.
 * @param {string} context - The context or module name.
 * @param {FormData} formData - The form data.
 * @param {string[]} requiredFields - Array of required field names.
 * @returns {boolean} True if all required fields are valid, false otherwise.
 */
export function validateRequiredFields(context, formData, requiredFields) {
  log(context, `Validating required fields: ${requiredFields.join(', ')}`);
  return withErrorHandling(`${context}:validateRequiredFields`, () => {
    return requiredFields.every(field => {
      const value = formData.get(field)?.trim();
      if (!value) {
        log(context, `Required field missing: ${field}`);
        return false;
      }
      if (field.includes('email') && !isValidEmail(context, value)) {
        log(context, `Invalid email format: ${value}`);
        return false;
      }
      return true;
    });
  }, ERROR_MESSAGES.FORM_VALIDATION_FAILED);
}

/**
 * Validates password fields, ensuring they match and meet requirements.
 * @param {string} context - The context or module name.
 * @param {FormData} formData - The form data.
 * @param {string} passwordField - The name of the password field.
 * @param {string} confirmField - The name of the confirm password field.
 * @returns {boolean} True if passwords are valid and match, false otherwise.
 */
export function validatePassword(context, formData, passwordField, confirmField) {
  log(context, `Validating password fields: ${passwordField}, ${confirmField}`);
  return withErrorHandling(`${context}:validatePassword`, () => {
    const password = formData.get(passwordField);
    const confirmPassword = formData.get(confirmField);
    if (!password || !confirmPassword) {
      log(context, 'Password or confirm password missing');
      return false;
    }
    if (password !== confirmPassword) {
      log(context, 'Passwords do not match');
      return false;
    }
    if (password.length < 8) {
      log(context, 'Password must be at least 8 characters');
      return false;
    }
    return true;
  }, ERROR_MESSAGES.FORM_VALIDATION_FAILED);
}

/**
 * Validates a phone number based on signup type.
 * @param {string} context - The context or module name.
 * @param {FormData} formData - The form data.
 * @param {string} phoneField - The name of the phone field.
 * @param {string} typeField - The name of the signup type field.
 * @returns {boolean} True if the phone number is valid, false otherwise.
 */
export function validatePhoneNumber(context, formData, phoneField, typeField) {
  log(context, `Validating phone number: ${phoneField}`);
  return withErrorHandling(`${context}:validatePhoneNumber`, () => {
    const signupType = formData.get(typeField);
    const phone = formData.get(phoneField)?.trim();
    if (signupType === 'merchant' && !phone) {
      log(context, 'Phone number required for merchant signup');
      return false;
    }
    if (phone) {
      const phoneRegex = /^\+?[1-9]\d{1,14}$/;
      if (!phoneRegex.test(phone)) {
        log(context, `Invalid phone number format: ${phone}`);
        return false;
      }
    }
    return true;
  }, ERROR_MESSAGES.FORM_VALIDATION_FAILED);
}

/**
 * Validates the forgot password form.
 * @param {string} context - The context or module name.
 * @param {FormData} formData - The form data.
 * @returns {boolean} True if the form is valid, false otherwise.
 */
export function validateForgotPassword(context, formData) {
  log(context, 'Validating forgot password form');
  return validateRequiredFields(context, formData, ['email']);
}

/**
 * Validates the OTP verification form.
 * @param {string} context - The context or module name.
 * @param {FormData} formData - The form data.
 * @returns {boolean} True if the form is valid, false otherwise.
 */
export function validateVerifyOtp(context, formData) {
  log(context, 'Validating OTP verification form');
  return validateRequiredFields(context, formData, ['email', 'otp', 'new_password', 'confirm_new_password']) &&
         validatePassword(context, formData, 'new_password', 'confirm_new_password');
}

/**
 * Initializes the form-validation module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} FormValidation instance with public methods.
 */
export function initializeFormValidationModule(registry) {
  const context = 'form-validation.js';
  log(context, 'Initializing form-validation module for module registry');
  return {
    validateRequiredFields: (ctx, ...args) => validateRequiredFields(ctx, ...args),
    validatePassword: (ctx, ...args) => validatePassword(ctx, ...args),
    validatePhoneNumber: (ctx, ...args) => validatePhoneNumber(ctx, ...args),
    validateForgotPassword: (ctx, ...args) => validateForgotPassword(ctx, ...args),
    validateVerifyOtp: (ctx, ...args) => validateVerifyOtp(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'form-validation.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

utils/icons.js

// /static/js/utils/icons.js
// Purpose: Provides utilities for creating and managing icons.

import { log } from '../core/logger.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from './initialization.js';

/**
 * Creates an icon element with specified class and attributes.
 * @param {string} context - The context or module name.
 * @param {string} className - The CSS class for the icon (e.g., 'fas fa-key').
 * @param {Object} attributes - Additional data attributes for the icon.
 * @returns {HTMLElement} The icon element.
 */
export function createIcon(context, className, attributes = {}) {
  log(context, `Creating icon with class: ${className}`);
  return withErrorHandling(`${context}:createIcon`, () => {
    const icon = document.createElement('i');
    icon.className = className;
    Object.entries(attributes).forEach(([key, value]) => {
      icon.dataset[key] = value;
    });
    return icon;
  }, ERROR_MESSAGES.RENDER_FAILED('icon'));
}

/**
 * Platform-specific SVG icons for API keys.
 * @type {Object.<string, string>}
 */
export const platformIcons = {
  wix: `
    <svg class="api-icon icon-wix" viewBox="0 0 700 400">
      <path fill="currentColor" d="M393.4 131.7c0 13 2.1 32.7-28.7 43.8-9.5 3.5-16 9.7-16 9.7 0-31 4.7-42.2 17.4-48.9 9.8-5.1 27.2-4.6 27.2-4.6zm-115.8 35.5l-34.2 132.7-28.5-108.6c-7.7-32-20.8-48.5-48.4-48.5-27.4 0-40.7 16.2-48.4 48.5L89.5 299.9 55.3 167.2C49.7 140.5 23.9 129 0 132l65.6 247.9s21.6 1.6 32.5-4c14.2-7.3 21-12.8 29.6-46.6 7.7-30.1 29.1-118.4 31.1-124.7 4.8-14.9 11.1-13.8 15.4 0 2 6.3 23.5 94.6 31.1 124.7 8.6 33.7 15.4 39.3 29.6 46.6 10.8 5.5 32.5 4 32.5 4l65.6-247.9c-24.4-3.1-49.8 8.9-55.3 35.3zm115.8 5.2s-4.1 6.3-13.5 11.6c-6 3.4-11.8 5.6-18 8.6-15.1 7.3-13.2 14-13.2 35.2v152.1s16.6 2.1 27.4-3.4c13.9-7.1 17.1-14 17.3-44.8V181.4l0 0v-9zm163.4 84.1L640 132.8s-35.1-6-52.5 9.9c-13.3 12.1-24.4 29.6-54.2 72.5-.5 .7-6.3 10.5-13.1 0-29.3-42.2-40.8-60.3-54.2-72.5-17.4-15.8-52.5-9.9-52.5-9.9l83.2 123.7-83 123.4s36.6 4.6 54-11.2c11.5-10.5 17.6-20.4 52.5-70.7 6.8-10.5 12.6-.8 13.1 0 29.4 42.4 39.2 58.1 53.1 70.7 17.4 15.8 53.3 11.2 53.3 11.2L556.8 256.5z"/>
    </svg>
  `,
  shopify: `
    <svg class="api-icon icon-shopify" viewBox="0 0 448 512">
      <path fill="currentColor" d="M388.3 104.1a4.7 4.7 0 0 0 -4.4-4c-2 0-37.2-.8-37.2-.8s-21.6-20.8-29.6-28.8V503.2L442.8 472S388.7 106.5 388.3 104.1zM288.7 70.5a116.7 116.7 0 0 0 -7.2-17.6C271 32.9 255.4 22 237 22a15 15 0 0 0 -4 .4c-.4-.8-1.2-1.2-1.6-2C223.4 11.6 213 7.6 200.6 8c-24 .8-48 18-67.3 48.8-13.6 21.6-24 48.8-26.8 70.1-27.6 8.4-46.8 14.4-47.2 14.8-14 4.4-14.4 4.8-16 18-1.2 10-38 291.8-38 291.8L307.9 504V65.7a41.7 41.7 0 0 0 -4.4 .4S297.9 67.7 288.7 70.5zM233.4 87.7c-16 4.8-33.6 10.4-50.8 15.6 4.8-18.8 14.4-37.6 25.6-50 4.4-4.4 10.4-9.6 17.2-12.8C232.2 54.9 233.8 74.5 233.4 87.7zM200.6 24.4A27.5 27.5 0 0 1 215 28c-6.4 3.2-12.8 8.4-18.8 14.4-15.2 16.4-26.8 42-31.6 66.5-14.4 4.4-28.8 8.8-42 12.8C131.3 83.3 163.8 25.2 200.6 24.4zM154.2 244.6c1.6 25.6 69.3 31.2 73.3 91.7 2.8 47.6-25.2 80.1-65.7 82.5-48.8 3.2-75.7-25.6-75.7-25.6l10.4-44s26.8 20.4 48.4 18.8c14-.8 19.2-12.4 18.8-20.4-2-33.6-57.2-31.6-60.8-86.9-3.2-46.4 27.2-93.3 94.5-97.7 26-1.6 39.2 4.8 39.2 4.8L221.4 225.4s-17.2-8-37.6-6.4C154.2 221 153.8 239.8 154.2 244.6zM249.4 82.9c0-12-1.6-29.2-7.2-43.6 18.4 3.6 27.2 24 31.2 36.4Q262.6 78.7 249.4 82.9z"/>
    </svg>
  `,
  magento: `
    <svg class="api-icon icon-magento" viewBox="0 0 448 512">
      <path fill="currentColor" d="M445.7 127.9V384l-63.4 36.5V164.7L223.8 73.1 65.2 164.7l.4 255.9L2.3 384V128.1L224.2 0l221.5 127.9zM255.6 420.5L224 438.9l-31.8-18.2v-256l-63.3 36.6 .1 255.9 94.9 54.9 95.1-54.9v-256l-63.4-36.6v255.9z"/>
    </svg>
  `,
  woocommerce: `
    <svg class="api-icon icon-woocommerce" viewBox="0 0 1024 1024">
      <path fill="currentColor" d="M204.848 655.616v149.312c-1.488 21.392-10 38.432-25.648 54.064-15.6 15.648-45.456 24.16-69.616 24.16H74.032c-22.768 0-32.768-11.392-49.808-26.992C10 841.952 1.44 826.304.048 806.4h128V274.496c0-22.72 8.56-42.672 25.552-58.272 17.088-15.696 46.944-24.16 69.712-24.16h476.384c22.72 0 32.72 11.344 49.808 26.992 14.16 14.256 22.688 29.904 24.16 49.808H204.816v78.192c7.072-1.44 12.784-1.44 18.464-1.44h520.512c24.16 0 95.264 12.832 112.352 29.904 17.04 15.648 28.432 31.248 39.824 55.408L1023.92 725.36c0 22.72-9.904 42.624-27.04 58.272-17.04 15.648-26.992 22.768-49.76 22.768H223.312c-5.696 0-11.392 0-18.464-1.488v-75.376h742.304l-128-307.2-614.304.016v233.264zM614.4 76.816c0-35.552 28.48-63.984 64.032-63.984s63.984 28.432 63.984 63.984-28.432 63.984-63.984 63.984S614.4 112.368 614.4 76.816zm-511.952 0c0-35.552 28.432-63.984 63.984-63.984s63.984 28.432 63.984 63.984-28.432 63.984-63.984 63.984-63.984-28.432-63.984-63.984z"/>
    </svg>
  `,
  bigcommerce: `
    <svg class="api-icon icon-bigcommerce" viewBox="0 0 60 60">
      <path fill="currentColor" d="M33.72 36.432h8.073c2.296 0 3.75-1.263 3.75-3.3 0-1.913-1.454-3.3-3.75-3.3H33.72c-.268 0-.497.23-.497.46v5.663c.038.268.23.46.497.46zm0 13.048h8.34c2.564 0 4.094-1.3 4.094-3.597 0-2-1.454-3.597-4.094-3.597h-8.34c-.268 0-.497.23-.497.46v6.237c.038.306.23.497.497.497zM63.257.16l-23.875 23.8h3.903c6.084 0 9.68 3.826 9.68 7.997 0 3.3-2.22 5.7-4.6 6.772-.383.153-.383.7.038.842 2.755 1.07 4.706 3.94 4.706 7.308 0 4.744-3.176 8.532-9.336 8.532H26.87c-.268 0-.497-.23-.497-.46V36.93L.164 63.023c-.344.344-.115.957.383.957h63.016c.23 0 .42-.2 .42-.42V.505c.115-.42-.42-.65-.727-.344z"/>
    </svg>
  `,
  squarespace: `
    <svg class="api-icon icon-squarespace" viewBox="0 0 512 512">
      <path fill="currentColor" d="M186.5 235.8c-24.7-24.7-64.8-24.7-89.5 0L73.2 259.5c-24.7 24.7-24.7 64.8 0 89.5l23.8 23.8c24.7 24.7 64.8 24.7 89.5 0l23.8-23.8c24.7-24.7 24.7-64.8 0-89.5l-23.8-23.7zm66.1-66.1c24.7 24.7 64.8 24.7 89.5 0l23.8-23.8c24.7-24.7 24.7-64.8 0-89.5l-23.8-23.8c-24.7-24.7-64.8-24.7-89.5 0L188.8 56.5c-24.7 24.7-24.7 64.8 0 89.5l23.8 23.7zm66.1 66.1c-24.7-24.7-64.8-24.7-89.5 0l-23.8 23.8c-24.7 24.7-24.7 64.8 0 89.5l23.8 23.8c24.7 24.7 64.8 24.7 89.5 0l23.8-23.8c24.7-24.7 24.7-64.8 0-89.5l-23.8-23.8zm66.1 66.1c24.7 24.7 64.8 24.7 89.5 0l23.8-23.8c24.7-24.7 24.7-64.8 0-89.5l-23.8-23.8c-24.7-24.7-64.8-24.7-89.5 0l-23.8 23.8c-24.7 24.7-24.7 64.8 0 89.5l23.8 23.8z"/>
    </svg>
  `,
  weebly: `
    <svg class="api-icon icon-weebly" viewBox="0 0 448 512">
      <path fill="currentColor" d="M435.8 123.5c-8.6-12.2-21.8-19.8-37-21.8-17.8-2.3-35.8 2.3-50 13-14.2-10.8-32.2-15.4-50-13-15.2 2-28.4 9.6-37 21.8-8.8 12.5-11 28-6 42.2 8 22.8 28.4 38 55 40 2 .2 4 .2 6 0 26.6-2 47-17.2 55-40 5-14.2 2.8-29.8-6-42.2zM256 235.8c-26.6-2-47-17.2-55-40-5-14.2-2.8-29.8 6-42.2 8.6-12.2 21.8-19.8 37-21.8 17.8-2.3 35.8 2.3 50 13 14.2-10.8 32.2-15.4 50-13 15.2 2 28.4 9.6 37 21.8 8.8 12.5 11 28 6 42.2-8 22.8-28.4 38-55 40-2 .2-4 .2-6 0-26.6-2-47-17.2-55-40zm-163.8 0c-26.6-2-47-17.2-55-40-5-14.2-2.8-29.8 6-42.2 8.6-12.2 21.8-19.8 37-21.8 17.8-2.3 35.8 2.3 50 13 14.2-10.8 32.2-15.4 50-13 15.2 2 28.4 9.6 37 21.8 8.8 12.5 11 28 6 42.2-8 22.8-28.4 38-55 40-2 .2-4 .2-6 0-26.6-2-47-17.2-55-40zm-12 97l47 179h40l-47-179H80zm163.8 0l47 179h40l-47-179h-40zm163.8 0l47 179h40l-47-179h-40z"/>
    </svg>
  `,
  joomla: `
    <svg class="api-icon icon-joomla" viewBox="0 0 448 512">
      <path fill="currentColor" d="M243.3 154.8c-10.5-10.5-27.6-10.5-38.1 0l-19 19-95.2-95.2c28-34.2 67-57 110.9-65.5C141.2 56.9 98.8 112.8 98.8 176c0 19.7 4.9 38.3 13.5 54.6l-90 90c-15.5-27-24.3-58.5-24.3-92 0-106 86-192 192-192 33.5 0 65 8.6 92 23.7l-30.7 30.7zm-41.4 83.5c10.5 10.5 27.6 10.5 38.1 0l19-19 95.2 95.2c-28 34.2-67 57-110.9 65.5 60.8-43.8 103.2-99.7 103.2-163 0-19.7-4.9-38.3-13.5-54.6l90-90c15.5 27 24.3 58.5 24.3 92 0 106-86 192-192 192-33.5 0-65-8.6-92-23.7l30.7-30.7zm-19-133.6l-30.7-30.7C125 58.9 93.5 50.3 60 50.3c-33.5 0-65 8.6-92 23.7l90 90c-8.6-16.3-13.5-34.9-13.5-54.6 0-63.2 42.4-119.1 103.2-163-43.9 8.5-82.9 31.3-110.9 65.5l95.2 95.2 19-19c10.5-10.5 10.5-27.6 0-38.1zm133.6 209.1l30.7 30.7c27-15.1 58.5-23.7 92-23.7 106 0 192-86 192-192 0-33.5-8.6-65-23.7-92l-90 90c8.6 16.3 13.5 34.9 13.5 54.6 0 63.2-42.4 119.1-103.2 163 43.9-8.5 82.9-31.3 110.9-65.5l-95.2-95.2-19 19c-10.5 10.5-10.5 27.6 0 38.1z"/>
    </svg>
  `,
  wordpress: `
    <svg class="api-icon icon-wordpress" viewBox="0 0 512 512">
      <path fill="currentColor" d="M61.7 169.6l-49.7 185.5c42.3 76.8 119.2 129.9 208.8 129.9 26.5 0 52.1-5 76-14.1L314 448l30.8-102.8 22-74.4-59-165.5c-24.7-5-50.8-7.6-77.8-7.6-42.8 0-82.8 11.7-116.3 32zm428.9 36.4C476 127.5 413.9 70.5 336 61.7L246.5 288l70.2 66.1zm-88.1-98.9c16.8 2.3 33 7.6 48 15.8 11.4 6.3 21.8 14.5 30.8 24.2 6.5 7 12 14.8 16.4 23.2 15.2 29.7 23.2 61.9 23.2 94.8 0 46-18.8 87.8-50 117-2.8-66-27-126-67.8-171.8zm-149.3 47.5c25.5 0 46 19 46 42.5s-20.5 42.5-46 42.5-46-19-46-42.5 20.5-42.5 46-42.5zm149.2 187.9l-33.8-100-42.5-112.9c-16.8-2-33.8-2.8-51-2.8-52.2 0-100.5 16.5-139.5 44.5l52.2 154.9c42-27.2 92.2-42.8 141.5-42.8 24.2 0 47.8 3.8 73.2 11.2zm-196-94.9c-25.5 0-46-19-46-42.5s20.5-42.5 46-42.5 46 19 46 42.5-20.5 42.5-46 42.5zm-90.5-42.5c0-23.5 20.5-42.5 46-42.5s46 19 46 42.5-20.5 42.5-46 42.5-46-19-46-42.5zm-61.8-85.8C36.2 165 0 223 0 288c0 141.4 114.6 256 256 256 90.8 0 171-47.5 216.5-119.5-45-15-93-23.5-142.5-23.5-66.5 0-129.2 21-181.2 59.8L112 344.5l13.8-51.5L209 64C148.2 64 94 99.8 61.7 149.8z"/>
    </svg>
  `,
};

/**
 * Initializes the icons module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Icons instance with public methods.
 */
export function initializeIconsModule(registry) {
  const context = 'icons.js';
  log(context, 'Initializing icons module for module registry');
  return {
    createIcon: (ctx, ...args) => createIcon(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'icons.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

utils/initialization.js

// /static/js/utils/initialization.js
// Purpose: Provides utilities for module initialization, page setup, and navigation.

import { log } from '../core/logger.js';
import { withAuthenticatedUser } from '../core/auth.js'; // Updated import to core/auth.js
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/messages.js'; // Updated import to messages.js
import { defineSectionHandlers } from '../modules/navigation.js';
import { withScriptLogging } from './logging-utils.js'; // Changed from re-export to direct import

const context = 'initialization.js';

/**
 * Shows the specified section and hides others.
 * @param {string} sectionId - The ID of the section to show.
 */
async function showSection(sectionId) {
    const sections = document.querySelectorAll('.section');
    sections.forEach(section => {
        if (section.id === sectionId) {
            section.style.display = 'block';
        } else {
            section.style.display = 'none';
        }
    });
}

/**
 * Creates a module initializer for the registry with standardized method wrapping.
 * @param {string} context - The context or module name.
 * @param {Object} methods - Object mapping method names to functions.
 * @returns {Object} Module instance with wrapped methods.
 */
export function createModuleInitializer(context, methods) {
    log(context, `Initializing ${context} module for module registry`);
    return Object.keys(methods).reduce((acc, key) => {
        acc[key] = (ctx, ...args) => methods[key](ctx, ...args);
        return acc;
    }, {});
}

/**
 * Parses the page type from a query parameter or defaults to a provided value.
 * @param {string} context - The context or module name.
 * @param {string} param - The query parameter name.
 * @param {string} defaultType - The default page type.
 * @returns {string} The parsed page type.
 */
export function parsePageType(context, param, defaultType) {
    log(context, `Parsing page type from param: ${param}`);
    return withErrorHandling(`${context}:parsePageType`, () => {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(param) || defaultType;
    }, ERROR_MESSAGES.DEFAULT, () => defaultType);
}

/**
 * Initializes role-based navigation for a page.
 * @param {string} context - The context or module name.
 * @param {string} role - The role associated with the page (e.g., 'admin', 'login').
 * @param {string} defaultSection - The default section to show.
 * @returns {Promise<void>}
 */
export async function initializeRoleNavigation(context, role, defaultSection) {
    log(context, `Initializing navigation for role: ${role}, default section: ${defaultSection}`);
    await withErrorHandling(`${context}:initializeRoleNavigation`, async () => {
        let sectionHandlers = {};
        if (role === 'login') {
            sectionHandlers = defineSectionHandlers(context, 'login', [
                {
                    id: 'info',
import { withScriptLogging } from './logging-utils.js';
                        log(context, 'Showing info section');
                        showSection('info');
                    },
                },
                {
                    id: 'signup',
                    handler: () => {
                        log(context, 'Showing signup section');
                        showSection('signupContainer');
                    },
                },
                {
                    id: 'forgot-password',
                    handler: () => {
                        log(context, 'Showing forgot-password section');
                        showSection('forgotPasswordContainer');
                    },
                },
            ]);
        }
        const navElement = document.querySelector(`nav[data-role="${role}"]`);
        if (!navElement) {
            log(context, `Navigation element not found for role: ${role}`);
            return;
        }
        const sectionLink = navElement.querySelector(`[data-section="${defaultSection}"]`) || 
                           document.querySelector(`.section-link[data-section="${defaultSection}"]`);
        if (sectionLink) {
            sectionLink.click();
        } else {
            log(context, `Section link not found for default section: ${defaultSection}`);
        }
    }, ERROR_MESSAGES.NAVIGATION_INIT_FAILED);
}

/**
 * Initializes a role-based page with authentication, navigation, and custom setup.
 * @param {string} context - The context or module name.
 * @param {string} role - The role associated with the page (e.g., 'admin', 'merchant').
 * @param {string} pageType - The type of page to initialize (e.g., 'products', 'integrations').
 * @param {Function} callback - The callback to execute for role-specific setup.
import { withScriptLogging } from './logging-utils.js';
 */
export async function initializeRolePage(context, role, pageType, callback) {
    log(context, `Initializing ${role} page with type: ${pageType}`);
    if (role === 'login') {
        // Login page does not require authentication
        await withErrorHandling(`${context}:initializeRolePage`, async () => {
            const userIdInput = document.getElementById('userId');
            if (userIdInput) userIdInput.value = localStorage.getItem('userId') || '';
            await callback();
        }, ERROR_MESSAGES.MODULE_INIT_FAILED);
    } else {
        await withAuthenticatedUser(context, async () => {
            await withErrorHandling(`${context}:initializeRolePage`, async () => {
                const userIdInput = document.getElementById('userId');
                if (userIdInput) userIdInput.value = localStorage.getItem('userId') || '';
                await callback();
            }, ERROR_MESSAGES.MODULE_INIT_FAILED);
        }, 'initializeRolePage');
    }
}

/**
 * Initializes the initialization module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Initialization instance with public methods.
 */
export function initializeInitializationModule(registry) {
    return createModuleInitializer('initialization.js', {
        withScriptLogging,
        createModuleInitializer,
        parsePageType,
        initializeRoleNavigation,
        initializeRolePage,
    });
}

/**
 * Hides the loading overlay and shows the layout wrapper.
 */
export function hideOverlay() {
    const loadingOverlay = document.getElementById('loadingOverlay');
    const layoutWrapper = document.querySelector('.layout-wrapper');
    if (loadingOverlay && layoutWrapper) {
        loadingOverlay.style.display = 'none';
        layoutWrapper.style.display = '';
    }
}

// Global event listener for the button in roles.inc
document.addEventListener('click', (event) => {
    const infoButton = event.target.closest('button[data-section="info"]');
    if (infoButton) {
        console.log('Info button clicked');
        showSection('info');
    }
});

// Initialize module with lifecycle logging
withScriptLogging(context, () => {
import { withScriptLogging } from './logging-utils.js';
});

utils/logging-utils.js

// /static/js/utils/logging-utils.js
// Purpose: Provides logging utilities for script lifecycle management.

import { log } from '../core/logger.js';

/**
 * Wraps a module initialization function with lifecycle logging.
 * @param {string} context - The context or module name.
 * @param {Function} initFn - The initialization function to wrap.
 * @returns {void}
 */
export function withScriptLogging(context, initFn) {
  log(context, 'Starting module initialization');
  try {
    const result = initFn();
    log(context, 'Module initialization completed');
    return result;
  } catch (error) {
    log(context, `Module initialization failed: ${error.message}`);
    throw error;
  }
}

/**
 * Initializes the logging-utils module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} LoggingUtils instance with public methods.
 */
export function initializeLoggingUtilsModule(registry) {
  log('logging-utils.js', 'Initializing logging-utils module for module registry');
  return {
    withScriptLogging,
  };
}

// Initialize module with lifecycle logging
const context = 'logging-utils.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

utils/settings-data.js

// /static/js/utils/settings-data.js
// Purpose: Provides utilities for fetching settings data.

import { log } from '../core/logger.js';
import { fetchData } from './data-fetch.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from './initialization.js';

/**
 * Loads settings data from the specified endpoint.
 * @param {string} context - The context or module name.
 * @param {string} endpoint - The API endpoint to fetch settings from.
 * @returns {Promise<Array>} The fetched settings data.
 */
import { withScriptLogging } from './logging-utils.js';
  log(context, `Loading settings from endpoint: ${endpoint}`);
  return await withErrorHandling(`${context}:loadSettings`, async () => {
    const data = await fetchData(context, endpoint);
    return data.settings || [];
  }, ERROR_MESSAGES.FETCH_FAILED('settings'), () => []);
}

/**
 * Initializes the settings-data module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} SettingsData instance with public methods.
 */
export function initializeSettingsDataModule(registry) {
  const context = 'settings-data.js';
  log(context, 'Initializing settings-data module for module registry');
  return {
    loadSettings: (ctx, ...args) => loadSettings(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'settings-data.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

utils/settings-events.js

// /static/js/utils/settings-events.js
// Purpose: Provides utilities for setting up settings-related event listeners.

import { log } from '../core/logger.js';
import { setupEventListeners } from './event-listeners.js';
import { fetchData } from './data-fetch.js';
import { success } from '../core/notifications.js';
import { withScriptLogging } from './initialization.js';

/**
 * Sets up event listeners for settings form submissions.
 * @param {string} context - The context or module name.
 * @param {string} formId - The ID of the form.
 * @param {string} endpoint - The API endpoint for submission.
 * @param {string} settingType - The type of setting (e.g., 'api', 'affiliate').
 * @returns {void}
 */
export function setupSettingsEvents(context, formId, endpoint, settingType) {
  log(context, `Setting up settings events for form: ${formId}`);
  setupEventListeners(context, [
    {
      eventType: 'submit',
      selector: `#${formId}`,
      handler: async e => {
        e.preventDefault();
        const fields = {};
        Array.from(e.target.querySelectorAll('input')).forEach(input => {
          fields[input.name] = input.value;
        });
        await fetchData(context, `${endpoint}/${settingType}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(fields),
        });
        success(context, `Settings for ${settingType} updated successfully`);
      },
import { withScriptLogging } from './logging-utils.js';
  ]);
}

/**
 * Initializes the settings-events module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} SettingsEvents instance with public methods.
 */
export function initializeSettingsEventsModule(registry) {
  const context = 'settings-events.js';
  log(context, 'Initializing settings-events module for module registry');
  return {
    setupSettingsEvents: (ctx, ...args) => setupSettingsEvents(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'settings-events.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

utils/settings-renderer.js

// /static/js/utils/settings-renderer.js
// Purpose: Provides utilities for rendering settings UI components.

import { log } from '../core/logger.js';
import { renderSettingsFields } from './settings-ui.js';
import { setupSettingsEvents } from './settings-events.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from './initialization.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Renders a settings form based on the provided configuration.
 * @param {string} context - The context or module name.
 * @param {Object} config - Settings configuration object.
 * @returns {Promise<void>}
 */
export async function renderSettingsForm(context, config) {
  log(context, `Rendering settings form for type: ${config.type}`);
  await withErrorHandling(`${context}:renderSettingsForm`, async () => {
    await renderSettingsFields(context, config.settings || [], {
      containerId: config.containerId,
      formId: config.formId,
      fieldsId: config.fieldsId,
      type: config.type,
      iconClass: config.iconClass,
      onIconClick: config.onIconClick,
      onReadmeClick: config.onReadmeClick,
    });
    setupSettingsEvents(context, config.formId, config.endpoint || '/settings', config.type);
  }, ERROR_MESSAGES.RENDER_FAILED('settings form'));
}

/**
 * Renders settings based on the provided configuration (legacy, prefer renderSettingsForm).
 * @param {string} context - The context or module name.
 * @param {Object} config - Settings configuration object.
 * @returns {Promise<void>}
 */
export async function renderSettings(context, config) {
  log(context, `Rendering settings for type: ${config.type} (legacy)`);
  await renderSettingsForm(context, config);
}

/**
 * Initializes the settings-renderer module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} SettingsRenderer instance with public methods.
 */
export function initializeSettingsRendererModule(registry) {
  return createModuleInitializer('settings-renderer.js', {
    renderSettings,
    renderSettingsForm,
  });
}

// Initialize module with lifecycle logging
const context = 'settings-renderer.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

utils/settings-ui.js

// /static/js/utils/settings-ui.js
// Purpose: Provides low-level utilities for rendering settings fields and UI components.

import { log } from '../core/logger.js';
import { createLinkIcons } from './ui-components.js';
import { setupSettingsEvents } from './settings-events.js';
import { withElement } from './dom-manipulation.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from './initialization.js';

/**
 * Renders settings fields based on the provided settings and configuration.
 * @param {string} context - The context or module name.
 * @param {Array} settings - Array of settings data.
 * @param {Object} config - Configuration object for rendering.
 * @returns {Promise<void>}
 */
export async function renderSettingsFields(context, settings, config) {
  log(context, `Rendering settings fields for type: ${config.type}`);
  await withErrorHandling(`${context}:renderSettingsFields`, async () => {
    await withElement(context, config.containerId, async container => {
      await withElement(context, config.fieldsId, async fieldsContainer => {
        await withElement(context, config.formId, async form => {
          container.innerHTML = '';
          fieldsContainer.innerHTML = '';
          const linkIcons = createLinkIcons(context, settings, config.type, config.onReadmeClick, config.onIconClick);
          container.append(...linkIcons);
          if (settings.length > 0) {
            fieldsContainer.innerHTML = settings[0].fields
              .map(field => `
                <div>
                  <label for="${field.name}">${field.label || field.name}</label>
                  <input type="${field.type || 'text'}" name="${field.name}" value="${field.value || ''}">
                </div>
              `)
              .join('');
            if (config.onIconClick) {
              config.onIconClick(settings[0], fieldsContainer, form);
            }
          }
          setupSettingsEvents(context, config.formId, config.endpoint || '/settings', config.type);
        });
      });
    });
  }, ERROR_MESSAGES.RENDER_FAILED('settings fields'));
}

/**
 * Initializes the settings-ui module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} SettingsUi instance with public methods.
 */
export function initializeSettingsUiModule(registry) {
  const context = 'settings-ui.js';
  log(context, 'Initializing settings-ui module for module registry');
  return {
    renderSettingsFields: (ctx, ...args) => renderSettingsFields(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'settings-ui.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});

utils/ui-components.js

// /static/js/utils/ui-components.js
// Purpose: Provides utilities for rendering reusable UI components.

import { log } from '../core/logger.js';
import { createIcon } from './icons.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from './initialization.js';

/**
 * Renders a data table based on the provided configuration.
 * @param {string} context - The context or module name.
 * @param {Object} config - Table configuration object.
 * @returns {string} The rendered HTML table.
 */
export function renderDataTable(context, { data = [], headers = [], rowMapper, emptyMessage }) {
  log(context, 'Rendering data table');
  return withErrorHandling(`${context}:renderDataTable`, () => {
    if (!data.length) {
      return `<p>${emptyMessage || 'No data available'}</p>`;
    }
    const headerHtml = headers.map(header => `<th>${header}</th>`).join('');
    const rowsHtml = data.map(item => `<tr>${rowMapper(item).map(cell => `<td>${cell}</td>`).join('')}</tr>`).join('');
    return `
      <table>
        <thead><tr>${headerHtml}</tr></thead>
        <tbody>${rowsHtml}</tbody>
      </table>
    `;
  }, ERROR_MESSAGES.RENDER_FAILED('data table'));
}

/**
 * Renders a checkbox list based on the provided configuration.
 * @param {string} context - The context or module name.
 * @param {Object} config - Checkbox list configuration object.
 * @returns {HTMLElement} The rendered checkbox list container.
 */
export function renderCheckboxList(context, { items = [], name, selected = [], dataAttributes = {}, containerClass = '' }) {
  log(context, `Rendering checkbox list for: ${name}`);
  return withErrorHandling(`${context}:renderCheckboxList`, () => {
    const container = document.createElement('div');
    if (containerClass) {
      container.className = containerClass;
    }
    items.forEach(item => {
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.name = name;
      checkbox.value = item.value;
      checkbox.checked = selected.includes(item.value);
      Object.entries(dataAttributes).forEach(([key, value]) => {
        checkbox.dataset[key] = value;
      });

      const label = document.createElement('label');
      label.textContent = item.label;
      label.prepend(checkbox);

      container.appendChild(label);
    });
    return container;
  }, ERROR_MESSAGES.RENDER_FAILED('checkbox list'));
}

/**
 * Renders a modal based on the provided configuration.
 * @param {string} context - The context or module name.
 * @param {Object} config - Modal configuration object.
 * @returns {Promise<HTMLElement>} The rendered modal element.
 */
export async function renderModal(context, { id, title, content, formId, buttons = [] }) {
  log(context, `Rendering modal: ${id}`);
  return await withErrorHandling(`${context}:renderModal`, async () => {
    const modal = document.createElement('div');
    modal.id = id;
    modal.className = 'modal';
    modal.innerHTML = `
      <div class="modal-content">
        <h2>${title}</h2>
        <form id="${formId}">
          ${typeof content === 'string' ? content : content.outerHTML}
          <div class="modal-buttons">
            ${buttons.map(btn => `<button type="${btn.type}" class="${btn.className || ''}" ${btn.onclick ? `onclick="${btn.onclick}"` : ''}>${btn.text}</button>`).join('')}
          </div>
        </form>
      </div>
    `;
    document.body.appendChild(modal);
    return modal;
  }, ERROR_MESSAGES.RENDER_FAILED('modal'));
}

/**
 * Creates link icons for settings or navigation.
 * @param {string} context - The context or module name.
 * @param {Array} links - Array of link objects with keyType and docLink.
 * @param {string} type - The type of links (e.g., 'api', 'affiliate').
 * @param {Function} onReadmeClick - Callback for readme link clicks.
 * @param {Function} onIconClick - Callback for icon clicks.
 * @returns {HTMLElement[]} Array of icon elements.
 */
export function createLinkIcons(context, links, type, onReadmeClick, onIconClick) {
  log(context, `Creating link icons for type: ${type}`);
  return withErrorHandling(`${context}:createLinkIcons`, () => {
    const icons = [];
    links.forEach(link => {
      const icon = createIcon(context, `fas fa-${type}`, { 'data-key-type': link.keyType });
      icon.addEventListener('click', () => onIconClick?.(link));
      icons.push(icon);

      const readmeLink = link.docLink?.find(l => l.title === 'readme');
      if (readmeLink) {
        const readmeIcon = createIcon(context, 'fas fa-book', { 'data-key-type': link.keyType });
        readmeIcon.addEventListener('click', () => onReadmeClick?.(link));
        icons.push(readmeIcon);
      }
    });
    return icons;
  }, ERROR_MESSAGES.RENDER_FAILED('link icons'));
}

/**
 * Initializes the ui-components module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} UiComponents instance with public methods.
 */
export function initializeUiComponentsModule(registry) {
  const context = 'ui-components.js';
  log(context, 'Initializing ui-components module for module registry');
  return {
    renderDataTable: (ctx, ...args) => renderDataTable(ctx, ...args),
    renderCheckboxList: (ctx, ...args) => renderCheckboxList(ctx, ...args),
    renderModal: (ctx, ...args) => renderModal(ctx, ...args),
    createLinkIcons: (ctx, ...args) => createLinkIcons(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'ui-components.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});


+ [js]
+----[admin]
+------admin-events.js
+------affiliates.js
+------api-keys.js
+------deals-orchestrator.js
+------deals.js
+------initializer.js
+------logs-ui.js
+------navigation.js
+------referral-test.js
+------settings-orchestrator.js
+------settings.js
+------site-requests.js
+------site-settings.js
+------users-data.js
+------users-orchestrator.js
+------users-ui.js
+----admin-page.js
+----[community]
+------categories-data.js
+------categories-events.js
+------categories-navigation.js
+------categories-page.js
+------categories-ui.js
+------community-providers.js
+------navigation.js
+------providers-data.js
+------providers-events.js
+------providers-handlers.js
+------providers-page.js
+------providers.js
+------referrals-data.js
+------referrals-page.js
+------referrals-ui.js
+------settings-renderer.js
+------setup.js
+----community-page.js
+----[config]
+------constants.js
+------endpoints.js
+------form-configs.js
+------menus.js
+------messages.js
+------pages.js
+------roles.js
+------settings.js
+----[core]
+------auth.js
+------cookies.js
+------logger.js
+------markdown.js
+------mce.js
+------notifications.js
+------user.js
+----[login]
+------forgot-password.js
+------login.js
+------set-password.js
+------signup.js
+----login-page.js
+----main.js
+----[merchant]
+------api-keys-events.js
+------api-keys.js
+------documentation.js
+------navigation.js
+------products.js
+------referrals-data.js
+------referrals-page.js
+------referrals-ui.js
+------setup.js
+------user-settings.js
+----merchant-page.js
+----[modules]
+------dataLoader.js
+------navigation.js
+------pageSetup.js
+------site-request.js
+------userSettings.js
+----[partner]
+------initializer.js
+------integrations-data.js
+------integrations-ui.js
+------integrations.js
+------navigation.js
+------partner-events.js
+----partner-page.js
+----[utils]
+------data-fetch.js
+------dom-events.js
+------dom-manipulation.js
+------error.js
+------event-listeners.js
+------form-rendering.js
+------form-submission.js
+------form-validation-utils.js
+------form-validation.js
+------icons.js
+------initialization.js
+------logging-utils.js
+------settings-data.js
+------settings-events.js
+------settings-renderer.js
+------settings-ui.js
+------ui-components.js

admin/admin-events.js
// /static/js/admin/admin-events.js
import { log } from '../core/logger.js';
import { registerEvents } from '../utils/event-listeners.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { parsePageType, shouldInitializeForPageType } from '../utils/initialization.js';
import { createModuleInitializer } from '../utils/initialization.js';

const context = 'admin-events.js';

export async function setupAdminEvents(context) {
    const pageType = await parsePageType(context, 'page', 'admin');
    if (pageType !== 'admin') {
        log(context, `Skipping initialization for non-admin page type: ${pageType}`);
        return;
    }
    log(context, 'Setting up admin event listeners');
    await withErrorHandling(`${context}:setupAdminEvents`, () => {
        registerEvents(context, [
            'formSubmit',
            'navigationToggle',
            'permissionChange',
            'modifyPermissions',
        ], {
            formId: 'settingsForm',
            endpoint: '/settings/user',
            configKey: 'userSettings',
            navToggleId: 'adminNavToggle',
            navId: 'adminNav',
        });
    }, ERROR_MESSAGES.EVENT_HANDLER_FAILED);
}

export function initializeAdminEventsModule(registry) {
    return createModuleInitializer(context, {
        setupAdminEvents,
    });
}

if (shouldInitializeForPageType('admin')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
} else {
    log(context, 'Skipping initialization for non-admin page');
}
admin/affiliates.js
// /static/js/admin/affiliates.js
import { log, warn } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { createIcon } from '../utils/icons.js';
import { setupEventListeners } from '../utils/event-listeners.js';
import { toggleViewState, withElement } from '../utils/dom-manipulation.js';
import { error, success } from '../core/notifications.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { parsePageType, shouldInitializeForPageType } from '../utils/initialization.js';
import { createModuleInitializer } from '../utils/initialization.js';
import { renderMarkdown } from '../core/markdown.js'; // Added import for markdown rendering

const context = 'affiliates.js';

export async function loadAffiliates(context) {
    const pageType = await parsePageType(context, 'page', 'admin');
    if (pageType !== 'admin') {
        log(context, `Skipping initialization for non-admin page type: ${pageType}`);
        return;
    }
    log(context, 'Loading affiliate programs');
    await withErrorHandling(`${context}:loadAffiliates`, async () => {
        const data = await fetchData(context, API_ENDPOINTS.SETTINGS_AFFILIATE_KEY);
        log(context, `API response for ${API_ENDPOINTS.SETTINGS_AFFILIATE_KEY}:`, data);
        if (!data.settings || !Array.isArray(data.settings) || data.settings.length === 0) {
            warn(context, 'Invalid or empty affiliate programs data');
            error(context, 'No affiliate programs available');
            return;
        }
        await renderAffiliateIcons(context, data.settings);
        await renderAffiliateFields(context, data.settings[0]);
        toggleViewState(context, { affiliates: true });
    }, ERROR_MESSAGES.FETCH_FAILED('affiliate programs'));
}

async function renderAffiliateIcons(context, settings) {
    log(context, 'Rendering affiliate icons');
    await withElement(context, 'affiliate-icons', async (container) => {
        container.innerHTML = '';
        for (const [index, setting] of settings.entries()) {
            const iconClass = setting.icon || 'fas fa-link';
            const icon = await createIcon(context, iconClass, { 'data-key-type': setting.key_type });
            icon.classList.add('affiliate-icon');
            if (index === 0) icon.classList.add('selected');
            Object.assign(icon.style, {
                width: '24px',
                height: '24px',
                display: 'inline-block',
                margin: '5px',
                cursor: 'pointer'
            });
            icon.addEventListener('click', async () => {
                log(context, `Icon clicked for ${setting.key_type}`);
                container.querySelectorAll('.affiliate-icon').forEach(i => i.classList.remove('selected'));
                icon.classList.add('selected');
                await renderAffiliateFields(context, setting);
            });
            container.appendChild(icon);
        }
    });
}

async function renderAffiliateFields(context, setting) {
    log(context, `Rendering fields for affiliate: ${setting.key_type}`);
    const staticContainer = document.getElementById('affiliate-static-content');
    const formContainer = document.getElementById('affiliate-settings-container');
    const readmeContainer = document.getElementById('affiliate-readme-content');

    if (!staticContainer || !formContainer || !readmeContainer) {
        warn(context, 'Missing required DOM elements for affiliate details');
        error(context, 'Missing required DOM elements for affiliate details');
        return;
    }

    staticContainer.innerHTML = '';
    const header = document.createElement('div');
    header.id = 'affiliate-header';
    header.style.display = 'flex';
    header.style.alignItems = 'center';
    header.style.marginBottom = '15px';

    const icon = document.createElement('i');
    icon.className = `selected-affiliate-icon ${setting.icon || 'fas fa-link'}`;
    icon.style.fontSize = '16px';
    icon.style.color = 'currentColor';
    icon.style.marginRight = '10px';
    header.appendChild(icon);

    const title = document.createElement('h3');
    title.className = 'affiliate-comment-heading';
    title.style.display = 'inline-block';
    title.style.verticalAlign = 'middle';
    title.style.margin = '0';
    title.textContent = setting.comment || `${setting.key_type} Settings`;
    header.appendChild(title);

    const linksContainer = document.createElement('div');
    linksContainer.style.marginLeft = 'auto';
    linksContainer.style.display = 'flex';
    linksContainer.style.gap = '10px';

    if (Array.isArray(setting.doc_link) && setting.doc_link.length > 0) {
        setting.doc_link.forEach(doc => {
            const linkElement = document.createElement('a');
            linkElement.className = `affiliate-${doc.title}-link`;
            linkElement.style.color = 'currentColor';
            linkElement.innerHTML = `<i class="fas fa-${doc.title === 'api' ? 'link' : doc.title === 'signup' ? 'user-plus' : 'book'}" style="font-size: 16px;"></i>`;
            linkElement.href = doc.link;
            linkElement.style.display = 'inline-block';
            linkElement.target = '_blank';
            linkElement.title = doc.title.charAt(0).toUpperCase() + doc.title.slice(1);
            linksContainer.appendChild(linkElement);
        });
    } else {
        log(context, 'No doc_link array found, skipping links rendering');
    }

    header.appendChild(linksContainer);
    staticContainer.appendChild(header);

    const descriptionText = setting._description || setting.description || 'Use this section to manage your affiliate program credentials.';
    const description = document.createElement('p');
    description.className = 'affiliate-description';
    description.style.marginBottom = '15px';
    description.textContent = descriptionText;
    staticContainer.appendChild(description);

    const readmeLinkObj = setting.doc_link ? setting.doc_link.find(link => link.title === 'readme') : null;
    if (readmeLinkObj) {
        const mdLinkElement = staticContainer.querySelector('.affiliate-readme-link');
        if (mdLinkElement) {
            const keysLinkElement = document.createElement('a');
            keysLinkElement.className = 'affiliate-keys-link';
            keysLinkElement.style.color = 'currentColor';
            keysLinkElement.innerHTML = '<i class="fas fa-key" style="font-size: 16px;"></i>';
            keysLinkElement.style.display = 'none';
            keysLinkElement.title = 'Back to Keys';
            linksContainer.appendChild(keysLinkElement);

            mdLinkElement.addEventListener('click', async (e) => {
                e.preventDefault();
                try {
                    const markdown = await renderMarkdown(context, readmeLinkObj.link);
                    readmeContainer.innerHTML = markdown;
                    formContainer.style.display = 'none';
                    readmeContainer.style.display = 'block';
                    mdLinkElement.style.display = 'none';
                    keysLinkElement.style.display = 'inline-block';
                    log(context, `Readme loaded for ${setting.key_type}`);
                } catch (err) {
                    error(context, 'Failed to load readme');
                    log(context, `Error loading readme: ${err.message}`);
                }
            });

            keysLinkElement.addEventListener('click', (e) => {
                e.preventDefault();
                formContainer.style.display = 'block';
                readmeContainer.style.display = 'none';
                keysLinkElement.style.display = 'none';
                mdLinkElement.style.display = 'inline-block';
                log(context, `Returned to form view for ${setting.key_type}`);
            });

            formContainer.style.display = 'block';
            readmeContainer.style.display = 'none';
        }
    }

    formContainer.innerHTML = '';
    const form = document.createElement('form');
    form.id = 'affiliate-form';
    form.dataset.keyType = setting.key_type;

    Object.entries(setting.fields || {}).forEach(([name, value]) => {
        const div = document.createElement('div');
        div.style.marginBottom = '10px';
        div.innerHTML = `
            <label for="${name}">${name}:</label>
            <input type="text" id="${name}" name="${name}" value="${value || ''}">
        `;
        form.appendChild(div);
    });

    const saveButton = document.createElement('button');
    saveButton.type = 'submit';
    saveButton.className = 'save-button';
    const saveIcon = document.createElement('i');
    saveIcon.className = 'fas fa-save';
    saveButton.appendChild(saveIcon);
    saveButton.appendChild(document.createTextNode(' Save Affiliate'));
    form.appendChild(saveButton);

    formContainer.appendChild(form);
    setupAffiliateEvents(context);
}

function setupAffiliateEvents(context) {
    log(context, 'Setting up affiliate event listeners');
    setupEventListeners(context, [{
        eventType: 'submit',
        selector: '#affiliate-form',
        handler: async (event) => {
            event.preventDefault();
            const form = event.target;
            const keyType = form.dataset.keyType;
            const fields = {};
            Array.from(form.querySelectorAll('input')).forEach(input => {
                fields[input.name] = input.value;
            });
            try {
                await fetchData(context, `${API_ENDPOINTS.SETTINGS_AFFILIATE_KEY}/${keyType}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(fields),
                });
                success(context, SUCCESS_MESSAGES.SETTINGS_UPDATED);
                log(context, `Settings updated for ${keyType}`);
            } catch (err) {
                error(context, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
                log(context, `Error updating settings: ${err.message}`);
            }
        },
    }]);
}

export function initializeAffiliatesModule(registry) {
    return createModuleInitializer(context, {
        loadAffiliates,
    });
}

if (shouldInitializeForPageType('admin')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
} else {
    log(context, 'Skipping initialization for non-admin page');
}
admin/api-keys.js
// /static/js/admin/api-keys.js
import { log } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { withElement, toggleViewState } from '../utils/dom-manipulation.js';
import { error } from '../core/notifications.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { parsePageType, shouldInitializeForPageType } from '../utils/initialization.js';

const context = 'admin/api-keys.js';

export async function loadApiKeys(context) {
    const pageType = parsePageType(context, 'page', 'admin');
    if (pageType !== 'admin') {
        log(context, `Skipping initialization for non-admin page type: ${pageType}`);
        return;
    }
    log(context, 'Loading API keys');
    await withErrorHandling(`${context}:loadApiKeys`, async () => {
        await withElement(context, 'api-keys-icons', async iconsContainer => {
            await withElement(context, 'api-keys-fields', async fieldsContainer => {
                await withElement(context, 'api-keys-form', async form => {
                    const data = await fetchData(context, API_ENDPOINTS.SETTINGS_KEY, { method: 'GET' });
                    if (!data.settings || data.settings.length === 0) {
                        iconsContainer.innerHTML = '<p>No API keys available.</p>';
                        error(context, ERROR_MESSAGES.NO_DATA('API keys'));
                        return;
                    }
                    await displayApiKeyFields(context, data.settings[0], fieldsContainer, form);
                });
            });
        });
    }, ERROR_MESSAGES.FETCH_FAILED('API keys'));
}

export async function displayApiKeyFields(context, setting, fieldsContainer, form) {
    log(context, 'Rendering API key fields');
    fieldsContainer.innerHTML = '';
    form.style.display = 'block';
    form.dataset.keyType = setting.key_type;

    const container = document.createElement('div');
    container.className = 'api-keys-settings';
    fieldsContainer.appendChild(container);

    const heading = document.createElement('h3');
    heading.textContent = setting.comment || 'API Keys Settings';
    heading.className = 'api-keys-comment-heading';
    container.appendChild(heading);

    const description = document.createElement('p');
    description.textContent = setting.description || '';
    description.className = 'api-keys-description';
    container.appendChild(description);

    Object.entries(setting.fields).forEach(([name, value]) => {
        const div = document.createElement('div');
        div.className = 'api-keys-field';
        div.innerHTML = `
            <label for="${name}">${name}:</label>
            <input type="text" id="${name}" name="${name}" value="${value}">
        `;
        container.appendChild(div);
    });

    toggleViewState(context, { 'api-keys-fields': true });
}

if (shouldInitializeForPageType('admin')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
} else {
    log(context, 'Skipping initialization for non-admin page');
}
admin/deals-orchestrator.js
// /static/js/admin/deals-orchestrator.js
import { log } from '../core/logger.js';
import { loadDeals } from './deals.js';
import { getElements } from '../utils/dom-manipulation.js';
import { withErrorHandling } from '../utils/error.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { parsePageType, shouldInitializeForPageType } from '../utils/initialization.js';
import { createModuleInitializer } from '../utils/initialization.js';

const context = 'deals-orchestrator.js';

export async function initializeDealsOrchestrator(context) {
    const pageType = parsePageType(context, 'page', 'admin');
    if (pageType !== 'admin') {
        log(context, `Skipping initialization for non-admin page type: ${pageType}`);
        return;
    }
    log(context, 'Initializing deals orchestrator (stub feature)');
    await withErrorHandling(`${context}:initializeDealsOrchestrator`, async () => {
        const elements = await getElements(context, ['dealList']);
        await loadDeals(context, elements);
    }, 'Failed to initialize deals orchestrator (stub)');
}

export function initializeDealsOrchestratorModule(registry) {
    return createModuleInitializer(context, {
        initializeDealsOrchestrator,
    });
}

if (shouldInitializeForPageType('admin')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
} else {
    log(context, 'Skipping initialization for non-admin page');
}
admin/deals.js
// /static/js/admin/deals.js
import { log } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { parsePageType, shouldInitializeForPageType } from '../utils/initialization.js';

const context = 'deals.js';

export async function loadDeals(context, { dealList }) {
    const pageType = parsePageType(context, 'page', 'admin');
    if (pageType !== 'admin') {
        log(context, `Skipping initialization for non-admin page type: ${pageType}`);
        return;
    }
    log(context, 'Deals feature is a stub and not currently active');
    await withErrorHandling(`${context}:loadDeals`, async () => {
        if (dealList) {
            dealList.innerHTML = '<p>Deals feature is currently under development.</p>';
        }
    }, 'Failed to initialize deals stub');
}

export function initializeDealsModule(registry) {
    log(context, 'Initializing deals module for module registry');
    return {
        loadDeals: (ctx, ...args) => loadDeals(ctx, ...args),
    };
}

if (shouldInitializeForPageType('admin')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
} else {
    log(context, 'Skipping initialization for non-admin page');
}
admin/initializer.js
// /static/js/admin/initializer.js
import { log } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { initializeDealsOrchestrator } from './deals-orchestrator.js';
import { initializeUsersOrchestratorModule } from './users-orchestrator.js';
import { initializeSettingsOrchestrator } from './settings-orchestrator.js';
import { initializeReferralTest } from './referral-test.js'; // Added import
import { parsePageType, shouldInitializeForPageType } from '../utils/initialization.js';

const context = 'initializer.js';

export async function initializeAdminModules(context) {
    const pageType = parsePageType(context, 'page', 'admin');
    if (pageType !== 'admin') {
        log(context, `Skipping initialization for non-admin page type: ${pageType}`);
        return;
    }
    log(context, 'Initializing admin feature orchestrators');
    const orchestrators = [
        { name: 'deals', init: initializeDealsOrchestrator },
        { name: 'users', init: initializeUsersOrchestratorModule },
        { name: 'settings', init: initializeSettingsOrchestrator },
        { name: 'referralTest', init: initializeReferralTest }, // Added referralTest
    ];
    for (const { name, init } of orchestrators) {
        await withErrorHandling(`${context}:initialize${name}`, async () => {
            await init(context);
        }, `Failed to initialize ${name} orchestrator (continuing with other orchestrators)`);
    }
}

export function initializeInitializerModule(registry) {
    return createModuleInitializer(context, {
        initializeAdminModules,
    });
}

if (shouldInitializeForPageType('admin')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
} else {
    log(context, 'Skipping initialization for non-admin page');
}
admin/logs-ui.js
// /static/js/admin/logs-ui.js
import { authenticatedFetch } from '../core/auth.js'; // Import for authenticated requests

// Define available log periods with their icons and labels
const periods = [
    { name: 'today', icon: 'fa-calendar-day', label: 'Today' },
    { name: 'yesterday', icon: 'fa-calendar-day', label: 'Yesterday' },
    { name: 'this_week', icon: 'fa-calendar-week', label: 'This Week' },
    { name: 'last_week', icon: 'fa-calendar-week', label: 'Last Week' },
    { name: 'this_month', icon: 'fa-calendar', label: 'This Month' },
    { name: 'last_month', icon: 'fa-calendar', label: 'Last Month' }
];

// Define icons for each log type using FontAwesome classes
const logTypeIcons = {
    'login': 'fa-sign-in-alt',
    'signup': 'fa-user-plus',
    'click': 'fa-mouse-pointer',
    'order': 'fa-shopping-cart',
    // Add more log types and their corresponding icons as needed
};

/**
 * Renders period icons in the log_period_icon container and sets up click handlers.
 * Initializes with 'today' as the default selected period.
 */
export function renderPeriodIcons() {
    console.log('Rendering period icons'); // Debugging log
    const container = document.getElementById('log_period_icon');
    if (!container) {
        console.error('Error: log_period_icon container not found.');
        return;
    }
    container.innerHTML = ''; // Clear existing content
    periods.forEach((period, index) => {
        const icon = document.createElement('i');
        icon.className = `fa-solid ${period.icon} period-icon`;
        icon.dataset.period = period.name;
        if (index === 0) icon.classList.add('selected'); // Default to 'today'
        icon.addEventListener('click', () => selectPeriod(period.name));
        container.appendChild(icon);
    });
    selectPeriod('today'); // Load logs for 'today' initially
}

/**
 * Selects a period, updates the UI, and triggers log loading for that period.
 * Updates the logs-description element with the log type icon and period label.
 * @param {string} periodName - The name of the period to select (e.g., 'today').
 */
export function selectPeriod(periodName) {
    const icons = document.querySelectorAll('.period-icon');
    icons.forEach(icon => icon.classList.remove('selected'));
    const selectedIcon = document.querySelector(`.period-icon[data-period="${periodName}"]`);
    if (selectedIcon) {
        selectedIcon.classList.add('selected');
    }
    const period = periods.find(p => p.name === periodName);
    if (period) {
        const logsSection = document.getElementById('logs');
        const type = logsSection ? logsSection.dataset.type : null;
        updateDescription(type, period.label); // Update description with icon and text
        loadLogs(period.name);
    }
}

/**
 * Updates the logs-description element with the log type icon and text.
 * @param {string} type - The log type (e.g., 'login', 'signup').
 * @param {string} periodLabel - The label of the selected period (e.g., 'Today').
 */
function updateDescription(type, periodLabel) {
    const descriptionElement = document.getElementById('logs-description');
    if (descriptionElement) {
        const typeLabel = type ? type.charAt(0).toUpperCase() + type.slice(1) : 'Unknown';
        const iconClass = logTypeIcons[type] || 'fa-question'; // Default to question mark if type unknown
        descriptionElement.innerHTML = `<i class="fa-solid ${iconClass}"></i> ${typeLabel} logs for ${periodLabel}`;
    } else {
        console.warn('Warning: logs-description element not found.');
    }
}

/**
 * Fetches logs for a given period and type, then renders them.
 * @param {string} period - The period for which to fetch logs (e.g., 'today').
 */
export async function loadLogs(period) {
    const logsSection = document.getElementById('logs');
    const type = logsSection.dataset.type;
    if (!type) {
        console.error('Error: No type set for logs section.');
        return;
    }
    try {
        const response = await authenticatedFetch(`/logs/${type}?period=${period}`, {
            headers: { 'Content-Type': 'application/json' },
        });
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }
        const data = await response.json();
        if (data.status === 'success') {
            renderLogsTable(data.data);
        } else {
            throw new Error(data.message || 'Failed to fetch logs.');
        }
    } catch (error) {
        console.error('Error loading logs:', error);
        document.getElementById('logs-table-container').innerHTML = `
            <p>Error: ${error.message}</p>
            <button onclick="loadLogs('${period}')">Retry</button>
        `;
    }
}

/**
 * Formats a timestamp string to UK format (DD/MM/YYYY HH:MM).
 * @param {string} timestamp - The timestamp to format (expected in ISO format).
 * @returns {string} - The formatted timestamp or 'N/A' if invalid.
 */
function formatTimestamp(timestamp) {
    if (!timestamp) return 'N/A';
    const date = new Date(timestamp);
    if (isNaN(date.getTime())) return 'N/A'; // Invalid date
    const options = {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        hour12: false
    };
    return date.toLocaleString('en-GB', options).replace(',', '');
}

/**
 * Renders the logs data into a table within the logs-table-container.
 * @param {Array} logs - Array of log objects to display.
 */
export function renderLogsTable(logs) {
    const container = document.getElementById('logs-table-container');
    if (!container) {
        console.error('Error: logs-table-container not found.');
        return;
    }
    container.innerHTML = ''; // Clear existing content
    const table = document.createElement('table');
    table.innerHTML = `
        <thead>
            <tr>
                <th>Timestamp</th>
                <th>Details</th>
            </tr>
        </thead>
        <tbody>
            ${logs.map(log => `
                <tr>
                    <td>${formatTimestamp(log.timestamp)}</td>
                    <td>${log.details || 'N/A'}</td>
                </tr>
            `).join('')}
        </tbody>
    `;
    container.appendChild(table);
}

/**
 * Changes the log type and refreshes the logs display.
 * @param {string} type - The new log type (e.g., 'click', 'order').
 */
export function changeLogType(type) {
    const logsSection = document.getElementById('logs');
    if (logsSection) {
        logsSection.dataset.type = type;
        const currentPeriod = document.querySelector('.period-icon.selected')?.dataset.period || 'today';
        selectPeriod(currentPeriod); // Reload logs and update description
    } else {
        console.error('Error: logs section not found.');
    }
}

/**
 * Initializes the logs UI when the DOM is fully loaded.
 */
function initializeLogsUI() {
    const logsSection = document.getElementById('logs');
    if (logsSection && !logsSection.dataset.type) {
        logsSection.dataset.type = 'default'; // Set a default log type if none specified
    }
    renderPeriodIcons();
}

// Initialize the UI when the DOM is loaded
document.addEventListener('DOMContentLoaded', initializeLogsUI);
admin/navigation.js
// /static/js/admin/navigation.js
import { log, error as logError } from '../core/logger.js';
import { defineSectionHandlers } from '../modules/navigation.js';
import { loadDeals } from './deals.js';
import { initializeUserManagement } from './users-orchestrator.js';
import { loadAdminSettings } from './settings.js';
import { initializeAdminModules } from './initializer.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { toggleViewState } from '../utils/dom-manipulation.js';
import { parsePageType, shouldInitializeForPageType } from '../utils/initialization.js';
import { loadSiteRequests, viewSiteRequest } from './site-requests.js';

const context = 'navigation.js';

let lastSection = null; // Track the last section to prevent duplicate events
const DEBOUNCE_MS = 100; // Debounce events within 100ms

export function defineAdminSectionHandlers(context) {
    const pageType = parsePageType(context, 'page', 'admin');
    if (pageType !== 'admin') {
        log(context, `Skipping initialization for non-admin page type: ${pageType}`);
        return;
    }
    log(context, 'Defining section handlers');
    defineSectionHandlers(context, 'admin', [
        {
            id: 'info',
            handler: async (show) => {
                if (show && lastSection !== 'info') {
                    log(context, 'Loading info section');
                    lastSection = 'info';
                    await new Promise(resolve => setTimeout(resolve, DEBOUNCE_MS));
                    toggleViewState(context, { info: show });
                } else if (!show) {
                    lastSection = null;
                    toggleViewState(context, { info: false });
                }
            },
        },
        {
            id: 'user_management',
            handler: async (show) => {
                if (show && lastSection !== 'user_management') {
                    log(context, 'Loading user management section');
                    lastSection = 'user_management';
                    await new Promise(resolve => setTimeout(resolve, DEBOUNCE_MS));
                    await initializeUserManagement(context);
                    toggleViewState(context, { user_management: show });
                } else if (!show) {
                    lastSection = null;
                    toggleViewState(context, { user_management: false });
                }
            },
        },
        {
            id: 'affiliates',
            handler: async (show) => {
                if (show && lastSection !== 'affiliates') {
                    log(context, 'Calling loadAdminSettings for affiliates');
                    lastSection = 'affiliates';
                    await new Promise(resolve => setTimeout(resolve, DEBOUNCE_MS));
                    await loadAdminSettings(context, 'affiliates');
                    toggleViewState(context, { affiliates: show });
                } else if (!show) {
                    lastSection = null;
                    toggleViewState(context, { affiliates: false });
                }
            },
        },
        {
            id: 'site_settings',
            handler: async (show) => {
                if (show && lastSection !== 'site_settings') {
                    log(context, 'Calling initializeAdminModules');
                    lastSection = 'site_settings';
                    await new Promise(resolve => setTimeout(resolve, DEBOUNCE_MS));
                    await initializeAdminModules(context);
                    toggleViewState(context, { site_settings: show });
                } else if (!show) {
                    lastSection = null;
                    toggleViewState(context, { site_settings: false });
                }
            },
        },
        {
            id: 'api_keys',
            handler: async (show) => {
                if (show && lastSection !== 'api_keys') {
                    log(context, 'Calling loadAdminSettings for apiKeys');
                    lastSection = 'api_keys';
                    await new Promise(resolve => setTimeout(resolve, DEBOUNCE_MS));
                    await loadAdminSettings(context, 'apiKeys');
                    toggleViewState(context, { api_keys: show });
                } else if (!show) {
                    lastSection = null;
                    toggleViewState(context, { api_keys: false });
                }
            },
        },
        {
            id: 'deals',
            handler: async (show) => {
                if (show && lastSection !== 'deals') {
                    log(context, 'Calling loadDeals');
                    lastSection = 'deals';
                    await new Promise(resolve => setTimeout(resolve, DEBOUNCE_MS));
                    const elements = await import('../utils/dom-manipulation.js').then(m => m.getElements(context, ['dealList']));
                    await loadDeals(context, elements);
                    toggleViewState(context, { deals: show });
                } else if (!show) {
                    lastSection = null;
                    toggleViewState(context, { deals: false });
                }
            },
        },
        {
            id: 'site_requests',
            handler: async (show) => {
                if (show && lastSection !== 'site_requests') {
                    log(context, 'Loading site requests section');
                    lastSection = 'site_requests';
                    await new Promise(resolve => setTimeout(resolve, DEBOUNCE_MS));
                    await loadSiteRequests(context);
                    toggleViewState(context, { site_requests: show });
                } else if (!show) {
                    log(context, 'Hiding site requests section');
                    lastSection = null;
                    toggleViewState(context, { site_requests: false });
                }
            },
        },
        {
            id: 'view-site-request',
            handler: async (show) => {
                if (show && lastSection !== 'view-site-request') {
                    log(context, 'Loading view site request section');
                    lastSection = 'view-site-request';
                    await new Promise(resolve => setTimeout(resolve, DEBOUNCE_MS));
                    toggleViewState(context, { 'view-site-request': show });
                } else if (!show) {
                    log(context, 'Hiding view site request section');
                    lastSection = null;
                    toggleViewState(context, { 'view-site-request': false });
                }
            },
        },
        {
            id: 'logsIntro',
            handler: async (show) => {
                if (show && lastSection !== 'logsIntro') {
                    log(context, 'Loading logsIntro section');
                    lastSection = 'logsIntro';
                    await new Promise(resolve => setTimeout(resolve, DEBOUNCE_MS));
                    toggleViewState(context, { logsIntro: show });
                } else if (!show) {
                    lastSection = null;
                    toggleViewState(context, { logsIntro: false });
                }
            },
        },
        {
            id: 'logs',
            handler: async (show, role, type) => {
                if (show && lastSection !== 'logs') {
                    log(context, `Loading logs section with type: ${type || 'none'}`);
                    lastSection = 'logs';
                    await new Promise(resolve => setTimeout(resolve, DEBOUNCE_MS));
                    toggleViewState(context, { logs: true });
                    if (type) {
                        await loadLogs(type);
                    } else {
                        logError(context, 'No log type specified');
                    }
                } else if (!show) {
                    lastSection = null;
                    toggleViewState(context, { logs: false });
                }
            },
        },
    ]);
}

export function initializeNavigationModule(registry) {
    log(context, 'Initializing navigation module for module registry');
    return {
        defineAdminSectionHandlers: ctx => defineAdminSectionHandlers(ctx),
    };
}

if (shouldInitializeForPageType('admin')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
} else {
    log(context, 'Skipping initialization for non-admin page');
}
admin/referral-test.js
// /static/js/admin/referral-test.js
import { log, warn } from '../core/logger.js';
import { success, error } from '../core/notifications.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { shouldInitializeForPageType } from '../utils/initialization.js';

const context = 'referral-test.js';

let currentUserId;

document.addEventListener('DOMContentLoaded', () => {
    const userIdInput = document.getElementById('userId');
    if (userIdInput && userIdInput.value) {
        currentUserId = userIdInput.value;
    } else {
        warn(context, 'Current user ID not found in template variables');
        currentUserId = 'unknown';
    }

    if (shouldInitializeForPageType('admin')) {
        initializeReferralTest(context);
    }
});

export async function initializeReferralTest(context) {
    log(context, 'Initializing referral test forms');
    await withErrorHandling(`${context}:initializeReferralTest`, async () => {
        // Set default values
        const pageVisitForm = document.getElementById('pageVisitForm');
        const orderForm = document.getElementById('orderForm');

        if (pageVisitForm) {
            pageVisitForm.querySelector('#sourceUserId').value = currentUserId;
            pageVisitForm.querySelector('#destinationUserId').value = currentUserId;
        } else {
            warn(context, 'pageVisitForm not found');
        }

        if (orderForm) {
            orderForm.querySelector('#orderSourceUserId').value = currentUserId;
            orderForm.querySelector('#orderDestinationUserId').value = currentUserId;
        } else {
            warn(context, 'orderForm not found');
        }

        // Setup form event listeners with duplicate prevention
        setupFormListeners(context);
    }, ERROR_MESSAGES.MODULE_INIT_FAILED);
}

function setupFormListeners(context) {
    log(context, 'Setting up form event listeners');

    const pageVisitForm = document.getElementById('pageVisitForm');
    const orderForm = document.getElementById('orderForm');

    if (pageVisitForm && !pageVisitForm._submitListenerAttached) {
        pageVisitForm.addEventListener('submit', (event) => {
            event.preventDefault();
            event.stopPropagation(); // Prevent event bubbling
            log(context, 'Page visit form submit event triggered');
            handleFormSubmit(context, event.target, API_ENDPOINTS.EVENT, 'click');
        });
        pageVisitForm._submitListenerAttached = true;
        log(context, 'Page visit form listener attached');
    }

    if (orderForm && !orderForm._submitListenerAttached) {
        orderForm.addEventListener('submit', (event) => {
            event.preventDefault();
            event.stopPropagation(); // Prevent event bubbling
            log(context, 'Order form submit event triggered');
            handleFormSubmit(context, event.target, API_ENDPOINTS.EVENT, 'order');
        });
        orderForm._submitListenerAttached = true;
        log(context, 'Order form listener attached');
    }
}

async function handleFormSubmit(context, form, endpoint, eventType) {
    log(context, `Handling ${eventType} form submission to ${endpoint}`);
    const formData = new FormData(form);
    const data = Object.fromEntries(formData);

    if (eventType === 'order') {
        data.sale_value = parseFloat(data.sale_value || '0');
        if (isNaN(data.sale_value)) {
            error(context, 'Invalid sale value: must be a number');
            return;
        }
    }

    try {
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data),
        });

        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);

        const result = await response.json();
        if (result.status === 'success') {
            success(context, SUCCESS_MESSAGES[`${eventType.toUpperCase()}_RECORDED`]);
            log(context, `${eventType} recorded successfully: ${result.message || 'No message'}`);
            form.reset();
            form.querySelector('input[name="source_user_id"]').value = currentUserId;
            form.querySelector('input[name="destination_user_id"]').value = currentUserId;
            if (eventType === 'order') {
                form.querySelector('input[name="sale_value"]').value = '99.99';
            }
        } else {
            throw new Error(result.message || 'Unknown error');
        }
    } catch (err) {
        error(context, `Failed to record ${eventType}: ${err.message}`);
        log(context, `Error submitting ${eventType} form: ${err.message}`);
    }
}
admin/settings-orchestrator.js
// /static/js/admin/settings-orchestrator.js
import { log } from '../core/logger.js';
import { loadAdminSettings } from './settings.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { parsePageType, shouldInitializeForPageType } from '../utils/initialization.js';
import { createModuleInitializer } from '../utils/initialization.js';

const context = 'settings-orchestrator.js';

export async function initializeSettingsOrchestrator(context) {
    const pageType = parsePageType(context, 'page', 'admin');
    if (pageType !== 'admin') {
        log(context, `Skipping initialization for non-admin page type: ${pageType}`);
        return;
    }
    log(context, 'Initializing settings orchestrator');
    const settingsTypes = ['affiliates', 'siteSettings', 'apiKeys'];
    for (const type of settingsTypes) {
        await withErrorHandling(`${context}:initialize${type}`, async () => {
            await loadAdminSettings(context, type);
        }, ERROR_MESSAGES.MODULE_INIT_FAILED);
    }
}

export function initializeSettingsOrchestratorModule(registry) {
    return createModuleInitializer(context, {
        initializeSettingsOrchestrator,
    });
}

if (shouldInitializeForPageType('admin')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
} else {
    log(context, 'Skipping initialization for non-admin page');
}
admin/settings.js
// /static/js/admin/settings.js
import { log } from '../core/logger.js';
import { renderSettingsForm } from '../utils/settings-renderer.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { SETTINGS } from '../config/settings.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { createModuleInitializer } from '../utils/initialization.js';
import { loadSettings } from '../utils/settings-data.js';
import { withErrorHandling } from '../utils/error.js';
import { parsePageType, shouldInitializeForPageType } from '../utils/initialization.js';

const context = 'settings.js';

export async function loadAdminSettings(context, type) {
    const pageType = parsePageType(context, 'page', 'admin');
    if (pageType !== 'admin') {
        log(context, `Skipping initialization for non-admin page type: ${pageType}`);
        return;
    }
    log(context, `Loading ${type} settings`);
    const settingsConfig = SETTINGS[type];
    if (!settingsConfig) {
        throw new Error(`Unknown settings type: ${type}`);
    }
    let settingsData = [];
    try {
        settingsData = await loadSettings(context, settingsConfig.endpoint);
    } catch (err) {
        log(context, `Failed to fetch settings for ${type}: ${err.message}`);
        settingsData = [];
    }
    const configWithSettings = {
        ...settingsConfig,
        settings: settingsData,
    };
    await withErrorHandling(`${context}:renderSettingsForm`, async () => {
        await renderSettingsForm(context, configWithSettings);
    }, ERROR_MESSAGES.RENDER_FAILED('settings form'));
}

export function initializeSettingsModule(registry) {
    return createModuleInitializer(context, {
        loadAdminSettings,
    });
}

if (shouldInitializeForPageType('admin')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
} else {
    log(context, 'Skipping initialization for non-admin page');
}
admin/site-requests.js
// /static/js/admin/site-requests.js
import { log, warn, error as logError } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { renderDataTable } from '../utils/ui-components.js';
import { toggleViewState, withElement } from '../utils/dom-manipulation.js';
import { error, success } from '../core/notifications.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/messages.js';
import { API_ENDPOINTS } from '../config/endpoints.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { parsePageType, shouldInitializeForPageType } from '../utils/initialization.js';
import { createModuleInitializer } from '../utils/initialization.js';

const context = 'site-requests.js';

/**
 * Loads and renders the list of site requests into a table.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function loadSiteRequests(context) {
    const pageType = await parsePageType(context, 'page', 'admin');
    if (pageType !== 'admin') {
        log(context, `Skipping initialization for non-admin page type: ${pageType}`);
        return;
    }
    log(context, 'Loading site requests');
    await withErrorHandling(`${context}:loadSiteRequests`, async () => {
        await withElement(context, 'site-request-list', async (tableBody) => {
            const data = await fetchData(context, API_ENDPOINTS.SITE_REQUESTS, { method: 'GET' });
            log(context, `API response for ${API_ENDPOINTS.SITE_REQUESTS}:`, data);
            if (!data.siterequests || !Array.isArray(data.siterequests) || data.siterequests.length === 0) {
                warn(context, 'No site requests found');
                tableBody.innerHTML = '<tr><td colspan="7">No site requests available.</td></tr>';
                error(context, ERROR_MESSAGES.NO_DATA('site requests'));
                return;
            }

            const headers = ['User ID', 'Contact Name', 'Email', 'Organisation', 'Type', 'Received At', 'Actions'];
            const rowMapper = (request) => {
                const viewButton = document.createElement('button');
                viewButton.textContent = 'View';
                viewButton.className = 'view-site-request';
                viewButton.dataset.userId = request.user_id;
                viewButton.addEventListener('click', () => {
                    viewSiteRequest(context, request.user_id);
                });

                return [
                    request.user_id || 'N/A',
                    request.contact_name || 'N/A',
                    request.email || 'N/A',
                    request.organisation || 'N/A',
                    request.type || 'N/A',
                    new Date(request.received_at).toLocaleString('en-GB') || 'N/A',
                    viewButton
                ];
            };

            const tbody = await renderDataTable(context, {
                data: data.siterequests,
                headers,
                rowMapper,
                emptyMessage: 'No site requests available.'
            });

            tableBody.innerHTML = '';
            while (tbody.firstChild) {
                tableBody.appendChild(tbody.firstChild);
            }
            log(context, `Rendered ${data.siterequests.length} site requests`);
            toggleViewState(context, { site_requests: true, 'view-site-request': false });
        });
    }, ERROR_MESSAGES.FETCH_FAILED('site requests'));
}

/**
 * Loads and renders the details of a specific site request in read-only mode with TinyMCE controls.
 * @param {string} context - The context or module name.
 * @param {string} userId - The user ID associated with the site request.
 * @returns {Promise<void>}
 */
export async function viewSiteRequest(context, userId) {
    const pageType = await parsePageType(context, 'page', 'admin');
    if (pageType !== 'admin') {
        log(context, `Skipping initialization for non-admin page type: ${pageType}`);
        return;
    }
    log(context, `Viewing site request for user ID: ${userId}`);
    await withErrorHandling(`${context}:viewSiteRequest`, async () => {
        const data = await fetchData(context, `${API_ENDPOINTS.SITE_REQUESTS}/${userId}`, { method: 'GET' });
        log(context, `API response for ${API_ENDPOINTS.SITE_REQUESTS}/${userId}:`, data);
        if (!data.siterequest) {
            warn(context, `No site request found for user ID: ${userId}`);
            error(context, ERROR_MESSAGES.NO_DATA('site request'));
            return;
        }

        await withElement(context, 'siteRequestForm', async (form) => {
            const request = data.siterequest;

            // **Populate static fields**
            const fields = {
                'name': request.communityName || '',
                'about': request.aboutCommunity || '',
                'colorPrefs': request.colorPrefs || '',
                'stylingDetails': request.stylingDetails || '',
                'preferredDomain': request.preferredDomain || ''
            };

            Object.entries(fields).forEach(([id, value]) => {
                const input = form.querySelector(`#${id}`);
                if (input) {
                    input.value = value;
                    // Only disable non-textarea elements; TinyMCE will handle textareas
                    if (input.tagName !== 'TEXTAREA') {
                        input.disabled = true;
                    }
                }
            });

            // **Populate logos (display actual images instead of file input)**
            const logosContainer = form.querySelector('#orglogos');
            if (logosContainer) {
                logosContainer.innerHTML = ''; // Clear existing content
                const logos = request.communityLogos;
                if (Array.isArray(logos)) {
                    if (logos.length > 0) {
                        logos.forEach((logo, index) => {
                            const img = document.createElement('img');
                            img.src = logo; // Assuming logo is a URL or path to the image
                            img.alt = `Logo ${index + 1}`;
                            img.className = 'logo-image'; // Optional: Add styling class
                            logosContainer.appendChild(img);
                        });
                    } else {
                        logosContainer.innerHTML = '<p>No logos available</p>';
                    }
                } else if (typeof logos === 'string') {
                    const img = document.createElement('img');
                    img.src = logos;
                    img.alt = 'Logo';
                    img.className = 'logo-image';
                    logosContainer.appendChild(img);
                } else {
                    logosContainer.innerHTML = '<p>No logos available</p>';
                }
            }

            // **Populate emails**
            const emailsContainer = form.querySelector('#emailsContainer');
            if (emailsContainer) {
                emailsContainer.innerHTML = (request.emails || ['']).map((email, index) => `
                    <div class="email-entry">
                        <input type="email" name="email_${index}" value="${email}" disabled>
                    </div>
                `).join('');
                // Disable add email button
                const addEmailButton = form.querySelector('[data-action="addEmail"]');
                if (addEmailButton) addEmailButton.disabled = true;
            }

            // **Populate pages with TinyMCE-enabled textareas**
            const pagesContainer = form.querySelector('#pagesContainer');
            if (pagesContainer) {
                pagesContainer.innerHTML = (request.pages || []).map((page, index) => {
                    let imagesHtml;
                    if (Array.isArray(page.images)) {
                        imagesHtml = page.images.length > 0
                            ? page.images.map((img, imgIndex) => `
                                <img src="${img}" alt="Page Image ${imgIndex + 1}" class="page-image">
                            `).join('')
                            : '<p>No images available</p>';
                    } else if (typeof page.images === 'string') {
                        imagesHtml = `<img src="${page.images}" alt="Page Image" class="page-image">`;
                    } else {
                        imagesHtml = '<p>No images available</p>';
                    }
                    return `
                        <div class="page-entry">
                            <input type="text" name="page_${index}_title" value="${page.title || ''}" disabled>
                            <textarea id="page_${index}_content" name="page_${index}_content" class="mce-editor">${page.content || ''}</textarea>
                            <div class="page-images">${imagesHtml}</div>
                        </div>
                    `;
                }).join('');
                // Disable add page button
                const addPageButton = form.querySelector('[data-action="addPage"]');
                if (addPageButton) addPageButton.disabled = true;
            }

            // **Populate widgets**
            const widgetCheckboxes = form.querySelectorAll('input[name="widgets"]');
            widgetCheckboxes.forEach(checkbox => {
                checkbox.checked = (request.widgets || []).includes(checkbox.value);
                checkbox.disabled = true;
            });

            // **Disable submit button**
            const submitButton = form.querySelector('.submit-request-button');
            if (submitButton) submitButton.disabled = true;

            // **Initialize TinyMCE on all textareas with class "mce-editor"**
            tinymce.init({
                selector: 'textarea.mce-editor',
                readonly: true,
                toolbar: false,
                menubar: false,
                statusbar: false
            });

            // **Setup back button to destroy TinyMCE instances before navigating back**
            const backButton = document.getElementById('back-to-list');
            if (backButton) {
                backButton.addEventListener('click', () => {
                    destroyTinyMCE();
                    loadSiteRequests(context);
                });
            }

            toggleViewState(context, { 'view-site-request': true, site_requests: false });
        });
    }, ERROR_MESSAGES.FETCH_FAILED('site request details'));
}

/**
 * Destroys all TinyMCE instances on textareas with class "mce-editor".
 */
function destroyTinyMCE() {
    tinymce.remove('textarea.mce-editor');
}

/**
 * Initializes the site requests module for the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Module instance with public methods.
 */
export function initializeSiteRequestsModule(registry) {
    return createModuleInitializer(context, {
        loadSiteRequests,
        viewSiteRequest
    });
}

if (shouldInitializeForPageType('admin')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
} else {
    log(context, 'Skipping initialization for non-admin page');
}
admin/site-settings.js
// /static/js/admin/site-settings.js
import { log, warn } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { withElement } from '../utils/dom-manipulation.js';
import { error, success } from '../core/notifications.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { parsePageType, shouldInitializeForPageType } from '../utils/initialization.js';

const context = 'admin/site-settings.js';
let isSubmitting = false;

export async function loadSiteSettings(context) {
    const pageType = await parsePageType(context, 'page', 'admin');
    if (pageType !== 'admin') {
        log(context, `Skipping initialization for non-admin page type: ${pageType}`);
        return;
    }
    log(context, 'Loading site settings');
    await withErrorHandling(`${context}:loadSiteSettings`, async () => {
        await withElement(context, 'site-settings-icons', async (iconsContainer) => {
            const data = await fetchData(context, API_ENDPOINTS.SETTINGS_KEY, { method: 'GET' });
            log(context, `API response for ${API_ENDPOINTS.SETTINGS_KEY}:`, data);
            if (!data.settings || !Array.isArray(data.settings) || data.settings.length === 0) {
                iconsContainer.innerHTML = '<p>No site settings available.</p>';
                error(context, 'No site settings available');
                return;
            }
            iconsContainer.innerHTML = '';
            data.settings.forEach((setting, index) => {
                const safeKeyType = setting.key_type.replace(/[^a-zA-Z0-9-_]/g, '-');
                const iconContainer = document.createElement('span');
                iconContainer.style.width = '24px';
                iconContainer.style.height = '24px';
                iconContainer.style.display = 'inline-flex';
                iconContainer.style.justifyContent = 'center';
                iconContainer.style.alignItems = 'center';
                iconContainer.style.cursor = 'pointer';
                iconContainer.dataset.index = index;
                const icon = document.createElement('i');
                const iconClasses = (setting.icon || 'fas fa-cog').split(' ');
                iconClasses.forEach(cls => icon.classList.add(cls));
                icon.classList.add('site-settings-icon', `icon-${safeKeyType}`);
                icon.style.fontSize = '24px';
                iconContainer.appendChild(icon);
                iconsContainer.appendChild(iconContainer);
                iconContainer.addEventListener('click', (event) => {
                    event.stopPropagation();
                    iconsContainer.querySelectorAll('.site-settings-icon').forEach(i => i.classList.remove('selected'));
                    icon.classList.add('selected');
                    displaySiteSettingsFields(context, setting);
                });
            });
            const allIcons = iconsContainer.querySelectorAll('.site-settings-icon');
            if (allIcons.length > 0) {
                allIcons[0].classList.add('selected');
                await displaySiteSettingsFields(context, data.settings[0]);
            }
        });
    }, ERROR_MESSAGES.FETCH_FAILED('site settings'));
}

export async function displaySiteSettingsFields(context, setting) {
    log(context, `Rendering fields for site setting with key_type: ${setting.key_type}`);
    const form = document.getElementById('site-settings-form');
    const fieldsContainer = document.getElementById('site-settings-fields');
    if (!form || !fieldsContainer) {
        warn(context, 'Missing required DOM elements for site settings details');
        error(context, 'Missing required DOM elements for site settings details');
        return;
    }
    fieldsContainer.innerHTML = '';
    const header = document.createElement('div');
    header.style.display = 'flex';
    header.style.alignItems = 'center';
    header.style.marginBottom = '15px';
    const icon = document.createElement('i');
    const iconClasses = (setting.icon || 'fas fa-cog').split(' ');
    iconClasses.forEach(cls => icon.classList.add(cls));
    icon.classList.add('selected-setting-icon');
    icon.style.fontSize = '16px';
    icon.style.color = 'currentColor';
    icon.style.marginRight = '10px';
    header.appendChild(icon);
    const title = document.createElement('h3');
    title.className = 'site-settings-comment-heading';
    title.style.display = 'inline-block';
    title.style.verticalAlign = 'middle';
    title.style.margin = '0';
    title.textContent = setting.comment || `${setting.key_type} Settings`;
    header.appendChild(title);
    const linksContainer = document.createElement('div');
    linksContainer.style.marginLeft = 'auto';
    linksContainer.style.display = 'flex';
    linksContainer.style.gap = '10px';
    if (Array.isArray(setting.doc_link) && setting.doc_link.length > 0) {
        setting.doc_link.forEach((doc) => {
            const linkElement = document.createElement('a');
            linkElement.className = `site-settings-${doc.title}-link`;
            linkElement.style.color = 'currentColor';
            linkElement.innerHTML = `<i class="fas fa-${doc.title === 'api' ? 'link' : doc.title === 'signup' ? 'user-plus' : 'book'}" style="font-size: 16px;"></i>`;
            linkElement.href = doc.link;
            linkElement.style.display = 'inline-block';
            linkElement.target = '_blank';
            linkElement.title = doc.title.charAt(0).toUpperCase() + doc.title.slice(1);
            linksContainer.appendChild(linkElement);
        });
    }
    header.appendChild(linksContainer);
    fieldsContainer.appendChild(header);
    const descriptionText = setting._description || setting.description || 'Use this section to manage your site settings.';
    const description = document.createElement('p');
    description.className = 'site-settings-description';
    description.style.marginBottom = '15px';
    description.textContent = descriptionText;
    fieldsContainer.appendChild(description);
    Object.entries(setting.fields || {}).forEach(([name, value]) => {
        const div = document.createElement('div');
        div.style.marginBottom = '10px';
        div.innerHTML = `
            <label for="${name}">${name}:</label>
            <input type="text" id="${name}" name="${name}" value="${value || ''}">
        `;
        fieldsContainer.appendChild(div);
    });
    form.dataset.keyType = setting.key_type;
    form.style.display = 'block';
}

async function handleFormSubmit(event) {
    if (isSubmitting) return;
    isSubmitting = true;
    event.preventDefault();
    const form = document.getElementById('site-settings-form');
    const keyType = form.dataset.keyType;
    log(context, `Form submission - keyType: ${keyType}`);
    if (!keyType) {
        warn(context, 'No keyType set for form submission');
        error(context, 'Failed to update settings: No keyType specified');
        isSubmitting = false;
        return;
    }
    const fields = {};
    Array.from(form.querySelectorAll('input')).forEach((input) => {
        fields[input.name] = input.value;
    });
    try {
        await fetchData(context, `${API_ENDPOINTS.SETTINGS_KEY}/${keyType}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(fields),
        });
        success(context, SUCCESS_MESSAGES.SETTINGS_UPDATED);
        log(context, `Settings updated for ${keyType}`);
    } catch (err) {
        error(context, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
        log(context, `Error updating settings: ${err.message}`);
    } finally {
        isSubmitting = false;
    }
}

if (shouldInitializeForPageType('admin')) {
    const form = document.getElementById('site-settings-form');
    if (form) {
        form.addEventListener('submit', handleFormSubmit);
    } else {
        warn(context, 'Form element not found');
    }
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
} else {
    log(context, 'Skipping initialization for non-admin page');
}
admin/users-data.js
// /static/js/admin/users-data.js
import { authenticatedFetch } from '../core/auth.js';
import { log } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { parsePageType, shouldInitializeForPageType } from '../utils/initialization.js';

const context = 'users-data.js';

export async function loadUsers(context, role = 'admin') {
    const pageType = parsePageType(context, 'page', 'admin');
    if (pageType !== 'admin') {
        log(context, `Skipping initialization for non-admin page type: ${pageType}`);
        return { users: [], role };
    }
    log(context, `Fetching users for role: ${role}`);
    return await withErrorHandling(`${context}:loadUsers`, async () => {
        const endpoint = API_ENDPOINTS.USERS_ROLE(role);
        const response = await authenticatedFetch(endpoint);
        const data = await response.json();
        if (data.status === 'error') {
            throw new Error(data.message || ERROR_MESSAGES.FETCH_FAILED(`users for role ${role}`));
        }
        return { users: data.users || [], role };
    }, ERROR_MESSAGES.FETCH_FAILED(`users for role ${role}`));
}

export async function updateUserPermission(context, userId, permission, isChecked, role) {
    const pageType = parsePageType(context, 'page', 'admin');
    if (pageType !== 'admin') {
        log(context, `Skipping initialization for non-admin page type: ${pageType}`);
        return { userId, permission, isChecked, role, message: 'Skipped due to page type' };
    }
    log(context, `Updating permission ${permission} for user ${userId}`);
    const method = isChecked ? 'PATCH' : 'DELETE';
    return await withErrorHandling(`${context}:updateUserPermission`, async () => {
        const response = await authenticatedFetch(API_ENDPOINTS.PERMISSION, {
            method,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ userId, permission }),
        });
        const data = await response.json();
        return { userId, permission, isChecked, role, message: data.message || 'Permission updated' };
    }, ERROR_MESSAGES.FETCH_FAILED('permission update'));
}

export async function fetchUserForPermissions(context, userId) {
    const pageType = parsePageType(context, 'page', 'admin');
    if (pageType !== 'admin') {
        log(context, `Skipping initialization for non-admin page type: ${pageType}`);
        return {};
    }
    log(context, `Fetching user data for ${userId}`);
    return await withErrorHandling(`${context}:fetchUserForPermissions`, async () => {
        const response = await authenticatedFetch(API_ENDPOINTS.USERS_USERID(userId));
        const userData = await response.json();
        if (userData.status === 'error') {
            throw new Error(userData.message || ERROR_MESSAGES.FETCH_FAILED('user details'));
        }
        return userData;
    }, ERROR_MESSAGES.FETCH_FAILED('user details'));
}

export function initializeUsersDataModule(registry) {
    log(context, 'Initializing users data module for module registry');
    return {
        loadUsers: (ctx, ...args) => loadUsers(ctx, ...args),
        updateUserPermission: (ctx, ...args) => updateUserPermission(ctx, ...args),
        fetchUserForPermissions: (ctx, ...args) => fetchUserForPermissions(ctx, ...args),
    };
}

if (shouldInitializeForPageType('admin')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
} else {
    log(context, 'Skipping initialization for non-admin page');
}
admin/users-orchestrator.js
// /static/js/admin/users-orchestrator.js
import { log, error as logError } from '../core/logger.js';
import { renderRoleIcons } from './users-ui.js';
import { setupAdminEvents } from './admin-events.js';
import { getElements } from '../utils/dom-manipulation.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { parsePageType, shouldInitializeForPageType } from '../utils/initialization.js';
import { createModuleInitializer } from '../utils/initialization.js';

const context = 'users-orchestrator.js';

export async function initializeUserManagement(context) {
    const pageType = await parsePageType(context, 'page', 'admin');
    if (pageType !== 'admin') {
        log(context, `Skipping initialization for non-admin page type: ${pageType}`);
        return;
    }
    log(context, 'Initializing user management');
    await withErrorHandling(`${context}:initializeUserManagement`, async () => {
        const elements = await getElements(context, ['user_management', 'user_list']);
        if (!elements.user_management || !elements.user_list) {
            logError(context, 'Required elements not found');
            throw new Error(ERROR_MESSAGES.ELEMENT_NOT_FOUND);
        }
        await renderRoleIcons(context);
        log(context, 'Events setup for user management');
        await setupAdminEvents(context);
    }, ERROR_MESSAGES.MODULE_INIT_FAILED);
}

export function initializeUsersOrchestratorModule(registry) {
    return createModuleInitializer(context, {
        initializeUserManagement,
    });
}

if (shouldInitializeForPageType('admin')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
} else {
    log(context, 'Skipping initialization for non-admin page');
}
admin/users-ui.js
import { log, warn, error as logError } from '../core/logger.js';
import { toggleViewState } from '../utils/dom-manipulation.js';
import { success, error } from '../core/notifications.js';
import { renderCheckboxList, renderDataTable, renderModal } from '../utils/ui-components.js';
import { SUCCESS_MESSAGES, ERROR_MESSAGES } from '../config/constants.js';
import { ROLES } from '../config/roles.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { loadUsers } from './users-data.js';
import { parsePageType, shouldInitializeForPageType } from '../utils/initialization.js';

const context = 'users-ui.js';

export async function renderRoleIcons(context) {
    const pageType = await parsePageType(context, 'page', 'admin');
    if (pageType !== 'admin') {
        log(context, `Skipping initialization for non-admin page type: ${pageType}`);
        return;
    }
    log(context, 'Rendering role icons for user management');
    const roles = [
        { name: 'admin', icon: 'fa-solid fa-headset', label: 'Admin' },
        { name: 'community', icon: 'fa-solid fa-people-group', label: 'Community' },
        { name: 'merchant', icon: 'fa-solid fa-user-tie', label: 'Merchant' },
        { name: 'partner', icon: 'fa-solid fa-palette', label: 'Partner' }
    ];
    const roleIconsContainer = document.getElementById('user_role_icon');
    if (!roleIconsContainer) {
        logError(context, 'User role icon container (user_role_icon) not found');
        error(context, 'User role icon container not found');
        return;
    }
    const roleTitleElement = document.getElementById('user_role_title');
    if (!roleTitleElement) {
        logError(context, 'User role title element (user_role_title) not found');
        error(context, 'User role title element not found');
        return;
    }
    roleIconsContainer.innerHTML = '';
    roles.forEach((role, index) => {
        const icon = document.createElement('i');
        icon.className = `${role.icon} affiliate-icon`;
        Object.assign(icon.style, {
            width: '24px',
            height: '24px',
            display: 'inline-block',            
            cursor: 'pointer'
        });
        icon.dataset.role = role.name;
        if (index === 0) icon.classList.add('selected');
        icon.addEventListener('click', async (event) => {
            event.preventDefault(); // Prevent any default behavior that might hide the section
            roleIconsContainer.querySelectorAll('.affiliate-icon').forEach(i => i.classList.remove('selected'));
            icon.classList.add('selected');
            roleTitleElement.textContent = role.label;
            const userData = await loadUsers(context, role.name);
            await renderUsersTable(context, userData, { 
                userManagement: document.getElementById('user_management'), 
                userList: document.getElementById('user_list') 
            });
            // Ensure the user_management section remains visible
            document.getElementById('user_management').style.display = 'block';
        });
        roleIconsContainer.appendChild(icon);
    });
    if (roles.length > 0) {
        const firstRole = roles[0];
        roleTitleElement.textContent = firstRole.label;
        const userData = await loadUsers(context, firstRole.name);
        await renderUsersTable(context, userData, { 
            userManagement: document.getElementById('user_management'), 
            userList: document.getElementById('user_list') 
        });
        // Ensure the user_management section remains visible on initial load
        document.getElementById('user_management').style.display = 'block';
    }
}

export async function renderUsersTable(context, { users, role }, { userManagement, userList }) {
    log(context, `Rendering users for role: ${role}`);
    if (!userList || userList.tagName.toLowerCase() !== 'tbody') {
        logError(context, 'Invalid table body element (userList)');
        throw new Error(ERROR_MESSAGES.INVALID_TABLE_BODY);
    }
    const parentTable = userList.closest('table');
    if (!parentTable) {
        logError(context, 'Parent table not found for userList');
        throw new Error(ERROR_MESSAGES.TABLE_NOT_FOUND);
    }
    toggleViewState(context, { userManagement: true });
    if (!users || !Array.isArray(users) || users.length === 0) {
        warn(context, `No users found for role ${role}`);
        userList.innerHTML = `<tr><td colspan="7">No users available for role ${role}. Please check the user database or contact support.</td></tr>`;
        log(context, 'Logging API response for debugging: /users/admin');
        const userData = await loadUsers(context, 'admin');
        log(context, `API response for /users/admin:`, userData);
        return;
    }
    const allowedPermissions = ROLES[role]?.permissions || [];
    const headers = ['ID', 'Name', 'Website', 'Email', 'Phone', 'Permissions', 'Actions'];
    const rowMapper = async (user) => {
        const normalizedUser = {
            userId: user.USERid || user.userId || 'N/A',
            contactName: user.contact_name || user.contactName || 'N/A',
            websiteUrl: user.website_url || user.websiteUrl || 'N/A',
            emailAddress: user.email_address || user.emailAddress || 'N/A',
            phoneNumber: user.phone_number || user.phoneNumber || 'N/A',
            permissions: Array.isArray(user.permissions) ? user.permissions : [],
        };
        const userPermissions = normalizedUser.permissions;
        const permissionsContainer = await renderCheckboxList(context, {
            items: allowedPermissions.map(perm => ({ value: perm, label: perm })),
            name: `permissions-${normalizedUser.userId}`,
            selected: userPermissions,
            dataAttributes: { userId: normalizedUser.userId, role },
            containerClass: 'permissions-list',
        });
        const modifyButton = document.createElement('button');
        modifyButton.className = 'modify-permissions';
        modifyButton.dataset.userId = normalizedUser.userId;
        modifyButton.dataset.role = role;
        modifyButton.textContent = 'Modify Permissions';
        return [
            normalizedUser.userId,
            normalizedUser.contactName,
            normalizedUser.websiteUrl,
            normalizedUser.emailAddress,
            normalizedUser.phoneNumber,
            permissionsContainer,
            modifyButton,
        ];
    };
    const tbody = await renderDataTable(context, {
        data: users,
        headers,
        rowMapper,
        emptyMessage: `No users available for role ${role}.`,
    });
    userList.innerHTML = '';
    while (tbody.firstChild) {
        userList.appendChild(tbody.firstChild);
    }
    if (userList.children.length === 0) {
        warn(context, 'Table body empty after rendering');
        userList.innerHTML = `<tr><td colspan="7">${ERROR_MESSAGES.USERS_RENDER_FAILED}</td></tr>`;
        error(context, ERROR_MESSAGES.USERS_RENDER_FAILED);
    } else {
        log(context, `Successfully rendered ${users.length} users for role ${role}`);
        //success(context, SUCCESS_MESSAGES.USERS_RENDERED);
    }
}

export async function renderPermissionsModal(context, userId, userData, role, formId = 'permissionsForm') {
    log(context, `Rendering modal for user ${userId} with role ${role}`);
    const allowedPermissions = ROLES[role]?.permissions || [];
    const currentPermissions = Array.isArray(userData.permissions) ? userData.permissions : [];
    const checkboxList = await renderCheckboxList(context, {
        items: allowedPermissions.map(perm => ({ value: perm, label: perm })),
        name: 'permissions',
        selected: currentPermissions,
        dataAttributes: { userId, role },
        containerClass: 'permissions-checkboxes',
    });
    const modal = await renderModal(context, {
        id: `permissionsModal-${userId}`,
        title: `Modify Permissions for User ${userId} (${role})`,
        content: checkboxList,
        formId,
        buttons: [
            { type: 'submit', text: 'Save', className: 'save' },
            { type: 'button', text: 'Cancel', className: 'cancel', onclick: 'this.closest(".modal").remove()' },
        ],
    });
    return modal;
}

export function initializeUsersUiModule(registry) {
    log(context, 'Initializing users UI module for module registry');
    return {
        renderRoleIcons: (ctx) => renderRoleIcons(ctx),
        renderUsersTable: (ctx, ...args) => renderUsersTable(ctx, ...args),
        renderPermissionsModal: (ctx, ...args) => renderPermissionsModal(ctx, ...args),
    };
}

if (shouldInitializeForPageType('admin')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
} else {
    log(context, 'Skipping initialization for non-admin page');
}
admin-page.js
// /static/js/admin-page.js
import { log, error as logError } from './core/logger.js';
import { initializeUserManagement } from './admin/users-orchestrator.js';
import { loadAffiliates } from './admin/affiliates.js';
import { loadSiteSettings } from './admin/site-settings.js';
import { initializeReferralTest } from './admin/referral-test.js';
import { initializeRoleNavigation, defineSectionHandlers as defineCommonSectionHandlers } from './modules/navigation.js';
import { getMenu } from './config/menus.js';
import { getElements, toggleViewState } from './utils/dom-manipulation.js';
import { withScriptLogging } from './utils/logging-utils.js';
import { getDefaultSectionFromQuery, parsePageType, shouldInitializeForPageType } from './utils/initialization.js';
import { setupAdminEvents } from './admin/admin-events.js';
import { error as notifyError } from './core/notifications.js';
import { renderPeriodIcons } from './admin/logs-ui.js';
import { loadSiteRequests } from './admin/site-requests.js';

const context = 'admin-page.js';

/**
 * Handles errors by logging them and displaying a notification.
 * @param {string} fnName - The name of the function where the error occurred.
 * @param {Error} error - The error object.
 * @param {string} [toastrMessage] - Optional custom message for the notification.
 */
function handleError(fnName, error, toastrMessage) {
    logError(context, `${fnName} - Error: ${error.message}`, error.stack);
    notifyError(context, toastrMessage || `Error in ${fnName}: ${error.message}`);
}

/**
 * Creates fallback content for unavailable sections.
 * @param {string} message - The message to display.
 * @returns {HTMLElement} The created div element.
 */
function createFallbackContent(message) {
    const div = document.createElement('div');
    div.innerHTML = `<p>${message}</p>`;
    return div;
}

/**
 * Initializes the admin page based on the page type.
 * @param {string} pageType - The type of page to initialize.
 */
export async function initializeAdmin(pageType) {
    const resolvedPageType = await parsePageType(context, 'page', 'admin');
    log(context, `initializeAdmin - Initializing admin page with type: ${resolvedPageType}`);
    if (resolvedPageType !== 'admin') {
        log(context, 'Skipping initialization for non-admin page');
        return;
    }
    try {
        const elements = await getElements(context, [
            'user_management', 'user_list', 'user_role_icon', 'user_role_title',
            'affiliate-icons', 'affiliate-settings-container', 'affiliate-static-content', 'affiliate-readme-content',
            'site-settings-icons', 'site-settings-form', 'site-settings-fields',
            'logs', 'logs-table-container', 'logs-description', 'logsIntro',
            'page_visit_test', 'order_test',
            'site-request-list', 'view-site-request', 'siteRequestForm'
        ]);

        Object.entries(elements).forEach(([key, value]) => {
            if (!value) logError(context, `DOM element not found: ${key}`);
        });

        const initFunctions = [
            {
                name: 'userManagement',
                fn: async () => {
                    log(context, 'Initializing User Management');
                    if (elements.user_management && elements.user_list && elements.user_role_icon && elements.user_role_title) {
                        await initializeUserManagement(context);
                    } else {
                        logError(context, 'Skipping User Management initialization due to missing elements');
                        notifyError(context, 'User Management section not properly configured');
                        document.getElementById('user_management')?.appendChild(createFallbackContent('User management unavailable'));
                    }
                }
            },
            {
                name: 'affiliates',
                fn: async () => {
                    log(context, 'Initializing Affiliates');
                    if (elements['affiliate-icons'] && elements['affiliate-settings-container'] && elements['affiliate-static-content']) {
                        await loadAffiliates(context);
                    } else {
                        logError(context, 'Skipping Affiliates initialization due to missing elements');
                        notifyError(context, 'Affiliates section not properly configured');
                        document.getElementById('affiliates')?.appendChild(createFallbackContent('Affiliate programs unavailable'));
                    }
                }
            },
            {
                name: 'siteSettings',
                fn: async () => {
                    log(context, 'Initializing Site Settings');
                    if (elements['site-settings-icons'] && elements['site-settings-form'] && elements['site-settings-fields']) {
                        await loadSiteSettings(context);
                    } else {
                        logError(context, 'Skipping Site Settings initialization due to missing elements');
                        notifyError(context, 'Site Settings section not properly configured');
                        document.getElementById('site_settings')?.appendChild(createFallbackContent('Site settings unavailable'));
                    }
                }
            },
            {
                name: 'siteRequests',
                fn: async () => {
                    log(context, 'Initializing Site Requests');
                    if (elements['site-request-list'] && elements['view-site-request'] && elements['siteRequestForm']) {
                        await loadSiteRequests(context);
                    } else {
                        logError(context, 'Skipping Site Requests initialization due to missing elements');
                        notifyError(context, 'Site Requests section not properly configured');
                        document.getElementById('site_requests')?.appendChild(createFallbackContent('Site requests unavailable'));
                    }
                }
            },
            {
                name: 'events',
                fn: async () => {
                    log(context, 'Setting up admin events');
                    await setupAdminEvents(context);
                }
            },
            {
                name: 'referralTest',
                fn: async () => {
                    log(context, 'Initializing Referral Test');
                    await initializeReferralTest(context);
                }
            }
        ];

        for (const { name, fn } of initFunctions) {
            try {
                await fn();
                log(context, `${name} initialized successfully`);
            } catch (error) {
                handleError(name, error, `Failed to initialize ${name} module`);
            }
        }

        const defaultSection = await getDefaultSectionFromQuery(context, 'admin', 'info');
        toggleViewState(context, { [defaultSection]: true });
        log(context, `Set default section to ${defaultSection}`);
    } catch (error) {
        handleError('initializeAdmin', error, 'Failed to initialize admin page');
    }
}

/**
 * Defines section handlers for the admin page.
 * @returns {Object} An object mapping section names to their handlers.
 */
function defineAdminSectionHandlers() {
    return {
        'info': async (show, role) => {
            log(context, 'Handler - Info triggered');
            toggleViewState(context, { info: show });
        },
        'user_management': async (show, role = 'admin') => {
            log(context, `Handler - User Management triggered with role: ${role}`);
            try {
                const elements = await getElements(context, ['user_management', 'user_list', 'user_role_icon', 'user_role_title']);
                if (!elements.user_management || !elements.user_list || !elements.user_role_icon || !elements.user_role_title) {
                    logError(context, 'Required user management elements not found');
                    notifyError(context, 'User management section not properly configured');
                    elements.user_management?.appendChild(createFallbackContent('User management unavailable due to configuration issues'));
                    return;
                }
                await initializeUserManagement(context);
                toggleViewState(context, { user_management: show, info: false });
                log(context, `User management initialized for role ${role}`);
            } catch (error) {
                handleError('user_management', error, 'Failed to load user management');
            }
        },
        'affiliates': async (show, role) => {
            log(context, 'Handler - Affiliates triggered');
            try {
                const elements = await getElements(context, ['affiliate-icons', 'affiliate-settings-container', 'affiliate-static-content', 'affiliate-readme-content']);
                if (!elements['affiliate-icons'] || !elements['affiliate-settings-container'] || !elements['affiliate-static-content']) {
                    logError(context, 'Required affiliates elements not found');
                    notifyError(context, 'Affiliates section not properly configured');
                    elements.affiliates?.appendChild(createFallbackContent('Affiliate programs unavailable due to configuration issues'));
                    return;
                }
                await loadAffiliates(context);
                toggleViewState(context, { affiliates: show, info: false });
                log(context, 'Affiliates section loaded');
            } catch (error) {
                handleError('affiliates', error, 'Failed to load affiliates');
            }
        },
        'site_settings': async (show, role) => {
            log(context, 'Handler - Site Settings triggered');
            try {
                const elements = await getElements(context, ['site-settings-icons', 'site-settings-form', 'site-settings-fields']);
                if (!elements['site-settings-icons'] || !elements['site-settings-form'] || !elements['site-settings-fields']) {
                    logError(context, 'Required site settings elements not found');
                    notifyError(context, 'Site settings section not properly configured');
                    elements.site_settings?.appendChild(createFallbackContent('Site settings unavailable due to configuration issues'));
                    return;
                }
                await loadSiteSettings(context);
                toggleViewState(context, { site_settings: show, info: false });
                log(context, 'Site settings section loaded');
            } catch (error) {
                handleError('site_settings', error, 'Failed to load site settings');
            }
        },
        'site_requests': async (show, role) => {
            log(context, 'Handler - Site Requests triggered');
            try {
                const elements = await getElements(context, ['site-request-list']);
                if (!elements['site-request-list']) {
                    logError(context, 'Required site requests elements not found');
                    notifyError(context, 'Site requests section not properly configured');
                    document.getElementById('site_requests')?.appendChild(createFallbackContent('Site requests unavailable due to configuration issues'));
                    return;
                }
                if (show) {
                    await loadSiteRequests(context);
                }
                toggleViewState(context, { site_requests: show, info: false, 'view-site-request': false });
                log(context, 'Site requests section loaded');
            } catch (error) {
                handleError('site_requests', error, 'Failed to load site requests');
            }
        },
        'view-site-request': async (show, role) => {
            log(context, 'Handler - View Site Request triggered');
            try {
                const elements = await getElements(context, ['view-site-request', 'siteRequestForm']);
                if (!elements['view-site-request'] || !elements['siteRequestForm']) {
                    logError(context, 'Required view site request elements not found');
                    notifyError(context, 'View site request section not properly configured');
                    document.getElementById('view-site-request')?.appendChild(createFallbackContent('View site request unavailable due to configuration issues'));
                    return;
                }
                toggleViewState(context, { 'view-site-request': show, site_requests: false, info: false });
                log(context, 'View site request section loaded');
            } catch (error) {
                handleError('view-site-request', error, 'Failed to load view site request');
            }
        },
        'userManagementIntro': async (show, role) => {
            log(context, 'Handler - User Management Intro triggered');
            toggleViewState(context, { userManagementIntro: show, info: false });
        },
        'testScriptsIntro': async (show, role) => {
            log(context, 'Handler - Test Scripts Intro triggered');
            toggleViewState(context, { testScriptsIntro: show, info: false });
        },
        'referralTestsIntro': async (show, role) => {
            log(context, 'Handler - Referral Tests Intro triggered');
            toggleViewState(context, { referralTestsIntro: show, info: false });
        },
        'page_visit_test': async (show, role) => {
            log(context, 'Handler - Page Visit Test triggered');
            toggleViewState(context, { page_visit_test: show, info: false });
        },
        'order_test': async (show, role) => {
            log(context, 'Handler - Order Test triggered');
            toggleViewState(context, { order_test: show, info: false });
        },
        'test_partner': async (show, role) => {
            log(context, 'Handler - Test Partner triggered');
            toggleViewState(context, { test_partner: show, info: false });
        },
        'test_merchant': async (show, role) => {
            log(context, 'Handler - Test Merchant triggered');
            toggleViewState(context, { test_merchant: show, info: false });
        },
        'test_community': async (show, role) => {
            log(context, 'Handler - Test Community triggered');
            toggleViewState(context, { test_community: show, info: false });
        },
        'logsIntro': async (show, role) => {
            log(context, 'Handler - Logs Intro triggered');
            toggleViewState(context, { logsIntro: show, info: false });
        },
        'logs': async (show, role, type) => {
            log(context, `Handler - Logs triggered with type: ${type}`);
            if (show) {
                toggleViewState(context, { logs: true, info: false });
                if (type) {
                    const logsSection = document.getElementById('logs');
                    logsSection.dataset.type = type;
                    renderPeriodIcons();
                } else {
                    logError(context, 'No log type specified for logs section');
                    notifyError(context, 'Log type not specified');
                }
            } else {
                toggleViewState(context, { logs: false });
            }
        },
    };
}

// Initialize the admin page if the page type is 'admin'
if (shouldInitializeForPageType('admin')) {
    document.addEventListener('DOMContentLoaded', async () => {
        log(context, 'admin-page.js - DOMContentLoaded, initializing');
        try {
            const role = 'admin';
            const defaultSection = await getDefaultSectionFromQuery(context, role, 'info');

            const commonHandlers = defineCommonSectionHandlers(context, role);
            const adminHandlers = defineAdminSectionHandlers();
            const sectionHandlers = { ...commonHandlers, ...adminHandlers };

            const menuElement = document.getElementById('menu');
            if (menuElement) {
                const menu = getMenu('admin');
                log(context, `Menu items: ${menu.map(item => item.section).join(', ')}`);
                await initializeRoleNavigation(menuElement, menu, { sectionHandlers, defaultSection });
                log(context, `Triggering default section: ${defaultSection}`);
                if (sectionHandlers[defaultSection]) {
                    await sectionHandlers[defaultSection](true, role);
                } else {
                    logError(context, `No handler for default section: ${defaultSection}`);
                    await sectionHandlers.info(true, role);
                }
            } else {
                logError(context, 'Menu element not found');
                notifyError(context, 'Navigation menu not found');
                toggleViewState(context, { info: true });
            }

            document.addEventListener('sectionChange', async (e) => {
                const { section, role, type } = e.detail || {};
                log(context, `sectionChange - Section: ${section}, Role: ${role}, Type: ${type || 'none'}`);
                const handler = sectionHandlers[section];
                if (handler) {
                    await handler(true, role, type);
                } else {
                    logError(context, `No handler for section: ${section}`);
                    notifyError(context, `Section ${section} not found`);
                    await sectionHandlers.info(true, role);
                }
            });

            await initializeAdmin('admin');
        } catch (error) {
            handleError('navigationSetup', error, 'Failed to set up navigation');
            toggleViewState(context, { info: true });
        }
    });
} else {
    log(context, 'Skipping initialization for non-admin page');
}

// Expose functions to the global scope
window.handleError = handleError;
window.initializeAdmin = initializeAdmin;

/**
 * Initializes the admin page module for a registry.
 * @param {Object} registry - The module registry.
 * @returns {Object} The module interface.
 */
export function initializeAdminPageModule(registry) {
    log(context, 'Initializing admin page module for module registry');
    return {
        initializeAdmin: (pageType) => initializeAdmin(pageType),
    };
}

// Log script initialization
withScriptLogging(context, () => {
    log(context, 'Module initialized');
});
community/categories-data.js
// /static/js/community/categories-data.js
import { log } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { withErrorHandling } from '../utils/error.js';
import { validateUserId } from '../core/user.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { createModuleInitializer, shouldInitializeForPageType } from '../utils/initialization.js';

const context = 'categories-data.js';

const state = {
    cumulativeDeselections: [],
};

export async function loadCategories(context, userId, isAdmin = false) {
    log(context, `Loading categories for user: ${userId}, isAdmin: ${isAdmin}`);
    return await withErrorHandling(`${context}:loadCategories`, async () => {
        await validateUserId(context);
        const data = await fetchData(context, API_ENDPOINTS.CATEGORIES, { method: 'GET' });
        return {
            categories: data.categories || {},
            deselected: data.deselected || [],
            previousDeselected: data.previousDeselected || [],
            prompt: data.prompt || '',
            selected: data.selected || [],
        };
    }, ERROR_MESSAGES.FETCH_FAILED('categories'), () => ({
        categories: {},
        deselected: [],
        previousDeselected: [],
        selected: [],
        prompt: '',
    }));
}

export async function saveCategories(context, data) {
    log(context, 'Saving categories');
    return await withErrorHandling(`${context}:saveCategories`, async () => {
        return await fetchData(context, API_ENDPOINTS.SAVE_CATEGORIES, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data),
        });
    }, ERROR_MESSAGES.FETCH_FAILED('categories save'));
}

export async function resetCategories(context, userId) {
    log(context, `Resetting categories for user: ${userId}`);
    return await withErrorHandling(`${context}:resetCategories`, async () => {
        await validateUserId(context);
        return await fetchData(context, API_ENDPOINTS.RESET_CATEGORIES, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ userId }),
        });
    }, ERROR_MESSAGES.FETCH_FAILED('categories reset'));
}

export function mergeDeselections(context, newDeselections) {
    if (Array.isArray(newDeselections)) {
        log(context, 'Merging new deselections:', newDeselections);
        state.cumulativeDeselections = [...new Set([...state.cumulativeDeselections, ...newDeselections])];
    }
    return state.cumulativeDeselections;
}

export function getCumulativeDeselections(context) {
    log(context, 'Retrieving cumulative deselections');
    return state.cumulativeDeselections;
}

export function updateDeselectedCategories(context, selectedCategories, allCategories) {
    log(context, 'Updating deselected categories');
    return withErrorHandling(`${context}:updateDeselectedCategories`, () => {
        const newDeselections = allCategories.filter(cat => !selectedCategories.includes(cat));
        mergeDeselections(context, newDeselections);
        return {
            deselected: newDeselections,
            previousDeselected: getCumulativeDeselections(context),
        };
    }, ERROR_MESSAGES.DATA_PROCESSING_FAILED, () => ({
        deselected: [],
        previousDeselected: [],
    }));
}

export function transformCategoriesData(formData) {
    log(context, 'Transforming categories form data');
    return {
        prompt: formData.get('prompt')?.trim(),
        categories: JSON.parse(formData.get('categories') || '{}'),
        deselected: JSON.parse(formData.get('deselected') || '[]'),
        previousDeselected: JSON.parse(formData.get('previousDeselected') || '[]'),
        selected: formData.getAll ? formData.getAll('selected') : [],
    };
}

export function validateCategoriesData(formData) {
    log(context, 'Validating categories form data');
    return !!formData.get('prompt')?.trim();
}

export function initializeCategoriesDataModule(registry) {
    return createModuleInitializer(context, {
        loadCategories,
        saveCategories,
        resetCategories,
        mergeDeselections,
        getCumulativeDeselections,
        updateDeselectedCategories,
        transformCategoriesData,
        validateCategoriesData,
    });
}

if (shouldInitializeForPageType('community')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
} else {
    log(context, 'Skipping initialization for non-community page');
}
community/categories-events.js
// /static/js/community/categories-events.js
import { log, warn } from '../core/logger.js';
import { setupEventListeners } from '../utils/event-listeners.js';
import { submitConfiguredForm, updateFormState } from '../utils/form-submission.js';
import { updateDeselectedCategories } from './categories-data.js';
import { updateCategoriesSection } from './categories-ui.js';
import { withElement } from '../utils/dom-manipulation.js';
import { notifyOperationResult } from '../core/notifications.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { API_ENDPOINTS } from '../config/endpoints.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { createModuleInitializer, shouldInitializeForPageType } from '../utils/initialization.js';

const context = 'categories-events.js';

/**
 * Sets up event listeners for the category form, ensuring form submission is captured via fetch.
 * @param {string} context - The context for logging and error handling.
 * @param {Object} elements - The DOM elements object containing references to UI components.
 */
export function setupCategoryEvents(context, elements) {
    log(context, 'Setting up category form event listeners');
    withErrorHandling(`${context}:setupCategoryEvents`, () => {
        // Ensure form exists
        const formElement = document.querySelector('#category-form');
        if (!formElement || !(formElement instanceof HTMLElement)) {
            warn(context, 'Form #category-form not found or invalid during event setup');
            notifyOperationResult(context, {
                success: false,
                message: 'Form not found. Please refresh the page.',
                defaultError: ERROR_MESSAGES.ELEMENT_NOT_FOUND,
            });
            return;
        }

        // Prevent duplicate submit listeners
        if (formElement.dataset.submitListenerAttached) {
            log(context, 'Submit listener already attached to #category-form, skipping');
            return;
        }

        // Main submit handler
        const submitHandler = async (event) => {
            log(context, 'Submit event triggered for #category-form');
            event.preventDefault(); // Prevent direct form submission
            event.stopPropagation(); // Prevent bubbling to other listeners
            log(context, 'Default form submission prevented');

            try {
                log(context, 'Before submitConfiguredForm');
                await submitConfiguredForm(context, 'category-form', API_ENDPOINTS.CATEGORIES, 'categories', {
                    successMessage: SUCCESS_MESSAGES.CATEGORIES_SUBMITTED,
                    onSuccess: (data) => {
                        log(context, 'onSuccess called with data:', data);
                        updateCategoriesSection(context, data, elements);
                    },
                    onError: (error, formData) => {
                        log(context, 'onError called with error:', error.message);
                        updateCategoriesSection(context, {
                            categories: JSON.parse(formData.get('categories') || '{}'),
                            deselected: JSON.parse(formData.get('deselected') || '[]'),
                            previousDeselected: JSON.parse(formData.get('previousDeselected') || '[]'),
                            selected: formData.getAll ? formData.getAll('selected') : [],
                            prompt: formData.get('prompt') || '',
                            errorMessage: error.message,
                        }, elements);
                    },
                });
                log(context, 'After submitConfiguredForm');
            } catch (error) {
                log(context, 'Error in submit handler:', error.message);
                notifyOperationResult(context, {
                    success: false,
                    message: error.message || ERROR_MESSAGES.FORM_SUBMISSION_FAILED,
                });
            } finally {
                log(context, 'Submit handler completed');
            }
        };

        // Attach listener directly to the form
        formElement.addEventListener('submit', submitHandler);

        // Delegated listener on document to catch dynamic forms
        document.addEventListener('submit', (event) => {
            const targetForm = event.target;
            if (targetForm && targetForm.id === 'category-form' && !event.defaultPrevented) {
                log(context, 'Delegated submit event triggered for #category-form');
                submitHandler(event);
            }
        });

        // Fallback: Prevent direct submission if all else fails
        formElement.addEventListener('submit', (event) => {
            if (!event.defaultPrevented) {
                log(context, 'Fallback: Preventing direct form submission for #category-form');
                event.preventDefault();
                event.stopPropagation();
            }
        });

        // Use setupEventListeners for other events
        setupEventListeners(context, [
            // Click handler for "Save Categories" button
            {
                eventType: 'click',
                selector: '[data-action="save-categories"]',
                handler: async () => {
                    await withErrorHandling(`${context}:saveCategories`, async () => {
                        await submitConfiguredForm(context, 'category-form', API_ENDPOINTS.SAVE_CATEGORIES, 'categories', {
                            onSuccess: (data) => updateCategoriesSection(context, data, elements),
                        });
                    }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
                },
            },
            // Click handler for "Reset Categories" button
            {
                eventType: 'click',
                selector: '[data-action="reset-categories"]',
                handler: async () => {
                    await withErrorHandling(`${context}:resetCategories`, async () => {
                        await submitConfiguredForm(context, 'reset-categories-form', API_ENDPOINTS.RESET_CATEGORIES, 'resetCategories', {
                            onSuccess: (data) => updateCategoriesSection(context, data, elements),
                        });
                    }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
                },
            },
            // Change handler for category checkboxes
            {
                eventType: 'change',
                selector: 'input[data-deselected]',
                handler: async () => {
                    await withErrorHandling(`${context}:updateDeselections`, async () => {
                        await withElement(context, 'deselected', async (deselectedInput) => {
                            await withElement(context, 'previousDeselected', async (previousDeselectedInput) => {
                                const allCategories = Array.from(document.querySelectorAll('input[name="selected"]')).map(cb => cb.value);
                                const selectedCategories = Array.from(document.querySelectorAll('input[name="selected"]:checked')).map(cb => cb.value);
                                const { deselected, previousDeselected } = updateDeselectedCategories(context, selectedCategories, allCategories);
                                await updateFormState(context, 'category-form', {
                                    deselected: JSON.stringify(deselected),
                                    previousDeselected: JSON.stringify(previousDeselected),
                                });
                                log(context, 'Updated deselections:', deselected);
                            });
                        }, 10, 100, true);
                    }, ERROR_MESSAGES.DATA_PROCESSING_FAILED);
                },
            },
        ]);

        // Mark form as having a submit listener
        formElement.dataset.submitListenerAttached = 'true';
        log(context, 'Submit event listener attached to #category-form');
    }, ERROR_MESSAGES.EVENT_HANDLER_FAILED);
}

/**
 * Initializes the categories events module for use with a registry.
 * @param {object} registry - The registry for module initialization.
 * @returns {object} The initialized module.
 */
export function initializeCategoriesEventsModule(registry) {
    return createModuleInitializer(context, {
        setupCategoryEvents,
    });
}

// Initialize the module if on a community page
if (shouldInitializeForPageType('community')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
        // Note: setupCategoryEvents is called from categories-page.js with elements
    });
} else {
    log(context, 'Skipping initialization for non-community page');
}
community/categories-navigation.js
// /static/js/community/categories-navigation.js
import { log } from '../core/logger.js';
import { defineSectionHandlers } from '../modules/navigation.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { toggleViewState } from '../utils/dom-manipulation.js';
import { shouldInitializeForPageType } from '../utils/initialization.js';

const context = 'categories-navigation.js';

export async function setupCategoriesNavigation(context, role, defaultSection) {
    log(context, `Setting up navigation for role ${role}, section ${defaultSection}`);
    await withErrorHandling(`${context}:setupCategoriesNavigation`, async () => {
        defineSectionHandlers(context, 'community', [
            {
                id: 'info',
                handler: async () => {
                    log(context, 'Loading info section');
                    toggleViewState(context, { info: true });
                },
            },
            {
                id: 'categories',
                handler: async () => {
                    log(context, 'Loading categories section');
                    await import('./categories-page.js').then(m => m.initializeCategoriesPage(context));
                },
            },
            {
                id: 'providers',
                handler: async () => {
                    log(context, 'Loading providers section');
                    await import('./providers-page.js').then(m => m.initializeProvidersPage(context));
                },
            },
            {
                id: 'referrals',
                handler: async () => {
                    log(context, 'Loading referrals section');
                    await import('./referrals-page.js').then(m => m.initializeReferralsPage(context));
                },
            },
        ]);
    }, ERROR_MESSAGES.NAVIGATION_INIT_FAILED);
}

export function initializeCategoriesNavigationModule(registry) {
    log(context, 'Initializing categories-navigation module for module registry');
    return {
        setupCategoriesNavigation: (ctx, ...args) => setupCategoriesNavigation(ctx, ...args),
    };
}

if (shouldInitializeForPageType('community')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
} else {
    log(context, 'Skipping initialization for non-community page');
}
community/categories-page.js
// /static/js/community/categories-page.js
import { log, warn } from '../core/logger.js';
import { loadCategories } from './categories-data.js';
import { renderCategoriesSection } from './categories-ui.js';
import { setupCategoryEvents } from './categories-events.js';
import { withAuthenticatedUser } from '../core/auth.js';
import { setupCategoriesNavigation } from './categories-navigation.js';
import { getElements, elementCache } from '../utils/dom-manipulation.js';
import { initializeTinyMCE } from '../core/mce.js';
import { error as notifyError } from '../core/notifications.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withErrorHandling } from '../utils/error.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { shouldInitializeForPageType } from '../utils/initialization.js';

const context = 'categories-page.js';

/**
 * Initializes the categories page, ensuring proper navigation, data loading, UI rendering, and event setup.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeCategoriesPage(context) {
    log(context, 'Initializing categories page');

    // Ensure the user is authenticated before proceeding
    await withAuthenticatedUser(context, async (userId) => {
        await withErrorHandling(`${context}:initializeCategoriesPage`, async () => {
            // Set up navigation for the categories page
            await setupCategoriesNavigation(context, 'community', 'categories');

            // Load categories data for the authenticated user
            const data = await loadCategories(context, userId, false);

            // Clear element cache to avoid stale references
            elementCache.clear();
            log(context, 'Cleared element cache before fetching elements');

            // Fetch required DOM elements with retries
            const elements = await getElements(context, ['categories', 'category-form', 'category-error', 'prompt'], 5, 100);

            // Define required elements for validation
            const requiredElements = ['categories', 'category-form', 'category-error', 'prompt'];

            // Check for missing or invalid elements
            const missingElements = requiredElements.filter(key => !elements[key] || !(elements[key] instanceof HTMLElement));
            if (missingElements.length > 0) {
                warn(context, `Missing or invalid elements: ${missingElements.join(', ')}`);
                missingElements.forEach(key => {
                    elementCache.delete(key);
                    log(context, `Cleared cache for invalid element: ${key}`);
                });

                // Fallback for missing prompt element
                if (missingElements.includes('prompt')) {
                    log(context, 'Creating fallback prompt element');
                    elements.prompt = document.createElement('textarea');
                    elements.prompt.id = 'prompt';
                    elements.prompt.name = 'prompt';
                    document.body.appendChild(elements.prompt);
                }

                const errorContainer = elements['category-error'] || document.getElementById('category-error');
                if (errorContainer) {
                    errorContainer.textContent = `Missing elements: ${missingElements.join(', ')}. Please refresh the page.`;
                    errorContainer.style.display = 'block';
                }
                notifyError(context, 'Required elements missing. Please refresh the page.', { preventDuplicate: true });
                return;
            }

            // Log element details for debugging
            requiredElements.forEach(key => {
                log(context, `Element ${key}: ${elements[key] ? `Found (ID: ${elements[key].id})` : 'Not found'}`);
            });

            // Validate error container before rendering
            if (!elements['category-error'] || !document.body.contains(elements['category-error'])) {
                warn(context, 'category-error element is invalid or disconnected');
                notifyError(context, 'Error display element missing. Please refresh the page.', { preventDuplicate: true });
                return;
            }

            // Render the categories section
            try {
                await renderCategoriesSection(context, data, {
                    categoriesSection: elements.categories,
                    formContainer: elements['category-form'],
                    errorDiv: elements['category-error'],
                    promptInput: elements.prompt,
                });
            } catch (err) {
                warn(context, `Render failed: ${err.message}`);
                notifyError(context, `Render failed: ${err.message}. Please refresh the page.`, { preventDuplicate: true });
                return;
            }

            // Set up form event listeners to prevent automatic submission
            const formElement = elements['category-form'];
            if (formElement && formElement instanceof HTMLElement) {
                log(context, 'Form #category-form found, setting up events');

                // Ensure event listeners are attached only once
                if (!formElement.dataset.submitListenerAttached) {
                    // Prevent default form submission
                    formElement.addEventListener('submit', (event) => {
                        log(context, 'Submit event triggered for #category-form');
                        event.preventDefault(); // Stop automatic submission
                        event.stopPropagation(); // Prevent event bubbling
                        log(context, 'Default form submission prevented');

                        // Add custom submission logic here if needed
                        // Example: validateFormAndSubmit(context, formElement);
                    });

                    // Mark listener as attached
                    formElement.dataset.submitListenerAttached = 'true';
                    log(context, 'Event listeners attached to #category-form');
                } else {
                    log(context, 'Submit listener already attached, skipping');
                }
            } else {
                warn(context, 'Form #category-form not found or invalid');
                notifyError(context, 'Form not found. Please refresh the page.', { preventDuplicate: true });
                return;
            }

            // Initialize TinyMCE with a delay for DOM readiness
            setTimeout(async () => {
                const selectors = ['#aboutCommunity', '#stylingDetails', '#page1Content'].filter(selector => document.querySelector(selector));
                if (selectors.length > 0) {
                    await initializeTinyMCE(context, selectors.join(','));
                } else {
                    warn(context, 'No TinyMCE targets found');
                }
            }, 100);
        }, ERROR_MESSAGES.FETCH_FAILED('categories page initialization'), (err) => {
            warn(context, `Initialization failed: ${err.message}`);
            const errorContainer = document.getElementById('category-error');
            if (errorContainer) {
                errorContainer.textContent = 'Failed to initialize categories. Please try again later.';
                errorContainer.style.display = 'block';
            }
        });
    }, 'initializeCategoriesPage');
}

if (shouldInitializeForPageType('community')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
        document.addEventListener('DOMContentLoaded', () => {
            initializeCategoriesPage(context);
        });
    });
} else {
    log(context, 'Skipping initialization for non-community page');
}
community/categories-ui.js
// /static/js/community/categories-ui.js
import { log, warn } from '../core/logger.js';
import { toggleViewState } from '../utils/dom-manipulation.js';
import { success, error } from '../core/notifications.js';
import { renderForm } from '../utils/form-rendering.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { getFormConfig } from '../config/form-configs.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { shouldInitializeForPageType } from '../utils/initialization.js';

const context = 'categories-ui.js';

function isValidCategories(categories) {
    return (
        typeof categories === 'object' &&
        !Array.isArray(categories) &&
        Object.keys(categories).length > 0 &&
        Object.keys(categories).length <= 7 &&
        Object.values(categories).every(
            subcats =>
                Array.isArray(subcats) &&
                subcats.length >= 1 &&
                subcats.length <= 7 &&
                subcats.every(s => typeof s === 'string'),
        )
    );
}

export async function renderCategoriesSection(context, data, { categoriesSection, formContainer, errorDiv, promptInput }) {
    log(context, 'Rendering categories section with data:', data);
    toggleViewState(context, { [errorDiv.id]: false });
    errorDiv.textContent = '';
    if (data.errorMessage) {
        errorDiv.textContent = data.errorMessage;
        toggleViewState(context, { [errorDiv.id]: true });
        error(context, data.errorMessage);
    }
    const currentPrompt = promptInput.value || data.prompt || '';
    data.categories = data.categories || {};
    const formConfig = getFormConfig(context, 'categories', {
        currentPrompt,
        deselected: data.deselected || [],
        previousDeselected: data.previousDeselected || [],
        selected: data.selected || [],
        categories: data.categories,
        isValidCategories: isValidCategories(data.categories),
    });
    formContainer.innerHTML = renderForm(formConfig);
    success(context, SUCCESS_MESSAGES.CATEGORIES_RENDERED);
}

export async function updateCategoriesSection(context, data, elements) {
    log(context, 'Updating categories section with data:', data);
    await renderCategoriesSection(context, data, elements);
}

export function initializeCategoriesUiModule(registry) {
    log(context, 'Initializing categories UI module for module registry');
    return {
        renderCategoriesSection: (ctx, ...args) => renderCategoriesSection(ctx, ...args),
        updateCategoriesSection: (ctx, ...args) => updateCategoriesSection(ctx, ...args),
    };
}

if (shouldInitializeForPageType('community')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
} else {
    log(context, 'Skipping initialization for non-community page');
}
community/community-providers.js
// /static/js/community/community-providers.js
import { log } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { withAuthenticatedUser } from '../core/auth.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { initializeProvidersPage } from './providers-page.js';
import { setupCategoriesNavigation } from './categories-navigation.js';
import { setupCollapsibleSections } from '../utils/dom-manipulation.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { shouldInitializeForPageType } from '../utils/initialization.js';

const context = 'community-providers.js';

export function initializeProviders(context) {
    log(context, 'Initializing providers page');
    withErrorHandling(`${context}:initializeProviders`, () => {
        withAuthenticatedUser(context, async (userId) => {  // Fixed syntax with parentheses
            const userIdInput = document.getElementById('userId');
            if (userIdInput) userIdInput.value = userId;
            setupCategoriesNavigation(context, 'community', 'providers');
            initializeProvidersPage(context);
            setupCollapsibleSections(context);
        }, 'initializeProviders');
    }, ERROR_MESSAGES.FETCH_FAILED('providers page initialization'));
}

export function initializeCommunityProvidersModule(registry) {
    log(context, 'Initializing community providers module for module registry');
    return {
        initializeProviders: (ctx) => initializeProviders(ctx),
    };
}

if (shouldInitializeForPageType('community')) {
    withScriptLogging(context, () => {
        initializeProviders(context);
    });
} else {
    log(context, 'Skipping initialization for non-community page');
}
community/navigation.js
// File path: /static/js/community/navigation.js
import { log, error as logError } from '../core/logger.js';
import { defineSectionHandlers } from '../modules/navigation.js';
import { toggleViewState } from '../utils/dom-manipulation.js';
import { renderMarkdown } from '../core/markdown.js';
import { initializeCategoriesPage } from './categories-page.js';
import { initializeProvidersPage } from './providers-page.js';
import { initializeReferralsPage } from './referrals-page.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { initializeSiteRequest } from '../modules/site-request.js';
import { error as notifyError } from '../core/notifications.js';

const context = 'community/navigation.js';

// Define arrays for section management
const topLevelSections = ['info', 'categories', 'logs', 'my_website_intro_section', 'no_website'];
const allSections = ['info', 'categories', 'logs', 'my_website_intro_section', 'no_website', 'providers'];

// Function to define handlers for each section in the community interface
export function defineCommunitySectionHandlers(contextParameter) {
    log(contextParameter, 'Defining section handlers for the community interface');

    const specificHandlers = [
        {
            id: 'info',
            handler: async function() {
                log(contextParameter, 'Loading the information section');
                const state = allSections.reduce(function(accumulator, section) {
                    accumulator[section] = section === 'info';
                    return accumulator;
                }, {});
                toggleViewState(contextParameter, state);
            },
        },
        {
            id: 'categories',
            handler: async function() {
                log(contextParameter, 'Loading the categories section');
                await initializeCategoriesPage(contextParameter);
                const state = allSections.reduce(function(accumulator, section) {
                    accumulator[section] = section === 'categories';
                    return accumulator;
                }, {});
                toggleViewState(contextParameter, state);
            },
        },
        {
            id: 'providers',
            handler: async function() {
                log(contextParameter, 'Loading the providers section');
                await initializeProvidersPage(contextParameter);
                const state = allSections.reduce(function(accumulator, section) {
                    accumulator[section] = section === 'providers';
                    return accumulator;
                }, {});
                toggleViewState(contextParameter, state);
            },
        },
        {
            id: 'logs',
            handler: async function(show, role, type) {
                log(contextParameter, `Loading logs section with type: ${type || 'none'}`);
                if (show) {
                    if (!type || !['click', 'order'].includes(type)) {
                        logError(contextParameter, `Invalid or missing log type: ${type}`);
                        notifyError(contextParameter, 'Please select a log type (Click or Order Events)');
                        toggleViewState(contextParameter, { logs: false, logsIntro: true });
                        return;
                    }

                    const logsSection = document.getElementById('logs');
                    if (!logsSection) {
                        logError(contextParameter, 'Logs section element not found');
                        notifyError(contextParameter, 'Logs section not found');
                        return;
                    }

                    logsSection.dataset.type = type;
                    log(contextParameter, `Set data-type="${type}" on logs section`);

                    toggleViewState(contextParameter, { logs: true, info: false });

                    try {
                        await initializeReferralsPage(type);
                        const { renderPeriodIcons } = await import('./referrals-ui.js');
                        renderPeriodIcons();
                        log(contextParameter, `Initialized logs UI for type: ${type}`);
                    } catch (err) {
                        logError(contextParameter, `Failed to initialize logs UI: ${err.message}`);
                        notifyError(contextParameter, 'Failed to load logs');
                    }
                } else {
                    toggleViewState(contextParameter, { logs: false });
                }
            },
        },
        {
            id: 'my_website_intro_section',
            handler: async function() {
                log(contextParameter, 'Loading the my website introduction section');
                await withErrorHandling(`${contextParameter}:my_website_intro_section`, async function() {
                    const { initializeProviders } = await import('./community-providers.js');
                    await initializeProviders(contextParameter);
                    await withElement(contextParameter, 'markdown-content', async function(section) {
                        try {
                            const htmlContent = await renderMarkdown(contextParameter, '/static/md/link_my_website.md');
                            section.innerHTML = htmlContent;
                            const state = allSections.reduce(function(accumulator, sectionIdentifier) {
                                accumulator[sectionIdentifier] = sectionIdentifier === 'my_website_intro_section';
                                return accumulator;
                            }, {});
                            toggleViewState(contextParameter, state);
                        } catch (error) {
                            log(contextParameter, `Failed to render markdown content: ${error.message}`);
                            section.innerHTML = '<p>Error: Unable to load website integration guide.</p>';
                        }
                    }, 3, 50, false);
                }, ERROR_MESSAGES.MARKDOWN_RENDER_FAILED);
            },
        },
        {
            id: 'no_website',
            handler: async function() {
                log(contextParameter, 'Loading the no website section');
                await withErrorHandling(`${contextParameter}:no_website`, async function() {
                    await initializeSiteRequest(contextParameter, 'no_website');
                }, 'Failed to initialize the site request');
            },
        },
    ];

    const sectionHandlers = defineSectionHandlers(contextParameter, 'community', specificHandlers);
    return sectionHandlers;
}

// Function to initialize the navigation module for the registry
export function initializeNavigationModule(registry) {
    log(context, 'Initializing the navigation module for the module registry');
    return {
        defineCommunitySectionHandlers: function(contextParameter) {
            return defineCommunitySectionHandlers(contextParameter);
        },
    };
}

// Execute script logging
withScriptLogging(context, function() {
    log(context, 'Module has been initialized');
});
community/providers-data.js
// /static/js/community/providers-data.js
import { log } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { shouldInitializeForPageType } from '../utils/initialization.js';

const context = 'providers-data.js';

/**
 * Fetches client API settings from the /settings/client_api endpoint.
 * @param {string} context - The context or module name.
 * @returns {Promise<Array>} The fetched settings data.
 * @throws {Error} If the data is missing or invalid.
 */
export async function loadClientApiSettings(context) {
    log(context, 'Loading client API settings');
    return await withErrorHandling(`${context}:loadClientApiSettings`, async () => {
        const data = await fetchData(context, API_ENDPOINTS.CLIENT_API_SETTINGS);
        if (!data.settings || !Array.isArray(data.settings) || data.settings.length === 0) {
            throw new Error('Settings data is missing or invalid');
        }
        return data.settings;
    });
}

if (shouldInitializeForPageType('community')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
} else {
    log(context, 'Skipping initialization for non-community page');
}
community/providers-events.js
// /static/js/community/providers-events.js
import { log, warn } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { withElement } from '../utils/dom-manipulation.js';
import { withScriptLogging } from '../utils/logging-utils.js';

const context = 'providers-events.js';

/**
 * Renders provider settings into the DOM, with icons styled similarly to the affiliates page.
 * @param {string} context - The context or module name.
 * @param {Array} settings - The settings data to render.
 * @param {string} iconsBarId - The ID of the icons bar container.
 * @param {string} contentAreaId - The ID of the content area container.
 * @returns {Promise<void>}
 */
export async function renderProviderSettings(context, settings, iconsBarId, contentAreaId) {
    log(context, 'Rendering provider settings');
    return await withErrorHandling(`${context}:renderProviderSettings`, async () => {
        const iconsBar = await withElement(context, iconsBarId, (element) => element);
        if (!iconsBar) {
            throw new Error(`Icons bar element (${iconsBarId}) not found`);
        }
        const contentArea = await withElement(context, contentAreaId, (element) => element);
        if (!contentArea) {
            throw new Error(`Content area element (${contentAreaId}) not found`);
        }

        iconsBar.innerHTML = '';
        contentArea.innerHTML = '';

        // Function to render provider details (header, description, readme)
        async function renderProviderDetails(setting) {
            contentArea.innerHTML = '';

            // Create header with icon, title, and links
            const header = document.createElement('div');
            header.style.display = 'flex';
            header.style.alignItems = 'center';
            header.style.marginBottom = '15px';

            const icon = document.createElement('i');
            icon.className = setting.icon || 'fas fa-cog';
            icon.style.fontSize = '16px';
            icon.style.marginRight = '10px';
            header.appendChild(icon);

            const title = document.createElement('h3');
            title.textContent = setting.comment || `${setting.key_type} Instructions`;
            title.style.margin = '0';
            header.appendChild(title);

            const linksContainer = document.createElement('div');
            linksContainer.style.marginLeft = 'auto';
            linksContainer.style.display = 'flex';
            linksContainer.style.gap = '10px';

            setting.doc_link.forEach(doc => {
                const linkElement = document.createElement('a');
                linkElement.href = doc.link;
                linkElement.target = '_blank';
                linkElement.title = doc.title;
                linkElement.innerHTML = `<i class="fas fa-${doc.title === 'api' ? 'link' : doc.title === 'signup' ? 'user-plus' : 'book'}"></i>`;
                linksContainer.appendChild(linkElement);
            });
            header.appendChild(linksContainer);

            // Add description
            const description = document.createElement('p');
            description.textContent = setting.description || 'No description available';
            description.style.marginBottom = '15px';

            contentArea.appendChild(header);
            contentArea.appendChild(description);

            // Fetch and render readme content
            const readmeLink = setting.doc_link.find(link => link.title === 'readme');
            if (readmeLink && readmeLink.link) {
                const response = await fetch(readmeLink.link);
                if (response.ok) {
                    const markdown = await response.text();
                    const readmeContent = document.createElement('div');
                    readmeContent.innerHTML = window.marked.parse(markdown);
                    contentArea.appendChild(readmeContent);
                } else {
                    const errorP = document.createElement('p');
                    errorP.textContent = 'Failed to load readme';
                    contentArea.appendChild(errorP);
                }
            } else {
                const noReadmeP = document.createElement('p');
                noReadmeP.textContent = 'No readme available';
                contentArea.appendChild(noReadmeP);
            }
        }

        // Render provider icons with selection behavior
        settings.forEach(setting => {
            const icon = document.createElement('i');
            icon.className = `${setting.icon || 'fas fa-cog'} provider-icon`;
            icon.dataset.keyType = setting.key_type;
            icon.addEventListener('click', async () => {
                // Remove 'selected' from all provider icons
                iconsBar.querySelectorAll('.provider-icon').forEach(i => i.classList.remove('selected'));
                // Add 'selected' to the clicked icon
                icon.classList.add('selected');
                // Render provider details
                await renderProviderDetails(setting);
            });
            iconsBar.appendChild(icon);
        });

        // Select and render the first provider by default
        if (settings.length > 0) {
            const firstIcon = iconsBar.firstChild;
            firstIcon.classList.add('selected');
            await renderProviderDetails(settings[0]);
        }
    });
}

withScriptLogging(context, () => {
    log(context, 'Module initialized');
});
community/providers-handlers.js
// /static/js/community/providers-handlers.js
import { log } from '../core/logger.js';
import { setupEventListeners } from '../utils/event-listeners.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { renderProviderSettings } from './providers-events.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { createModuleInitializer, shouldInitializeForPageType } from '../utils/initialization.js';

const context = 'providers-handlers.js';

export function setupProviderEvents(context) {
    log(context, 'Setting up provider form event listeners');
    withErrorHandling(`${context}:setupProviderEvents`, () => {
        setupEventListeners(context, [
            {
                eventType: 'submit',
                selector: '#providerForm',
                handler: async (event) => {
                    event.preventDefault();
                    await withErrorHandling(`${context}:submitProviderForm`, async () => {
                        await submitConfiguredForm(context, 'providerForm', API_ENDPOINTS.CLIENT_API_SETTINGS, 'providerSettings', {
                            successMessage: SUCCESS_MESSAGES.SETTINGS_UPDATED,
                            onSuccess: async (data) => {
                                await renderProviderSettings(context, data.settings || [], 'providerIconsBar');
                            },
                            onError: (error) => {
                                log(context, `Provider settings submission failed: ${error.message}`);
                            },
                        });
                    }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
                },
            },
            {
                eventType: 'click',
                selector: '#providerIconsBar i[data-key-type]',
                handler: async (event) => {
                    await withErrorHandling(`${context}:selectProviderSetting`, async () => {
                        const keyType = event.target.dataset.keyType;
                        log(context, `Selected provider setting: ${keyType}`);
                        const settings = await import('./providers-data.js').then(m => m.loadClientApiSettings(context));
                        await renderProviderSettings(context, settings.filter(s => s.key_type === keyType), 'providerIconsBar');
                    }, ERROR_MESSAGES.EVENT_HANDLER_FAILED);
                },
            },
        ]);
    }, ERROR_MESSAGES.EVENT_HANDLER_FAILED);
}

export function initializeProvidersHandlersModule(registry) {
    return createModuleInitializer(context, {
        setupProviderEvents,
    });
}

if (shouldInitializeForPageType('community')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
} else {
    log(context, 'Skipping initialization for non-community page');
}
community/providers-page.js
// /static/js/community/providers-page.js
import { log, warn } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { withAuthenticatedUser } from '../core/auth.js';
import { error as notifyError } from '../core/notifications.js';
import { loadClientApiSettings } from './providers-data.js';
import { renderProviderSettings } from './providers-events.js';
import { setupCategoriesNavigation } from './categories-navigation.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { shouldInitializeForPageType } from '../utils/initialization.js';

const context = 'providers-page.js';

/**
 * Initializes the providers page.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeProvidersPage(context) {
    log(context, 'Initializing providers page');
    await withAuthenticatedUser(context, async (userId) => {
        await withErrorHandling(`${context}:initializeProvidersPage`, async () => {
            // Set up navigation
            await setupCategoriesNavigation(context, 'community', 'providers');

            // Set user ID input
            const userIdInput = document.getElementById('userId');
            if (userIdInput) {
                userIdInput.value = userId;
            } else {
                warn(context, 'userId input not found');
            }

            // Fetch and render the settings
            const settings = await loadClientApiSettings(context);
            await renderProviderSettings(context, settings, 'providerIconsBar', 'client-api-settings');
        });
    }, 'initializeProvidersPage');
}

if (shouldInitializeForPageType('community')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
        initializeProvidersPage(context);
    });
} else {
    log(context, 'Skipping initialization for non-community page');
}
community/providers.js
// /static/js/community/providers.js
import { log, warn } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { createIcon } from '../utils/icons.js';
import { withElement } from '../utils/dom-manipulation.js';
import { API_ENDPOINTS } from '../config/constants.js';

const context = 'community/providers.js';

/**
 * Initializes the providers section by fetching data and rendering icons.
 */
export async function initializeProviders(context) {
    log(context, 'Initializing providers section');
    await withElement(context, 'providerIconsBar', async (iconsContainer) => {
        const data = await fetchData(context, API_ENDPOINTS.CLIENT_API_SETTINGS);
        if (!data.settings || data.settings.length === 0) {
            iconsContainer.innerHTML = '<p>No providers available.</p>';
            return;
        }
        await renderProviderIcons(context, data.settings, iconsContainer);
        // Initially, show a message until a provider is selected
        await withElement(context, 'client-api-settings', (staticContainer) => {
            staticContainer.innerHTML = '<p>Select a provider to view integration details.</p>';
        });
    });
}

/**
 * Renders provider icons in the specified container.
 */
async function renderProviderIcons(context, settings, container) {
    log(context, 'Rendering provider icons');
    container.innerHTML = '';
    settings.forEach(setting => {
        const icon = createIcon(context, setting.icon || 'fas fa-cog', { 'data-key-type': setting.key_type });
        icon.classList.add('provider-icon');
        icon.addEventListener('click', async () => {
            container.querySelectorAll('.provider-icon').forEach(i => i.classList.remove('selected'));
            icon.classList.add('selected');
            await renderProviderDetails(context, setting);
        });
        container.appendChild(icon);
    });
}

/**
 * Renders the details and readme content for the selected provider.
 */
async function renderProviderDetails(context, setting) {
    log(context, `Rendering details for provider: ${setting.key_type}`);
    await withElement(context, 'client-api-settings', async (staticContainer) => {
        await withElement(context, 'markdown-content', async (readmeContainer) => {
            // Render static content (header, description, links excluding readme)
            staticContainer.innerHTML = `
                <div style="display: flex; align-items: center; margin-bottom: 15px;">
                    <i class="${setting.icon || 'fas fa-cog'}" style="font-size: 16px; color: currentColor; margin-right: 10px;"></i>
                    <h3 style="display: inline-block; vertical-align: middle; margin: 0;">${setting.comment || ''}</h3>
                    <div style="margin-left: auto; display: flex; gap: 10px;">
                        ${setting.doc_link
                            ?.filter(link => link.title !== 'readme') // Exclude readme link
                            .map(link => `
                                <a href="${link.link}" target="_blank" style="color: currentColor;" title="${link.title.charAt(0).toUpperCase() + link.title.slice(1)}">
                                    <i class="fas fa-${link.title === 'api' ? 'link' : 'user-plus'}" style="font-size: 16px;"></i>
                                </a>
                            `).join('') || ''}
                    </div>
                </div>
                <p>${setting.description || ''}</p>
            `;

            // Fetch and render readme content
            const readmeLink = setting.doc_link?.find(link => link.title === 'readme')?.link;
            if (readmeLink) {
                try {
                    const response = await fetch(readmeLink);
                    if (!response.ok) throw new Error('Failed to fetch readme');
                    const markdown = await response.text();
                    readmeContainer.innerHTML = window.marked.parse(markdown);
                } catch (err) {
                    readmeContainer.innerHTML = '<p>Failed to load readme content.</p>';
                    warn(context, `Error loading readme: ${err.message}`);
                }
            } else {
                readmeContainer.innerHTML = '<p>No readme available for this provider.</p>';
            }

            // Show the content containers
            staticContainer.style.display = 'block';
            readmeContainer.style.display = 'block';
        });
    });
}
community/referrals-data.js
// /static/js/community/referrals-data.js
import { log } from '../core/logger.js';
import { authenticatedFetch } from '../core/auth.js';
import { withErrorHandling } from '../utils/error.js';
import { parsePageType, shouldInitializeForPageType } from '../utils/initialization.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';

const context = 'community/referrals-data.js';

/**
 * Fetches events for the given event type and period.
 * @param {string} eventType - 'referral' or 'sale'
 * @param {string} period - Temporal filter (e.g., 'today')
 * @returns {Promise<Array>} Array of event objects
 */
export async function fetchEvents(eventType, period) {
    const pageType = parsePageType(context, 'page', 'community');
    if (pageType === 'login') {
        log(context, `Skipping ${eventType} events fetch on login page`);
        return [];
    }
    log(context, `Fetching ${eventType} events for period: ${period}`);
    return await withErrorHandling(`${context}:fetchEvents`, async () => {
        const response = await authenticatedFetch(`/events/${eventType}?period=${period}`);
        const data = await response.json();
        if (data.status === 'error') {
            throw new Error(data.message || ERROR_MESSAGES.FETCH_FAILED(`${eventType} events`));
        }
        return data.events || [];
    }, ERROR_MESSAGES.FETCH_FAILED(`${eventType} events`), () => []);
}

if (shouldInitializeForPageType('community')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
} else {
    log(context, 'Skipping initialization for non-community page');
}
community/referrals-page.js
// /static/js/community/referrals-page.js
import { log } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { withAuthenticatedUser } from '../core/auth.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { renderPeriodIcons } from './referrals-ui.js';
import { shouldInitializeForPageType } from '../utils/initialization.js';
import { withScriptLogging } from '../utils/logging-utils.js';

const context = 'community/referrals-page.js';

/**
 * Initializes the referrals page with the specified log type ('referral' or 'sale').
 * @param {string} logType - The type of logs to display ('referral' or 'sale').
 * @returns {Promise<void>}
 */
export async function initializeReferralsPage(logType) {
    log(context, `Initializing referrals page for log type: ${logType}`);
    await withAuthenticatedUser(context, async () => {
        await withErrorHandling(`${context}:initializeReferralsPage`, async () => {
            const logsSection = document.getElementById('logs');
            if (logsSection) {
                logsSection.dataset.type = logType;
                renderPeriodIcons();
            } else {
                log(context, 'Error: logs section not found.');
            }
        }, ERROR_MESSAGES.FETCH_FAILED('referrals page initialization'));
    }, 'initializeReferralsPage');
}

if (shouldInitializeForPageType('community')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
} else {
    log(context, 'Skipping initialization for non-community page');
}
community/referrals-ui.js
// /static/js/community/referrals-ui.js
import { log } from '../core/logger.js';
import { fetchEvents } from './referrals-data.js';

// Define available log periods with their icons and labels
const periods = [
    { name: 'today', icon: 'fa-calendar-day', label: 'Today' },
    { name: 'yesterday', icon: 'fa-calendar-day', label: 'Yesterday' },
    { name: 'this_week', icon: 'fa-calendar-week', label: 'This Week' },
    { name: 'last_week', icon: 'fa-calendar-week', label: 'Last Week' },
    { name: 'this_month', icon: 'fa-calendar', label: 'This Month' },
    { name: 'last_month', icon: 'fa-calendar', label: 'Last Month' }
];

// Define icons for each log type using FontAwesome classes
const logTypeIcons = {
    'click': 'fas fa-mouse-pointer',
    'order': 'fas fa-shopping-cart'
};

/**
 * Formats a timestamp string to UK format (DD/MM/YYYY HH:MM).
 * @param {string} timestamp - The timestamp to format (expected in ISO format).
 * @returns {string} - The formatted timestamp or 'N/A' if invalid.
 */
function formatTimestamp(timestamp) {
    if (!timestamp) return 'N/A';
    const date = new Date(timestamp);
    if (isNaN(date.getTime())) return 'N/A'; // Invalid date
    const options = {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        hour12: false
    };
    return date.toLocaleString('en-GB', options).replace(',', '');
}

/**
 * Renders period icons in the log_period_icon container and sets up click handlers.
 * Initializes with 'today' as the default selected period.
 */
export function renderPeriodIcons() {
    const container = document.getElementById('log_period_icon');
    if (!container) {
        log('community/referrals-ui', 'Error: log_period_icon container not found.');
        return;
    }
    container.innerHTML = ''; // Clear existing content
    periods.forEach((period, index) => {
        const icon = document.createElement('i');
        icon.className = `fa-solid ${period.icon} period-icon`;
        icon.dataset.period = period.name;
        if (index === 0) icon.classList.add('selected'); // Default to 'today'
        icon.addEventListener('click', () => selectPeriod(period.name));
        container.appendChild(icon);
    });
    selectPeriod('today'); // Load logs for 'today' initially
}

/**
 * Selects a period, updates the UI, and triggers log loading for that period.
 * Updates the logs-description element with the log type icon and period label.
 * @param {string} periodName - The name of the period to select (e.g., 'today').
 */
export function selectPeriod(periodName) {
    const icons = document.querySelectorAll('.period-icon');
    icons.forEach(icon => icon.classList.remove('selected'));
    const selectedIcon = document.querySelector(`.period-icon[data-period="${periodName}"]`);
    if (selectedIcon) {
        selectedIcon.classList.add('selected');
    }
    const period = periods.find(p => p.name === periodName);
    if (period) {
        const logsSection = document.getElementById('logs');
        const type = logsSection ? logsSection.dataset.type : null;
        updateDescription(type, period.label); // Update description with icon and text
        loadLogs(type, period.name);
    }
}

/**
 * Updates the logs-description element with the log type icon and text.
 * @param {string} type - The log type (e.g., 'click', 'order').
 * @param {string} periodLabel - The label of the selected period (e.g., 'Today').
 */
function updateDescription(type, periodLabel) {
    const descriptionElement = document.getElementById('logs-description');
    if (descriptionElement) {
        const typeLabel = type ? type.charAt(0).toUpperCase() + type.slice(1) : 'Unknown';
        const iconClass = logTypeIcons[type] || 'fa-question'; // Default to question mark if type unknown
        descriptionElement.innerHTML = `<i class="fa-solid ${iconClass}"></i> ${typeLabel} logs for ${periodLabel}`;
    } else {
        log('community/referrals-ui', 'Warning: logs-description element not found.');
    }
}

/**
 * Fetches logs for a given type and period, then renders them.
 * @param {string} type - The event type ('click' or 'order').
 * @param {string} period - The period for which to fetch logs (e.g., 'today').
 */
export async function loadLogs(type, period) {
    if (!type) {
        log('community/referrals-ui', 'Error: No type set for logs section.');
        return;
    }
    try {
        const events = await fetchEvents(type, period); // Directly use 'click' or 'order'
        renderEventsTable(events);
    } catch (error) {
        log('community/referrals-ui', `Error loading logs: ${error.message}`);
        document.getElementById('logs-table-container').innerHTML = `
            <p>Error: ${error.message}</p>
            <button onclick="loadLogs('${type}', '${period}')">Retry</button>
        `;
    }
}

/**
 * Renders the events data into a table within the logs-table-container.
 * @param {Array} events - Array of event objects to display.
 */
export function renderEventsTable(events) {
    const container = document.getElementById('logs-table-container');
    if (!container) {
        log('community/referrals-ui', 'Error: logs-table-container not found.');
        return;
    }
    container.innerHTML = ''; // Clear existing content
    const table = document.createElement('table');
    table.innerHTML = `
        <thead>
            <tr>
                <th>Timestamp</th>
                <th>Details</th>
            </tr>
        </thead>
        <tbody>
            ${events.map(event => `
                <tr>
                    <td>${formatTimestamp(event.timestamp)}</td>
                    <td>${event.details || 'N/A'}</td>
                </tr>
            `).join('')}
        </tbody>
    `;
    container.appendChild(table);
}
community/settings-renderer.js
// /static/js/community/settings-renderer.js
import { log } from '../core/logger.js';
import { withScriptLogging } from '../utils/logging-utils.js';

const context = 'settings-renderer.js';

/**
 * Renders settings content into the specified content area.
 * @param {string} context - The context or module name.
 * @param {Object} settings - The settings data to render.
 * @param {string} type - The type of settings (e.g., 'provider').
 * @param {HTMLElement} iconsBar - The DOM element for the icons bar.
 * @param {HTMLElement} contentArea - The DOM element to render the settings into.
 * @returns {Promise<void>}
 */
export async function renderSettings(context, settings, type, iconsBar, contentArea) {
  log(context, `Rendering settings for type: ${type}`);
  contentArea.innerHTML = `<h3>${type} Settings</h3><p>Settings content goes here.</p>`;
  // Additional rendering logic can be added here based on specific requirements
}

withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
community/setup.js
// /static/js/community/setup.js
import { log } from '../core/logger.js';
import { withScriptLogging } from '../utils/logging-utils.js';

const context = 'community/setup.js';

export async function initializeCommunityModules(context, pageType) {
    log(context, `Initializing community modules for page type: ${pageType}`);
    // Add any additional module initialization here if needed
    // For now, it’s a placeholder to satisfy the reference
}

export function initializeSetupModule(registry) {
    log(context, 'Initializing community setup module for module registry');
    return {
        initializeCommunityModules: (ctx, pageType) => initializeCommunityModules(ctx, pageType),
    };
}

withScriptLogging(context, () => {
    log(context, 'Module initialized');
});
community-page.js
// /static/js/community-page.js
import { log } from './core/logger.js';
import { parsePageType, initializeRolePage, hideOverlay, getDefaultSectionFromQuery, shouldInitializeForPageType } from './utils/initialization.js';
import { toggleViewState } from './utils/dom-manipulation.js';
import { withScriptLogging } from './utils/logging-utils.js';
import { defineCommunitySectionHandlers } from './community/navigation.js';
import { initializeCommunityModules } from './community/setup.js';
import { getMenu } from './config/menus.js';
import { initializeRoleNavigation } from './modules/navigation.js';

const context = 'community-page.js';

/**
 * Initializes the community page with navigation and default section visibility.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeCommunityPage(context) {
  log(context, 'Initializing community page');
  const pageType = parsePageType(context, 'page', 'categories');
  if (pageType === 'login') {
    log(context, 'Skipping community page initialization for login page');
    return;
  }
  const role = 'community';
  const fallbackSection = 'info';
  const defaultSection = getDefaultSectionFromQuery(context, role, fallbackSection);

  await initializeRolePage(context, role, pageType, async () => {
    // Get section handlers
    const sectionHandlers = defineCommunitySectionHandlers(context);
    
    // Set up navigation
    const menuElement = document.getElementById('menu');
    if (menuElement) {
      const menu = getMenu(role);
      await initializeRoleNavigation(menuElement, menu, { sectionHandlers, defaultSection });
      log(context, 'Navigation initialized with default section:', defaultSection);
    } else {
      log(context, 'Menu element not found, skipping navigation setup');
    }

    // Initialize additional community modules, avoiding #siteRequestForm handlers
    const form = document.querySelector('#siteRequestForm');
    if (form && form.dataset.siteRequestHandled) {
      log(context, 'Skipping form handler setup for #siteRequestForm, handled by site-request.js');
    }
    await initializeCommunityModules(context, pageType);

    // Ensure the default section is visible
    toggleViewState(context, { [defaultSection]: true });
    log(context, `Default section '${defaultSection}' set to visible`);
  });
}

export function initializeCommunityPageModule(registry) {
  log(context, 'Initializing community-page module for module registry');
  return {
    initializeCommunityPage: ctx => initializeCommunityPage(ctx),
  };
}

if (shouldInitializeForPageType('community')) {
  withScriptLogging(context, async () => {
    log(context, 'Module initialized');
    await initializeCommunityPage(context);
    hideOverlay();
  });
} else {
  log(context, 'Skipping initialization for non-community page');
}
config/constants.js
// /static/js/config/constants.js
// Purpose: Centralizes constants for the application by re-exporting from other modules.

import { log } from '../core/logger.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { API_ENDPOINTS } from './endpoints.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from './messages.js';

const context = 'constants.js';

// Export the constants for use in other modules
export { API_ENDPOINTS, ERROR_MESSAGES, SUCCESS_MESSAGES };

/**
 * Initializes the constants module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Constants instance with public constants.
 */
export function initializeConstantsModule(registry) {
    log(context, 'Initializing constants module for module registry');
    return {
        API_ENDPOINTS,
        ERROR_MESSAGES,
        SUCCESS_MESSAGES,
    };
}

// Initialize module with lifecycle logging
withScriptLogging(context, () => {
    log(context, 'Module initialized');
});
config/endpoints.js
// /static/js/config/endpoints.js
// Purpose: Defines API endpoints for the application, centralizing all API routes for consistent usage.

import { log } from '../core/logger.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * API endpoint definitions with parameterized routes where applicable.
 * @type {Object.<string, string|Function>}
 */
export const API_ENDPOINTS = {
  BASE: 'https://clubmadeira.io', // Base URL for constructing full endpoint URLs
  // Admin endpoints
  SETTINGS_AFFILIATE: '/settings/affiliate',
  SETTINGS_AFFILIATE_KEY: '/settings/affiliate_key',
  SETTINGS_API_KEY: '/settings/api-key',
  SETTINGS_KEY: '/settings/settings_key',
  USERS_ROLE: role => `/users/${role}`,
  USERS_USERID: userId => `/users/${userId}`,
  USERS_CURRENT: '/users/current', // Added for fetching current user ID
  PERMISSION: '/permissions',
  DEALS: '/deals',
  EVENT: '/event', // Added for referral tracking and test forms

  // Community endpoints
  CATEGORIES: '/categories',
  SAVE_CATEGORIES: '/categories/save',
  RESET_CATEGORIES: '/categories/reset',
  CLIENT_API_SETTINGS: '/settings/client_api',
  CHECK_DOMAIN: '/check-domain',
  
  // Referral endpoints (user ID is inferred from auth token)
  REFERRAL: '/referral',
  REFERRAL_VISITS: '/referral/visits',
  REFERRAL_ORDERS: '/referral/orders',
  
  // Partner endpoints
  CLIENT_API: '/client-api',

  // User settings endpoints
  SETTINGS_USER: '/settings/user',
  UPDATE_PASSWORD: '/update-password',

  // Site request endpoint
  SITE_REQUEST: '/siterequest',
  SITE_REQUESTS: '/siterequests',

  // Merchant endpoints
  API_KEY: '/settings/api_key',
  PRODUCTS: '/settings/products',

  // Login endpoints
  LOGIN: '/',
  RESET_PASSWORD: '/reset-password',
  VERIFY_RESET_CODE: '/verify-reset-code',
  SIGNUP: '/signup',
  VERIFY_TOKEN: '/verify-token',
  COMPLETE_SIGNUP: '/complete-signup',
};

/**
 * Initializes the endpoints module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Endpoints instance with public endpoints.
 */
export function initializeEndpointsModule(registry) {
  const context = 'endpoints.js';
  log(context, 'Initializing endpoints module for module registry');
  return {
    API_ENDPOINTS,
  };
}

/**
 * Initializes the endpoints module.
 */
export function initializeEndpoints() {
  withScriptLogging('endpoints.js', () => {
    log('endpoints.js', 'Module initialized');
  });
}
config/form-configs.js
// /static/js/form-configs.js
import { log } from '../core/logger.js';
import { validatePhoneNumber } from '../utils/form-submission.js';
import { isValidEmail } from '../utils/form-validation-utils.js';
import { renderStyles } from '../utils/form-rendering.js';
import { renderCheckboxList } from '../utils/ui-components.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from './messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { createModuleInitializer } from '../utils/initialization.js';

const context = 'form-configs.js';

/**
 * Generates fields for a category form based on provided data.
 * @param {string} context - The context or module name.
 * @param {Object} [options={}] - Options for generating fields (e.g., defaults, category data).
 * @returns {Array} Array of field configurations.
 */
function generateCategoryFields(context, options = {}) {
  log(context, 'Generating category form fields');
  const { defaults = {}, category = {} } = options;
  return [
    {
      type: 'text',
      id: 'category_name',
      name: 'category_name',
      label: 'Category Name',
      required: true,
      value: category.name || defaults.name || '',
      style: renderStyles('categories', { width: '100%', padding: '8px' }),
    },
    {
      type: 'textarea',
      id: 'category_description',
      name: 'category_description',
      label: 'Description',
      value: category.description || defaults.description || '',
      style: renderStyles('categories', { width: '100%', padding: '8px' }),
    },
  ];
}

/**
 * Generates custom fields for a category form based on provided data.
 * @param {string} context - The context or module name.
 * @param {Object} [options={}] - Options for generating fields (e.g., custom fields).
 * @returns {Array} Array of custom field configurations.
 */
function generateCategoryCustomFields(context, options = {}) {
  log(context, 'Generating category custom form fields');
  const { customFields = [] } = options;
  return customFields.map((field, index) => ({
    type: field.type || 'text',
    id: `custom_field_${index}`,
    name: `custom_field_${field.key || index}`,
    label: field.label || `Custom Field ${index + 1}`,
    required: field.required || false,
    value: field.value || '',
    style: renderStyles('categories', { width: '100%', padding: '8px' }),
  }));
}

/**
 * Generates a categories form configuration based on provided data.
 * @param {string} context - The context or module name.
 * @param {Object} [options={}] - Options for generating the form (e.g., defaults, category data).
 * @returns {Object} The categories form configuration.
 */
function getCategoriesFormConfig(context, options = {}) {
  log(context, 'Generating categories form config');
  return {
    id: 'category-form', // Updated to match DOM ID
    action: '/categories',
    method: 'POST',
    successMessage: 'Categories processed successfully!', // Updated for clarity
    transform: formData => {
      let deselected = [];
      let previous_deselected = [];
      let previous_selected = [];
      let categories = {};
      try {
        deselected = JSON.parse(formData.get('deselected') || '[]');
      } catch (e) {
        log(context, 'Error parsing deselected:', e);
      }
      try {
        previous_deselected = JSON.parse(formData.get('previous_deselected') || '[]');
      } catch (e) {
        log(context, 'Error parsing previous_deselected:', e);
      }
      try {
        previous_selected = JSON.parse(formData.get('previous_selected') || '[]');
      } catch (e) {
        log(context, 'Error parsing previous_selected:', e);
      }
      try {
        categories = JSON.parse(formData.get('categories') || '{}');
      } catch (e) {
        log(context, 'Error parsing categories:', e);
      }
      return {
        prompt: formData.get('prompt')?.trim(),
        deselected,
        previous_deselected,
        previous_selected,
        categories,
      };
    },
    validate: formData => {
      const prompt = formData.get('prompt')?.trim();
      if (!prompt) {
        throw new Error('Please describe your club.');
      }
      return true;
    },
    validationError: 'Please describe your club.', // Updated to match validate message
    fetchOptions: {
      headers: { 'Content-Type': 'application/json' },
    },
    fields: [
      {
        type: 'textarea',
        id: 'prompt',
        name: 'prompt',
        label: 'Describe your club', // Simplified label
        required: true,
        style: { width: '100%', maxWidth: '600px' }, // Added style for consistency
      },
      {
        type: 'hidden',
        id: 'deselected',
        name: 'deselected',
      },
      {
        type: 'hidden',
        id: 'previous_deselected',
        name: 'previous_deselected',
      },
      {
        type: 'hidden',
        id: 'previous_selected',
        name: 'previous_selected',
      },
      {
        type: 'hidden',
        id: 'categories',
        name: 'categories',
      },
    ],
    requiresAuth: true,
  };
}

/**
 * Form configuration registry.
 * @type {Object.<string, Object>}
 */
const FORM_CONFIGS = {
  login: {
    id: 'loginForm',
    action: '/',
    method: 'POST',
    submitButtonText: 'Login',
    successMessage: 'Login successful!',
    transform: formData => ({
      email: formData.get('email')?.trim(),
      password: formData.get('password'),
    }),
    validate: formData => {
      try {
        return (
          !!formData.get('email')?.trim() &&
          isValidEmail('login', formData.get('email')) &&
          !!formData.get('password')
        );
      } catch (err) {
        throw new Error(err.message || ERROR_MESSAGES.FORM_VALIDATION_FAILED);
      }
    },
    validationError: 'Please enter a valid email and password.',
    fetchOptions: {
      headers: { 'Content-Type': 'application/json' },
    },
    fields: [
      {
        type: 'email',
        name: 'email',
        label: 'Email',
        required: true,
        attributes: { placeholder: 'Enter your email', id: 'loginEmail', autocomplete: 'off' },
      },
      {
        type: 'password',
        name: 'password',
        label: 'Password',
        required: true,
        attributes: {
          placeholder: 'Enter your password',
          id: 'loginPassword',
          autocomplete: 'off',
        },
        wrapper: {
          class: 'password-wrapper',
          style: 'position: relative; width: 100%;',
        },
        extraButtons: [
          {
            type: 'button',
            text: '<i class="fas fa-eye"></i>',
            className: 'toggle-password',
            style: 'position: absolute; right: 10px; top: 50%; transform: translateY(-50%); cursor: pointer; background: none; border: none; font-size: 16px; color: #666;',
          },
        ],
      },
    ],
    requiresAuth: false,
  },
  setPassword: {
    id: 'setPasswordForm',
    action: '/complete-signup',
    method: 'POST',
    submitButtonText: 'Set Password',
    successMessage: 'Password set successfully!',
    transform: formData => ({
      email: formData.get('email')?.trim(),
      password: formData.get('password'),
      confirm_password: formData.get('confirm_password'),
      set_password: formData.get('set_password'),
    }),
    validate: formData => {
      try {
        const email = formData.get('email')?.trim();
        const password = formData.get('password');
        const confirmPassword = formData.get('confirm_password');
        return (
          !!email &&
          isValidEmail('setPassword', email) &&
          !!password &&
          password === confirmPassword
        );
      } catch (err) {
        throw new Error(err.message || ERROR_MESSAGES.FORM_VALIDATION_FAILED);
      }
    },
    validationError: 'Please enter a valid email and ensure passwords match.',
    fetchOptions: {
      headers: { 'Content-Type': 'application/json' },
    },
    fields: [
      {
        type: 'email',
        name: 'email',
        label: 'Email',
        required: true,
        attributes: { id: 'email', autocomplete: 'off' },
      },
      {
        type: 'password',
        name: 'password',
        label: 'Password',
        required: true,
        attributes: { id: 'password', placeholder: 'Enter your password', autocomplete: 'new-password' },
        wrapper: {
          class: 'password-wrapper',
          style: 'position: relative; width: 100%;',
        },
        extraButtons: [
          {
            type: 'button',
            text: '<i class="fas fa-eye"></i>',
            className: 'toggle-password',
            style: 'position: absolute; right: 10px; top: 50%; transform: translateY(-50%); cursor: pointer; background: none; border: none; font-size: 16px; color: #666;',
          },
        ],
      },
      {
        type: 'password',
        name: 'confirm_password',
        label: 'Confirm Password',
        required: true,
        attributes: { id: 'confirmPassword', placeholder: 'Confirm your password', autocomplete: 'new-password' },
        wrapper: {
          class: 'password-wrapper',
          style: 'position: relative; width: 100%;',
        },
        extraButtons: [
          {
            type: 'button',
            text: '<i class="fas fa-eye"></i>',
            className: 'toggle-password',
            style: 'position: absolute; right: 10px; top: 50%; transform: translateY(-50%); cursor: pointer; background: none; border: none; font-size: 16px; color: #666;',
          },
        ],
      },
      {
        type: 'hidden',
        name: 'set_password',
        value: 'true',
      },
    ],
    requiresAuth: false,
  },
  signup: {
    id: 'signupForm',
    action: '/signup',
    method: 'POST',
    submitButtonText: 'Sign Me Up',
    successMessage: 'Signup submitted successfully!',
    transform: formData => ({
      signup_type: formData.get('signup_type')?.trim(),
    }),
    validate: formData => {
      log(context, 'Validating signup form, formData type:', formData.constructor.name);
      try {
        return !!formData.get('signup_type')?.trim();
      } catch (err) {
        throw new Error(err.message || ERROR_MESSAGES.FORM_VALIDATION_FAILED);
      }
    },
    validationError: 'Please select a signup type.',
    fetchOptions: {
      headers: { 'Content-Type': 'application/json' },
    },
    fields: [
      {
        type: 'radio',
        name: 'signup_type',
        label: 'Signup Type',
        required: true,
        attributes: { id: 'signup_type', autocomplete: 'off' },
        options: [
          { value: 'community', label: 'Community' },
          { value: 'seller', label: 'Merchant' },
          { value: 'partner', label: 'Partner' },
        ],
      },
    ],
    requiresAuth: false,
  },
  forgotPassword: {
    id: 'forgotPasswordForm',
    action: '/reset-password',
    method: 'POST',
    submitButtonText: 'Send OTP via SMS',
    successMessage: 'OTP sent successfully! Please check your SMS.',
    transform: formData => ({
      email: formData.get('email')?.trim(),
    }),
    validate: formData => {
      try {
        return !!formData.get('email')?.trim() && isValidEmail('forgotPassword', formData.get('email'));
      } catch (err) {
        throw new Error(err.message || ERROR_MESSAGES.FORM_VALIDATION_FAILED);
      }
    },
    validationError: 'Please enter a valid email.',
    fetchOptions: {
      headers: { 'Content-Type': 'application/json' },
    },
    fields: [
      {
        type: 'email',
        name: 'email',
        label: 'Email',
        required: true,
        attributes: { id: 'forgotEmail', autocomplete: 'off' },
      },
    ],
    requiresAuth: false,
  },
  verifyOtp: {
    id: 'verifyOtpForm',
    action: '/verify-signup-otp',
    method: 'POST',
    submitButtonText: 'Set Password',
    successMessage: 'Password set successfully!',
    transform: formData => ({
      email: formData.get('email')?.trim(),
      otp: formData.get('otp')?.trim(),
      new_password: formData.get('new_password'),
      otp_token: formData.get('otp_token'),
    }),
    validate: formData => {
      try {
        return (
          !!formData.get('email')?.trim() &&
          isValidEmail('verifyOtp', formData.get('email')) &&
          !!formData.get('otp')?.trim() &&
          !!formData.get('new_password') &&
          formData.get('new_password') === formData.get('confirm_new_password')
        );
      } catch (err) {
        throw new Error(err.message || ERROR_MESSAGES.FORM_VALIDATION_FAILED);
      }
    },
    validationError: 'Please complete all fields correctly and ensure passwords match.',
    fetchOptions: {
      headers: { 'Content-Type': 'application/json' },
    },
    fields: [
      {
        type: 'email',
        name: 'email',
        label: 'Email',
        required: true,
        attributes: { id: 'verifyEmail', autocomplete: 'off' },
      },
      {
        type: 'text',
        name: 'otp',
        label: 'One-Time Password',
        required: true,
        attributes: { id: 'otpCode', autocomplete: 'off' },
      },
      {
        type: 'password',
        name: 'new_password',
        label: 'New Password',
        required: true,
        attributes: { id: 'newPassword', autocomplete: 'new-password' },
        wrapper: {
          class: 'password-wrapper',
          style: 'position: relative; width: 100%;',
        },
        extraButtons: [
          {
            type: 'button',
            text: '<i class="fas fa-eye"></i>',
            className: 'toggle-password',
            style: 'position: absolute; right: 10px; top: 50%; transform: translateY(-50%); cursor: pointer; background: none; border: none; font-size: 16px; color: #666;',
          },
        ],
      },
      {
        type: 'password',
        name: 'confirm_new_password',
        label: 'Confirm New Password',
        required: true,
        attributes: { id: 'confirmNewPassword', autocomplete: 'new-password' },
        wrapper: {
          class: 'password-wrapper',
          style: 'position: relative; width: 100%;',
        },
        extraButtons: [
          {
            type: 'button',
            text: '<i class="fas fa-eye"></i>',
            className: 'toggle-password',
            style: 'position: absolute; right: 10px; top: 50%; transform: translateY(-50%); cursor: pointer; background: none; border: none; font-size: 16px; color: #666;',
          },
        ],
      },
      {
        type: 'hidden',
        name: 'otp_token',
        attributes: { id: 'otpToken' },
      },
    ],
    requiresAuth: false,
  },
  userSettings: {
    id: 'userSettingsForm',
    action: '/settings/user',
    method: 'PATCH',
    submitButtonText: 'Save Settings',
    successMessage: 'User settings updated successfully!',
    transform: formData => ({
      contact_name: formData.get('contact_name')?.trim(),
      email_address: formData.get('email_address')?.trim(),
      phone_number: formData.get('phone_number')?.trim(),
    }),
    validate: formData => {
      try {
        return (
          !!formData.get('contact_name')?.trim() &&
          !!formData.get('email_address')?.trim() &&
          isValidEmail('userSettings', formData.get('email_address')) &&
          validatePhoneNumber('userSettings', formData.get('phone_number'))
        );
      } catch (err) {
        throw new Error(err.message || ERROR_MESSAGES.FORM_VALIDATION_FAILED);
      }
    },
    validationError: 'Please complete all fields correctly.',
    fetchOptions: {
      headers: { 'Content-Type': 'application/json' },
    },
    fields: [
      {
        type: 'text',
        name: 'contact_name',
        label: 'Name',
        required: true,
        attributes: { id: 'contact_name' },
      },
      {
        type: 'email',
        name: 'email_address',
        label: 'Email',
        required: true,
        attributes: { id: 'email_address' },
      },
      {
        type: 'tel',
        name: 'phone_number',
        label: 'Phone Number',
        required: true,
        attributes: { id: 'phone_number' },
      },
    ],
    requiresAuth: true,
  },
  completeSignup: {
    id: 'setPasswordForm',
    action: '/complete-signup',
    method: 'POST',
    submitButtonText: 'Set Password',
    successMessage: 'Account created successfully!',
    transform: formData => ({
      password: formData.get('password'),
      confirm_password: formData.get('confirm_password'),
      stripe_account_id: formData.get('stripe_account_id'),
      role: formData.get('role'),
      email: formData.get('email'),
      phone: formData.get('phone'),
    }),
    validate: formData => {
      const password = formData.get('password');
      const confirmPassword = formData.get('confirm_password');
      const stripeAccountId = formData.get('stripe_account_id');
      const role = formData.get('role');
      const email = formData.get('email');
      const phone = formData.get('phone');

      if (!password || !confirmPassword || password !== confirmPassword || !stripeAccountId || !role) {
        throw new Error('Please ensure all required fields are filled correctly and passwords match.');
      }

      if (email !== null && !isValidEmail('completeSignup', email)) {
        throw new Error('Please enter a valid email address.');
      }

      if (phone !== null && !validatePhoneNumber('completeSignup', phone)) {
        throw new Error('Please enter a valid phone number.');
      }

      return true;
    },
    validationError: 'Please complete all fields correctly and ensure passwords match.',
    fetchOptions: {
      headers: { 'Content-Type': 'application/json' },
    },
    fields: [
      {
        type: 'password',
        name: 'password',
        label: 'Password',
        required: true,
        attributes: { 
          id: 'setPassword', 
          placeholder: 'Enter your password', 
          autocomplete: 'new-password' 
        },
        wrapper: {
          class: 'password-wrapper',
          style: 'position: relative; width: 100%;',
        },
        extraButtons: [
          {
            type: 'button',
            text: '<i class="fas fa-eye"></i>',
            className: 'toggle-password',
            style: 'position: absolute; right: 10px; top: 50%; transform: translateY(-50%); cursor: pointer; background: none; border: none; font-size: 16px; color: #666;',
          },
        ],
      },
      {
        type: 'password',
        name: 'confirm_password',
        label: 'Confirm Password',
        required: true,
        attributes: { 
          id: 'setConfirmPassword', 
          placeholder: 'Confirm your password', 
          autocomplete: 'new-password' 
        },
        wrapper: {
          class: 'password-wrapper',
          style: 'position: relative; width: 100%;',
        },
        extraButtons: [
          {
            type: 'button',
            text: '<i class="fas fa-eye"></i>',
            className: 'toggle-password',
            style: 'position: absolute; right: 10px; top: 50%; transform: translateY(-50%); cursor: pointer; background: none; border: none; font-size: 16px; color: #666;',
          },
        ],
      },
      {
        type: 'email',
        name: 'email',
        label: 'Email',
        required: false,
        attributes: { id: 'email', placeholder: 'Enter your email', autocomplete: 'off' },
      },
      {
        type: 'tel',
        name: 'phone',
        label: 'Phone Number',
        required: false,
        attributes: { id: 'phone', placeholder: 'Enter your phone number' },
      },
      {
        type: 'hidden',
        name: 'stripe_account_id',
        attributes: { id: 'stripeAccountId' },
      },
      {
        type: 'hidden',
        name: 'role',
        attributes: { id: 'role' },
      },
    ],
    requiresAuth: false,
  },
  siteRequest: {
    id: 'siteRequestForm',
    action: '/siterequest',
    method: 'POST',
    submitButtonText: 'Save Site Request',
    successMessage: 'Site request saved successfully!',
    transform: formData => {
      const data = { pages: [] };
      for (let [key, value] of formData.entries()) {
        if (key.startsWith('email_')) {
          data.emails = data.emails || [];
          data.emails.push(value);
        } else if (key.startsWith('page_')) {
          const [prefix, index, field] = key.split('_');
          data.pages[parseInt(index)] = data.pages[parseInt(index)] || {};
          data.pages[parseInt(index)][field] = value;
        } else {
          const fieldMap = {
            name: 'communityName',
            about: 'aboutCommunity',
            colorPrefs: 'colorPrefs',
            stylingDetails: 'stylingDetails',
            preferredDomain: 'preferredDomain',
            logos: 'communityLogos',
          };
          data[fieldMap[key] || key] = value instanceof File ? 'placeholder' : value;
        }
      }
      data.pages = data.pages.filter(page => page && page.title);
      return data;
    },
    validate: formData => {
      try {
        const communityName = formData.get('name')?.trim();
        const emails = Array.from(formData.entries())
          .filter(([key]) => key.startsWith('email_'))
          .map(([_, value]) => value);
        return (
          !!communityName &&
          emails.length > 0 &&
          emails.some(email => email.trim())
        );
      } catch (err) {
        throw new Error(err.message || ERROR_MESSAGES.FORM_VALIDATION_FAILED);
      }
    },
    validationError: 'Please enter a valid community name and at least one email.',
    fetchOptions: {
      headers: { 'Content-Type': 'application/json' },
    },
    fields: [
      {
        type: 'text',
        name: 'name',
        label: 'Community Name',
        required: true,
        attributes: { id: 'name', placeholder: 'Enter community name' },
      },
      {
        type: 'textarea',
        name: 'about',
        label: 'About Community',
        attributes: { id: 'about', placeholder: 'Describe your community', class: 'mce-editor' },
      },
      {
        type: 'text',
        name: 'colorPrefs',
        label: 'Color Preferences',
        attributes: { id: 'colorPrefs', placeholder: 'Enter color preferences' },
      },
      {
        type: 'text',
        name: 'stylingDetails',
        label: 'Styling Details',
        attributes: { id: 'stylingDetails', placeholder: 'Enter styling details' },
      },
      {
        type: 'text',
        name: 'preferredDomain',
        label: 'Preferred Domain',
        attributes: { id: 'preferredDomain', placeholder: 'e.g., mycommunity.org' },
      },
      {
        type: 'file',
        name: 'logos',
        label: 'Community Logos',
        attributes: { id: 'logos', multiple: true },
      },
      {
        type: 'dynamic',
        name: 'emails',
        containerId: 'emailsContainer',
        addButton: {
          text: 'Add Another Email',
          dataset: { action: 'addEmail' },
        },
        template: index => ({
          type: 'email',
          name: `email_${index}`,
          label: `Email ${index + 1}`,
          attributes: { placeholder: 'Enter email' },
          removeButton: {
            text: 'Remove',
            className: 'remove-email',
          },
        }),
      },
      {
        type: 'dynamic',
        name: 'pages',
        containerId: 'pagesContainer',
        addButton: {
          text: 'Add Page',
          dataset: { action: 'addPage' },
        },
        template: index => ({
          type: 'group',
          fields: [
            {
              type: 'text',
              name: `page_${index}_title`,
              label: `Page ${index + 1} Title`,
              attributes: { id: `page_${index}_title`, placeholder: 'Page Title' },
            },
            {
              type: 'textarea',
              name: `page_${index}_content`,
              label: `Page ${index + 1} Content`,
              attributes: { id: `page_${index}_content`, class: 'mce-editor', placeholder: 'Page Content' },
            },
            {
              type: 'file',
              name: `page_${index}_images`,
              label: `Page ${index + 1} Images`,
              attributes: { id: `page_${index}_images`, multiple: true },
            },
            {
              type: 'button',
              text: 'Remove',
              className: 'remove-page',
            },
          ],
        }),
      },
    ],
    requiresAuth: true,
  },
  categories: getCategoriesFormConfig,
};

/**
 * Retrieves a form configuration by key, optionally merging with dynamic options.
 * @param {string} context - The context or module name.
 * @param {string} configKey - The key for the form configuration (e.g., 'login', 'categories').
 * @param {Object} [options={}] - Dynamic options to merge with the configuration.
 * @returns {Object} The form configuration.
 */
export function getFormConfig(context, configKey, options = {}) {
  log(context, `Retrieving form config for key: ${configKey}`);
  if (!configKey || typeof configKey !== 'string') {
    log(context, `Invalid form configuration key: ${configKey}`);
    return {};
  }
  const config = FORM_CONFIGS[configKey];
  if (!config) {
    log(context, `No form configuration found for key: ${configKey}`);
    return {};
  }
  if (typeof config === 'function') {
    return config(context, options);
  }
  if (!config.method) {
    log(context, `Invalid configuration for key: ${configKey} - missing method`);
    return {};
  }
  return { ...config, ...options };
}

/**
 * Initializes the form configs module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Form configs instance with public methods.
 */
export function initializeFormConfigsModule(registry) {
  return createModuleInitializer('form-configs.js', {
    getFormConfig,
    getCategoriesFormConfig,
  });
}

// Initialize module with lifecycle logging
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
config/menus.js
// config/menus.js

import { log, warn } from '../core/logger.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { authenticatedFetch, getAuthToken, setAuthToken, removeAuthToken } from '../core/auth.js';
import { error as notifyError } from '../core/notifications.js';
import { resetNavigation } from '../modules/navigation.js';

const context = 'menus.js';

export const MENUS = {
    'admin': [
        {
            section: 'user_management',
            label: 'User Management',
            icons: ['icon-admin']
        },
        { section: 'affiliates', label: 'Affiliate Programs', icons: ['icon-amazon-uk'] },
        { section: 'site_settings', label: 'Site Settings', icons: ['fas fa-cog'] },
        {
            section: 'site_requests', // New menu item for site requests
            label: 'Site Requests',
            icons: ['fas fa-globe']
        },
        {
            section: 'logsIntro',
            label: 'Logs',
            icons: ['fas fa-chart-bar'],
            submenu: [
                { section: 'logs', label: 'Login Events', icons: ['fas fa-sign-in-alt'], type: 'login' },
                { section: 'logs', label: 'Signup Events', icons: ['fas fa-user-plus'], type: 'signup' },
                { section: 'logs', label: 'Click Events', icons: ['fas fa-mouse-pointer'], type: 'click' },
                { section: 'logs', label: 'Order Events', icons: ['fas fa-shopping-cart'], type: 'order' }
            ]
        },
        {
            section: 'testScriptsIntro',
            label: 'Test Scripts',
            icons: ['fas fa-vial'],
            submenu: [
                { section: 'test_partner', label: 'Test Partner', icons: ['icon-partner', 'fas fa-vial'] },
                { section: 'test_merchant', label: 'Test Merchant', icons: ['icon-merchant', 'fas fa-vial'] },
                { section: 'test_community', label: 'Test Community', icons: ['icon-community', 'fas fa-vial'] },
                {
                    section: 'referralTestsIntro',
                    label: 'Referral Tests',
                    icons: ['fas fa-cog', 'fas fa-vial'],
                    submenu: [
                        { section: 'page_visit_test', label: 'Page Visit Test', icons: ['fas fa-eye', 'fas fa-vial'] },
                        { section: 'order_test', label: 'Order Test', icons: ['fas fa-shopping-cart', 'fas fa-vial'] }
                    ]
                }
            ]
        }
    ],
    'merchant': [
        { section: 'create-store', label: 'Create Store', icons: ['fas fa-store'] },
        { section: 'my-products', label: 'My Products', icons: ['fas fa-box-open'] },
        { section: 'api-keys', label: 'API Keys', icons: ['fas fa-key'] },
        {
            section: 'logsIntro',
            label: 'Logs',
            icons: ['fas fa-chart-bar'],
            submenu: [                
                { section: 'logs', label: 'Click Events', icons: ['fas fa-mouse-pointer'], type: 'click' },
                { section: 'logs', label: 'Order Events', icons: ['fas fa-shopping-cart'], type: 'order' }
            ]
        }
    ],
    'community': [
        { section: 'categories', label: 'Categories', icons: ['fas fa-list'] },
        { section: 'my_website_intro_section', label: 'Link My Website', icons: ['fas fa-link'] },
        { section: 'no_website', label: 'Create Website', icons: ['fas fa-globe'] },
        {
            section: 'logsIntro',
            label: 'Logs',
            icons: ['fas fa-chart-bar'],
            submenu: [                
                { section: 'logs', label: 'Click Events', icons: ['fas fa-mouse-pointer'], type: 'click' },
                { section: 'logs', label: 'Order Events', icons: ['fas fa-shopping-cart'], type: 'order' }
            ]
        }
    ],
    'partner': [
        { section: 'referrals', label: 'Referrals', icons: ['fas fa-link'] },
        { section: 'settings', label: 'Settings', icons: ['fas fa-cog'] }
    ],
    'login': [
        {
            section: 'signupContainer',
            label: 'Sign Up',
            icons: ['fas fa-user-plus']
        },
        {
            section: 'forgotPasswordContainer',
            label: 'Forgot Password',
            icons: ['fas fa-lock']
        }
    ],
    'default': [
        {
            section: 'info',
            label: 'Login',
            icons: ['fas fa-sign-in-alt']
        }
    ]
};

export function hasAdminPermission() {
    const token = getAuthToken();
    if (!token) {
        log(context, 'No auth token found, assuming no admin permission');
        return false;
    }
    try {
        const payload = JSON.parse(atob(token.split('.')[1]));
        const hasPermission = payload && payload.permissions && payload.permissions.includes('admin');
        log(context, `Checking admin permission: ${hasPermission}`);
        return hasPermission;
    } catch (err) {
        warn(context, `Error decoding token: ${err.message}`);
        return false;
    }
}

async function switchRole(role) {
    log(context, `Switching to role: ${role}`);
    window.showLoadingOverlay?.();
    try {
        const response = await authenticatedFetch('/set-role', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ role })
        });
        if (!response.ok) {
            throw new Error(`Failed to set role: ${response.status}`);
        }
        const data = await response.json();
        log(context, `Successfully set x-role to ${role}, response:`, data);

        if (data.token) {
            setAuthToken(data.token);
            log(context, `Updated token with new x-role: ${role}`);
        } else {
            warn(context, 'No token returned in set-role response');
        }

        window.location.href = '/';
    } catch (err) {
        warn(context, `Error setting role to ${role}: ${err.message}`);
        notifyError(context, `Failed to switch to ${role} role`);
        window.hideLoadingOverlay?.();
    }
}

async function handleLogoff() {
    log(context, 'Logoff button clicked');
    try {
        const confirmed = confirm('Are you sure you want to log out?');
        if (confirmed) {
            window.showLoadingOverlay?.();
            log(context, 'Showing loading overlay during logoff');
            removeAuthToken();
            resetNavigation(context);
            window.location.href = '/logoff';
            log(context, 'Redirected to /logoff');
        } else {
            log(context, 'Logoff cancelled by user');
        }
    } catch (err) {
        warn(context, `Error during logoff: ${err.message}`);
        notifyError(context, 'Failed to log out');
        window.hideLoadingOverlay?.();
    }
}

function addActionsToMenu(menu, role) {
    return menu.map(item => {
        let newItem = { ...item };
        if (role !== 'login') {
            if (newItem.section === 'test_partner') {
                newItem.action = () => switchRole('partner');
            } else if (newItem.section === 'test_merchant') {
                newItem.action = () => switchRole('merchant');
            } else if (newItem.section === 'test_community') {
                newItem.action = () => switchRole('community');
            }
        } else {
            newItem.action = undefined;
        }
        if (newItem.submenu) {
            newItem.submenu = addActionsToMenu(newItem.submenu, role);
        }
        return newItem;
    });
}

export function getMenu(role) {
    log(context, `Retrieving menu for role: ${role}`);
    let baseMenu = MENUS[role] || MENUS['default'];
    if (!baseMenu || !Array.isArray(baseMenu)) {
        warn(context, `No valid menu found for role: ${role}, using default`);
        baseMenu = MENUS['default'];
    }

    const menuWithActions = addActionsToMenu(baseMenu, role);

    const additionalButtons = [];

    if (role !== 'login') {
        additionalButtons.push({
            section: 'my-account',
            label: 'My Account',
            icons: ['fas fa-user'],
            submenu: [
                { section: 'contact-details', label: 'Contact Details', icons: ['fas fa-address-card'] },
                { section: 'change-password', label: 'Change Password', icons: ['fas fa-key'] }
            ]
        });
    }

    let pageType = document.body.getAttribute('data-page-type') || document.body.dataset.pageType;
    if (role === 'login') {
        pageType = 'login';
        log(context, 'Forcing pageType to "login" for login role');
    } else if (!pageType) {
        const token = getAuthToken();
        if (token) {
            try {
                const payload = JSON.parse(atob(token.split('.')[1]));
                pageType = payload['x-role'] || 'unknown';
            } catch (err) {
                warn(context, `Error decoding token for page type: ${err.message}`);
                pageType = 'unknown';
            }
        } else {
            pageType = 'unknown';
        }
    }
    log(context, `Page type determined: ${pageType}, hasAdminPermission: ${hasAdminPermission()}`);

    const shouldAddBackToAdmin = hasAdminPermission() && pageType.toLowerCase() !== 'admin' && pageType.toLowerCase() !== 'login';
    log(context, `Should add Back to Admin button: ${shouldAddBackToAdmin}`);
    if (shouldAddBackToAdmin) {
        log(context, 'Adding Back to Admin button');
        additionalButtons.push({
            section: 'back-to-admin',
            label: 'Back to Admin',
            icons: ['icon-admin'],
            action: () => switchRole('admin')
        });
    } else {
        log(context, 'Back to Admin button not added');
    }

    if (role !== 'login') {
        additionalButtons.push({
            label: 'Logoff',
            icons: ['fas fa-sign-out-alt'],
            action: handleLogoff
        });
    }

    const finalMenu = [...menuWithActions, ...additionalButtons];
    log(context, `Final menu for role ${role}:`, finalMenu.map(item => item.label));

    if (role === 'login') {
        const requiredSections = ['signupContainer', 'forgotPasswordContainer'];
        const hasRequired = requiredSections.every(section => 
            finalMenu.some(item => item.section === section)
        );
        if (!hasRequired) {
            warn(context, 'Login menu missing required sections, using default login menu');
            return [
                {
                    section: 'signupContainer',
                    label: 'Sign Up',
                    icons: ['fas fa-user-plus']
                },
                {
                    section: 'forgotPasswordContainer',
                    label: 'Forgot Password',
                    icons: ['fas fa-lock']
                }
            ];
        }
    }

    return finalMenu;
}

export function initializeMenusModule(registry) {
    log(context, 'Initializing menus module for module registry');
    return {
        getMenu: (role) => getMenu(role)
    };
}

withScriptLogging(context, () => {
    log(context, 'Module initialized');
    const loginMenu = getMenu('login');
    log(context, 'Login menu during initialization:', loginMenu.map(item => item.label));
    if (!loginMenu.some(item => item.section === 'signupContainer') || 
        !loginMenu.some(item => item.section === 'forgotPasswordContainer')) {
        warn(context, 'Sign Up or Forgot Password missing in login menu');
    }
});
config/messages.js
// /static/js/config/messages.js
// Purpose: Defines error and success messages for consistent use across the application.

// Error messages organized by category
export const ERROR_MESSAGES = {
  // General Errors
  DEFAULT: 'An unexpected error occurred. Please try again.',
  MODULE_INIT_FAILED: 'Failed to initialize module.',
  EVENT_HANDLER_FAILED: 'Event handler failed.',
  DATA_PROCESSING_FAILED: 'Failed to process data.',

  // API and Data Fetching Errors
  FETCH_FAILED: context => `Failed to fetch ${context} data.`,
  NO_DATA: context => `No ${context} available.`,
  NO_ENDPOINT: 'No API endpoint provided.',

  // DOM Manipulation Errors
  ELEMENT_NOT_FOUND: 'Required DOM element not found.',
  INVALID_TABLE_BODY: 'Invalid table body element.',
  TABLE_NOT_FOUND: 'Parent table not found.',
  SECTION_TOGGLE_FAILED: 'Failed to toggle section.',
  DOM_INSERTION_FAILED: 'Failed to insert DOM element.',
  DOM_REMOVAL_FAILED: 'Failed to remove DOM element.',
  DOM_PROPERTY_ACCESS_FAILED: 'Failed to access DOM element property.',
  INVALID_DOM_ELEMENT: 'Invalid DOM element provided.',
  DUPLICATE_ELEMENT_ID: 'Duplicate DOM element ID found.',

  // Rendering Errors
  RENDER_FAILED: context => `Failed to render ${context} data.`,
  CUSTOM_FIELD_RENDER_FAILED: 'Failed to render custom form fields.',
  MARKDOWN_RENDER_FAILED: 'Failed to render markdown content.',

  // Form and Validation Errors
  FORM_SUBMISSION_FAILED: 'Form submission failed.',
  FORM_VALIDATION_FAILED: 'Form validation failed.',
  ALL_FIELDS_REQUIRED: 'All fields are required.',
  INVALID_SETTINGS_TYPE: 'Invalid settings type specified.',
  INVALID_SETTINGS_DATA: 'Invalid settings data received.',
  NO_SETTINGS_FOUND: 'No settings found.',
  NO_DOMAIN: 'Domain is required.',
  INVALID_DOMAIN: 'Invalid domain format.',

  // Navigation Errors
  NAVIGATION_INIT_FAILED: 'Failed to initialize navigation.',

  // User and Authentication Errors
  USER_ID_NOT_FOUND: 'User ID not found.',
};

// Success messages organized by category
export const SUCCESS_MESSAGES = {
  // General Success
  DEFAULT: 'Operation successful.',

  // Rendering Success
  RENDERED: context => `${context} successfully rendered.`,
  USERS_RENDERED: 'Users rendered successfully.',

  // Form Submission Success
  SUBMITTED: context => `${context} successfully submitted.`,
  SETTINGS_UPDATED: 'Settings successfully updated.',
  CLICK_RECORDED: 'Click event recorded successfully.', // Added for click events
  ORDER_RECORDED: 'Order event recorded successfully.', // Added for order events

  // DOM Manipulation Success
  DOM_INSERTION_SUCCESS: 'DOM element inserted successfully.',
  DOM_REMOVAL_SUCCESS: 'DOM element removed successfully.',
  SECTION_TOGGLED: 'Section toggled successfully.',
};
config/pages.js
// /static/js/config/pages.js
// Purpose: Maps page types to their corresponding module paths for dynamic imports in main.js.

import { log } from '../core/logger.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Page module mappings for dynamic imports.
 * @type {Object.<string, string[]>}
 */
export const PAGE_MODULES = {
  admin: ['./admin-page.js'],
  login: ['./login-page.js'],
  merchant: ['./merchant/category-management.js', './merchant/site-request.js', './merchant/merchant-page.js'],
  partner: ['./partner/partner-page.js'],
  community: ['./community/category-management.js', './community/site-request.js', './community/community-page.js'],
};

/**
 * Initializes the pages module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Pages instance with public mappings.
 */
export function initializePagesModule(registry) {
  const context = 'pages.js';
  log(context, 'Initializing pages module for module registry');
  return {
    PAGE_MODULES,
  };
}

// Initialize module with lifecycle logging
const context = 'pages.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
config/roles.js
// /static/js/config/roles.js
// Purpose: Centralizes role definitions, permissions, and menu structures for consistent use across the application.

import { log } from '../core/logger.js';
import { setAuthToken } from '../core/auth.js'; // Use setAuthToken from core/auth.js
import { authenticatedFetch } from '../core/auth.js'; // authenticatedFetch is in utils/auth.js
import { withErrorHandling } from '../utils/error.js';
import { withScriptLogging } from '../utils/logging-utils.js';

const context = 'roles.js';

/**
 * Role definitions with associated permissions.
 * @type {Object.<string, {permissions: string[], label: string}>}
 */
export const ROLES = {
    admin: {
        permissions: ['admin', 'validated', 'debug'],
        label: 'Admin',
    },
    partner: {
        permissions: ['partner', 'validated', 'verified'],
        label: 'Partner',
    },
    community: {
        permissions: ['community', 'validated'],
        label: 'Community',
    },
    merchant: {
        permissions: ['merchant', 'validated', 'verified'],
        label: 'Merchant',
    },
    login: { // Added login role to match config/menus.js
        permissions: [],
        label: 'Login',
    },
};

/**
 * Menu structure for admin role.
 * @type {Array}
 */
export const ADMIN_MENU = [
    {
        section: 'userManagementIntro',
        label: 'User Management',
        icons: ['fas fa-users'],
        submenu: [
            { section: 'user_management', label: 'Admin', icons: ['icon-admin'], role: 'admin' },
            { section: 'user_management', label: 'Partners', icons: ['icon-partner'], role: 'partner' },
            { section: 'user_management', label: 'Communities', icons: ['icon-community'], role: 'community' },
            { section: 'user_management', label: 'Merchants', icons: ['icon-merchant'], role: 'merchant' },
        ],
    },
    { section: 'affiliates', label: 'Affiliate Programs', icons: ['fas fa-link'] },
    { section: 'site_settings', label: 'Site Settings', icons: ['fas fa-cog'] },
    {
        section: 'testScriptsIntro',
        label: 'Test Scripts',
        icons: ['fas fa-vial'],
        submenu: [
            {
                section: 'test_partner',
                label: 'Test Partner',
                icons: ['icon-partner', 'fas fa-vial'],
                action: async context => {
                    log(context, 'Test Partner button clicked, showing overlay and calling /set-role');
                    window.showLoadingOverlay?.();
                    await withErrorHandling(`${context}:testPartnerAction`, async () => {
                        const response = await authenticatedFetch('/set-role', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ role: 'partner' }),
                        });
                        if (!response.ok) {
                            throw new Error(`Failed to set role: ${response.status}`);
                        }
                        const data = await response.json();
                        log(context, 'Successfully set x-role to partner, response:', data);

                        if (data.token) {
                            setAuthToken(data.token); // Replaced tokenManagerSetToken with setAuthToken
                            log(context, 'Updated token with new x-role: partner');
                        }
                    }, 'Failed to set partner role');
                },
            },
        ],
    },
];

/**
 * Fetches the user's role from the server.
 * @returns {Promise<string>} The user's role.
 */
export async function fetchUserRole() {
    log(context, 'Fetching user role');
    try {
        const response = await authenticatedFetch('/api/user/role');
        const data = await response.json();
        return data.role || ROLES.LOGIN;
    } catch (error) {
        log(context, `Error fetching user role: ${error.message}`);
        return ROLES.LOGIN; // Default to login role if fetching fails
    }
}

/**
 * Initializes the roles module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Roles instance with public definitions.
 */
export function initializeRolesModule(registry) {
    log(context, 'Initializing roles module for module registry');
    return {
        ROLES,
        ADMIN_MENU,
        fetchUserRole,
    };
}

// Initialize module with lifecycle logging
withScriptLogging(context, () => {
    log(context, 'Module initialized');
});
config/settings.js
// /static/js/config/settings.js
// Purpose: Defines centralized configuration for settings across the application.

import { log } from '../core/logger.js';
import { API_ENDPOINTS } from './endpoints.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Settings configuration registry for admin and provider settings.
 * @type {Object.<string, Object>}
 */
export const SETTINGS = {
  affiliates: {
    containerId: 'affiliate-icons',
    formId: 'affiliate-form',
    fieldsId: 'affiliate-settings-container',
    endpoint: API_ENDPOINTS.SETTINGS_AFFILIATE,
    type: 'affiliate',
    iconClass: 'fas fa-link',
  },
  apiKeys: {
    containerId: 'api-keys-icons',
    formId: 'api-keys-form',
    fieldsId: 'api-keys-fields',
    endpoint: API_ENDPOINTS.SETTINGS_API_KEY,
    type: 'api-keys',
    iconClass: 'fas fa-key',
  },
  siteSettings: {
    containerId: 'site-settings-icons',
    formId: 'site-settings-form',
    fieldsId: 'site-settings-fields',
    endpoint: API_ENDPOINTS.SETTINGS_KEY,
    type: 'site-settings',
    iconClass: 'fas fa-cog',
  },
  provider: {
    containerId: 'provider-icons',
    formId: 'providerForm',
    fieldsId: 'providerContentArea',
    endpoint: API_ENDPOINTS.CLIENT_API_SETTINGS,
    type: 'provider',
    iconClass: 'fas fa-cog',
  },
};

/**
 * Retrieves a settings configuration by type.
 * @param {string} context - The context or module name.
 * @param {string} type - The type of settings (e.g., 'affiliates', 'apiKeys', 'siteSettings', 'provider').
 * @returns {Object} The settings configuration.
 * @throws {Error} If the settings type is unknown.
 */
export function getSettingsConfig(context, type) {
  log(context, `Retrieving settings config for type: ${type}`);
  const config = SETTINGS[type];
  if (!config) {
    throw new Error(`Unknown settings type: ${type}`);
  }
  return config;
}

/**
 * Initializes the settings module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Settings instance with public methods.
 */
export function initializeSettingsModule(registry) {
  const context = 'settings.js';
  log(context, 'Initializing settings module for module registry');
  return {
    SETTINGS,
    getSettingsConfig: (ctx, ...args) => getSettingsConfig(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'settings.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
core/auth.js
// /static/js/core/auth.js
// Purpose: Manages authentication tokens, authenticated requests, and user authentication checks.

import { log } from './logger.js';
import { setCookie, getCookie, removeCookie } from './cookies.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { API_ENDPOINTS } from '../config/endpoints.js';

const context = 'auth.js';

/**
 * Decodes the payload from a JWT token.
 * @param {string} token - The JWT token.
 * @returns {Object|null} The decoded payload or null if invalid.
 */
function decodeToken(token) {
    log(context, 'Decoding JWT token');
    try {
        const payload = JSON.parse(atob(token.split('.')[1]));
        return payload;
    } catch (e) {
        log(context, `Token decoding failed: ${e.message}`);
        return null;
    }
}

/**
 * Sets the authentication token in a cookie.
 * @param {string} token - The authentication token.
 */
export function setAuthToken(token) {
    log(context, 'Setting auth token');
    setCookie('auth_token', token, 7);
}

/**
 * Retrieves the authentication token from a cookie.
 * @returns {string|null} The authentication token, or null if not found.
 */
export function getAuthToken() {
    log(context, 'Getting auth token');
    return getCookie('auth_token');
}

/**
 * Removes the authentication token from cookies.
 */
export function removeAuthToken() {
    log(context, 'Removing auth token');
    removeCookie('auth_token');
}

/**
 * Makes an authenticated fetch request using the stored token.
 * @param {string} endpoint - The API endpoint to fetch from.
 * @param {Object} [options={}] - Fetch options.
 * @returns {Promise<Response>} The fetch response.
 * @throws {Error} If no token is found or the request fails.
 */
export async function authenticatedFetch(endpoint, options = {}) {
    log(context, `Making authenticated fetch to ${endpoint}`);
    const token = getAuthToken();
    if (!token) {
        throw new Error('No auth token found');
    }

    const headers = {
        ...options.headers,
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
    };

    const response = await fetch(`${API_ENDPOINTS.BASE}${endpoint}`, {
        ...options,
        headers,
    });

    if (!response.ok) {
        throw new Error(`Authenticated fetch failed: ${response.statusText}`);
    }

    return response;
}

/**
 * Wraps a function to ensure it runs only for an authenticated user, passing the userId.
 * @param {string} context - The context or module name.
 * @param {Function} fn - The async function to execute if authenticated, accepting userId.
 * @param {string} operation - The operation name for logging.
 * @returns {Promise<*>} The result of the function execution.
 * @throws {Error} If the user is not authenticated or the token is invalid.
 */
export async function withAuthenticatedUser(context, fn, operation) {
    log(context, `Checking authentication for ${operation || 'operation'}`);
    const token = getAuthToken();
    if (!token) {
        log(context, 'User not authenticated');
        throw new Error('User not authenticated');
    }
    const payload = decodeToken(token);
    if (!payload || (!payload.userId && !payload.user_id)) {
        log(context, 'Invalid token or missing userId');
        throw new Error('Invalid token');
    }
    const userId = payload.userId || payload.user_id;
    log(context, `Authenticated user with userId: ${userId} for operation: ${operation}`);
    return await fn(userId);
}

// Initialize module with lifecycle logging
withScriptLogging(context, () => {
    log(context, 'Module initialized');
});
core/cookies.js
// /static/js/core/cookies.js
// /static/js/core/cookies.js
import { log } from './logger.js';
import { withScriptLogging } from '../utils/logging-utils.js'; // Corrected import

const context = 'cookies.js';


export function setCookie(name, value, days) {
    log(context, `Setting cookie: ${name}`);
    let expires = '';
    if (days) {
        const date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        expires = `; expires=${date.toUTCString()}`;
    }
    document.cookie = `${name}=${value}${expires}; path=/; SameSite=Strict`;
}

export function getCookie(name) {
    log(context, `Getting cookie: ${name}`);
    const nameEQ = `${name}=`;
    const ca = document.cookie.split(';');
    for (let i = 0; i < ca.length; i++) {
        let c = ca[i];
        while (c.charAt(0) === ' ') {
            c = c.substring(1, c.length);
        }
        if (c.indexOf(nameEQ) === 0) {
            return c.substring(nameEQ.length, c.length);
        }
    }
    return null;
}

export function removeCookie(name) {
    log(context, `Removing cookie: ${name}`);
    document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; SameSite=Strict`;
}

export function initializeCookies() {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
}
core/logger.js
// /static/js/core/logger.js
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Logs a message to the console with the specified context.
 * @param {string} context - The context or module name.
 * @param {...any} args - Arguments to log.
 */
export function log(context, ...args) {
    console.log(`[${context}]`, ...args);
}

/**
 * Logs a warning to the console with the specified context.
 * @param {string} context - The context or module name.
 * @param {...any} args - Arguments to log.
 */
export function warn(context, ...args) {
    console.warn(`[${context}]`, ...args);
}

/**
 * Logs an error to the console with the specified context.
 * @param {string} context - The context or module name.
 * @param {...any} args - Arguments to log.
 */
export function error(context, ...args) {
    console.error(`[${context}]`, ...args);
}

/**
 * Initializes the logger module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Logger instance with public methods.
 */
export function initializeLoggerModule(registry) {
    const context = 'logger.js';
    log(context, 'Initializing logger module for module registry');
    return {
        log,
        warn,
        error,
    };
}

// Initialize module with lifecycle logging
const context = 'logger.js';
withScriptLogging(context, () => {
    log(context, 'Module initialized');
});
core/markdown.js
// /static/js/core/markdown.js
// Purpose: Provides markdown rendering functionality using marked.js.

import { log } from './logger.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Renders markdown content from a URL or string.
 * @param {string} context - The context or module name.
 * @param {string} contentOrUrl - The markdown content or URL to fetch it from.
 * @returns {Promise<string>} The rendered HTML content.
 */
export async function renderMarkdown(context, contentOrUrl) {
  log(context, `Rendering markdown from: ${contentOrUrl}`);
  return await withErrorHandling(`${context}:renderMarkdown`, async () => {
    let markdownContent;
    if (contentOrUrl.startsWith('http') || contentOrUrl.startsWith('/')) {
      const response = await fetch(contentOrUrl);
      if (!response.ok) {
        throw new Error(`Failed to fetch markdown: ${response.status}`);
      }
      markdownContent = await response.text();
    } else {
      markdownContent = contentOrUrl;
    }
    // Use global window.marked with fallback to raw content
    return window.marked ? window.marked.parse(markdownContent) : markdownContent;
  }, ERROR_MESSAGES.MARKDOWN_RENDER_FAILED);
}

/**
 * Initializes the markdown module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Markdown instance with public methods.
 */
export function initializeMarkdownModule(registry) {
  const context = 'markdown.js';
  log(context, 'Initializing markdown module for module registry');
  return {
    renderMarkdown: (ctx, ...args) => renderMarkdown(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'markdown.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
core/mce.js
// /static/js/core/mce.js
// Purpose: Initializes TinyMCE editor for rich text editing.

import { log } from './logger.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Initializes TinyMCE editor on the specified selector.
 * @param {string} context - The context or module name.
 * @param {string} selector - The CSS selector for the textarea to initialize TinyMCE on.
 * @returns {Promise<void>}
 */
export async function initializeTinyMCE(context, selector) {
  log(context, `Initializing TinyMCE on selector: ${selector}`);
  await withErrorHandling(`${context}:initializeTinyMCE`, async () => {
    if (!window.tinymce) {
      throw new Error('TinyMCE library not loaded');
    }
    await window.tinymce.init({
      selector,
      plugins: 'lists link image table code',
      toolbar: 'undo redo | bold italic | alignleft aligncenter alignright | bullist numlist outdent indent | link image',
      menubar: false,
      statusbar: false,
      height: 300,
    });
    log(context, 'TinyMCE initialized successfully');
  }, ERROR_MESSAGES.MODULE_INIT_FAILED);
}

/**
 * Initializes the TinyMCE module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} TinyMCE instance with public methods.
 */
export function initializeMceModule(registry) {
  const context = 'mce.js';
  log(context, 'Initializing TinyMCE module for module registry');
  return {
    initializeTinyMCE: (ctx, ...args) => initializeTinyMCE(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'mce.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
core/notifications.js
// /static/js/core/notifications.js
// Purpose: Provides notification utilities using Toastr with fallback to alerts.

import { log, error as loggerError, warn as loggerWarn } from './logger.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { createModuleInitializer } from '../utils/initialization.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/messages.js'; // Updated import

const context = 'notifications.js';

/**
 * Sets up Toastr with custom logging and configuration.
 * @param {string} context - The context or module name.
 * @returns {boolean} Whether Toastr was successfully set up.
 */
export function setupToastr(context) {
    log(context, 'Setting up Toastr');
    if (typeof toastr === 'undefined') {
        loggerError(context, 'Toastr library not loaded');
        return false;
    }

    const originalSuccess = toastr.success;
    const originalError = toastr.error;
    const originalInfo = toastr.info;
    const originalWarning = toastr.warning;

    toastr.success = (message, title, options) => {
        log(context, `Toastr Success: ${title ? title + ' - ' : ''}${message}`);
        return originalSuccess.call(toastr, message, title, options);
    };
    toastr.error = (message, title, options) => {
        log(context, `Toastr Error: ${title ? title + ' - ' : ''}${message}`);
        return originalError.call(toastr, message, title, options);
    };
    toastr.info = (message, title, options) => {
        log(context, `Toastr Info: ${title ? title + ' - ' : ''}${message}`);
        return originalInfo.call(toastr, message, title, options);
    };
    toastr.warning = (message, title, options) => {
        log(context, `Toastr Warning: ${title ? title + ' - ' : ''}${message}`);
        return originalWarning.call(toastr, message, title, options);
    };

    toastr.options = {
        closeButton: true,
        progressBar: true,
        positionClass: 'toast-top-right',
        timeOut: 5000,
        showMethod: 'slideDown',
        hideMethod: 'slideUp'
    };

    log(context, 'Toastr configured:', toastr.options);
    return true;
}

/**
 * Displays a success notification.
 * @param {string} context - The context or module name.
 * @param {string} message - The message to display.
 * @param {string} [title] - The title of the notification.
 * @param {Object} [options] - Toastr options.
 */
export function success(context, message, title, options) {
    if (typeof toastr !== 'undefined' && setupToastr(context)) {
        toastr.success(message, title, options);
    } else {
        loggerWarn(context, 'Toastr not available, fallback to alert:', message);
        alert(`Success: ${title ? title + ' - ' : ''}${message}`);
    }
}

/**
 * Displays an error notification.
 * @param {string} context - The context or module name.
 * @param {string} message - The message to display.
 * @param {string} [title] - The title of the notification.
 * @param {Object} [options] - Toastr options.
 */
export function error(context, message, title, options) {
    if (typeof toastr !== 'undefined' && setupToastr(context)) {
        toastr.error(message, title, options);
    } else {
        loggerWarn(context, 'Toastr not available, fallback to alert:', message);
        alert(`Error: ${title ? title + ' - ' : ''}${message}`);
    }
}

/**
 * Displays an info notification.
 * @param {string} context - The context or module name.
 * @param {string} message - The message to display.
 * @param {string} [title] - The title of the notification.
 * @param {Object} [options] - Toastr options.
 */
export function info(context, message, title, options) {
    if (typeof toastr !== 'undefined' && setupToastr(context)) {
        toastr.info(message, title, options);
    } else {
        loggerWarn(context, 'Toastr not available, fallback to alert:', message);
        alert(`Info: ${title ? title + ' - ' : ''}${message}`);
    }
}

/**
 * Displays a warning notification.
 * @param {string} context - The context or module name.
 * @param {string} message - The message to display.
 * @param {string} [title] - The title of the notification.
 * @param {Object} [options] - Toastr options.
 */
export function warning(context, message, title, options) {
    if (typeof toastr !== 'undefined' && setupToastr(context)) {
        toastr.warning(message, title, options);
    } else {
        loggerWarn(context, 'Toastr not available, fallback to alert:', message);
        alert(`Warning: ${title ? title + ' - ' : ''}${message}`);
    }
}

/**
 * Notifies the result of an operation with success or error.
 * @param {string} context - The context or module name.
 * @param {Object} params - Operation result parameters.
 * @param {boolean} params.success - Whether the operation was successful.
 * @param {string} [params.message] - The message to display.
 * @param {string} [params.defaultSuccess] - Default success message.
 * @param {string} [params.defaultError] - Default error message.
 */
export function notifyOperationResult(context, { success: isSuccess, message, defaultSuccess = SUCCESS_MESSAGES.DEFAULT, defaultError = ERROR_MESSAGES.DEFAULT }) {
    log(context, `Notifying operation result: ${isSuccess ? 'success' : 'error'}, message: ${message}`);
    const notificationMessage = isSuccess ? (message || defaultSuccess) : (message || defaultError);
    if (isSuccess) {
        success(context, notificationMessage);
    } else {
        error(context, notificationMessage);
    }
}

/**
 * Initializes the notifications module for use with the module registry.
 * @param {Map} registry - The module registry instance.
 * @returns {Object} Module instance with public methods.
 */
export function initializeNotificationsModule(registry) {
    log(context, 'Initializing notifications module for module registry');
    setupToastr(context);
    return {
        success: (ctx, ...args) => success(ctx, ...args),
        error: (ctx, ...args) => error(ctx, ...args),
        info: (ctx, ...args) => info(ctx, ...args),
        warning: (ctx, ...args) => warning(ctx, ...args),
        notifyOperationResult: (ctx, ...args) => notifyOperationResult(ctx, ...args),
    };
}

// Initialize module with lifecycle logging
withScriptLogging(context, () => {
    log(context, 'Module initialized');
    setupToastr(context);
});
core/user.js
// /static/js/core/user.js
// Purpose: Manages user-related operations, such as fetching user data and validating user IDs.

import { log } from './logger.js';
import { authenticatedFetch } from './auth.js';
import { withErrorHandling } from '../utils/error.js';
import {  ERROR_MESSAGES } from '../config/constants.js';
import { API_ENDPOINTS } from '../config/endpoints.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Fetches user data for the specified user ID.
 * @param {string} context - The context or module name.
 * @param {string} userId - The user ID.
 * @returns {Promise<Object>} The user data.
 */
export async function fetchUser(context, userId) {
  log(context, `Fetching user data for userId: ${userId}`);
  return await withErrorHandling(`${context}:fetchUser`, async () => {
    const response = await authenticatedFetch(context, API_ENDPOINTS.USERS_USERID(userId));
    const data = await response.json();
    if (data.status === 'error') {
      throw new Error(data.message || ERROR_MESSAGES.FETCH_FAILED('user'));
    }
    return data;
  }, ERROR_MESSAGES.FETCH_FAILED('user'));
}

/**
 * Validates the user ID from localStorage or DOM.
 * @param {string} context - The context or module name.
 * @returns {Promise<string>} The validated user ID.
 * @throws {Error} If no valid user ID is found.
 */
export async function validateUserId(context) {
  log(context, 'Validating user ID');
  return await withErrorHandling(`${context}:validateUserId`, async () => {
    let userId = localStorage.getItem('userId');
    if (!userId) {
      const userIdInput = document.getElementById('userId');
      userId = userIdInput?.value;
      if (!userId) {
        throw new Error(ERROR_MESSAGES.USER_ID_NOT_FOUND);
      }
      localStorage.setItem('userId', userId);
    }
    log(context, `Validated user ID: ${userId}`);
    return userId;
  }, ERROR_MESSAGES.USER_ID_NOT_FOUND);
}

/**
 * Initializes the user module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} User instance with public methods.
 */
export function initializeUserModule(registry) {
  const context = 'user.js';
  log(context, 'Initializing user module for module registry');
  return {
    fetchUser: (ctx, ...args) => fetchUser(ctx, ...args),
    validateUserId: (ctx, ...args) => validateUserId(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'user.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
login/forgot-password.js
// /static/js/login/forgot-password.js
import { log } from '../core/logger.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { toggleViewState, withElement } from '../utils/dom-manipulation.js';
import { API_ENDPOINTS, ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Initializes the forgot password form in the specified section.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeForgotPassword(context) {
  log(context, 'Initializing forgot password form');
  await withElement(context, 'forgotPasswordContainer', async (section) => {
    // Ensure all other sections are hidden
    document.querySelectorAll('.section').forEach(s => {
      if (s.id !== 'forgotPasswordContainer') s.style.display = 'none';
    });
    // Show the target section
    section.style.display = 'block';
    toggleViewState(context, { forgotPasswordContainer: true });

    // Set up forgot password form submission
    submitConfiguredForm(context, 'forgotPasswordForm', API_ENDPOINTS.RESET_PASSWORD, 'forgotPassword', {
      onSuccess: async (data) => {
        log(context, 'Forgot password request successful, showing OTP section');
        if (data.otp_token) {
          localStorage.setItem('resetToken', data.otp_token);  // Correctly use otp_token
          log(context, 'Stored resetToken:', data.otp_token);
        } else {
          log(context, 'No otp_token in response');
          alert('Failed to receive OTP token from server.');
          return;
        }
        await withElement(context, 'verifyOtpSection', async otpSection => {
          toggleViewState(context, { verifyOtpSection: true });
          // Populate the otpToken field with the stored token
          const otpTokenInput = document.getElementById('otpToken');
          if (otpTokenInput) {
            const token = localStorage.getItem('resetToken');
            if (token) {
              otpTokenInput.value = token;
              log(context, `Set otpToken to: ${token}`);
            } else {
              log(context, 'No reset token found in localStorage');
            }
          } else {
            log(context, 'otpToken input not found');
          }
        });
      },
      onError: (error) => {
        log(context, 'Forgot password error:', error.message);
        alert(ERROR_MESSAGES.FORM_SUBMISSION_FAILED || 'Failed to send OTP. Please try again.');
      },
    });

    // Set up verify OTP form submission
    submitConfiguredForm(context, 'verifyOtpForm', API_ENDPOINTS.VERIFY_RESET_CODE, 'verifyOtp', {
      onSuccess: (data) => {
        log(context, 'OTP verified, redirecting to login');
        localStorage.removeItem('resetToken');
        window.location.href = '/';
      },
      onError: (error) => {
        log(context, 'OTP verification error:', error.message);
        alert(ERROR_MESSAGES.FORM_SUBMISSION_FAILED || 'Failed to verify OTP. Please try again.');
      },
    });

    // Set up password toggle for verify OTP form
    const verifyOtpSection = document.getElementById('verifyOtpSection');
    if (verifyOtpSection) {
      const toggleButtons = verifyOtpSection.querySelectorAll('.toggle-password, .toggle-password-icon');
      toggleButtons.forEach(toggleButton => {
        toggleButton.addEventListener('click', () => {
          const passwordInput = toggleButton.closest('.password-wrapper').querySelector('input[type="password"], input[type="text"]');
          const icon = toggleButton.querySelector('i') || toggleButton;
          if (passwordInput.type === 'password') {
            passwordInput.type = 'text';
            icon.classList.replace('fa-eye', 'fa-eye-slash');
          } else {
            passwordInput.type = 'password';
            icon.classList.replace('fa-eye-slash', 'fa-eye');
          }
        });
      });
    }
  });
}

/**
 * Initializes the forgot password module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Forgot password instance with public methods.
 */
export function initializeForgotPasswordModule(registry) {
  const context = 'forgot-password.js';
  log(context, 'Initializing forgot password module for module registry');
  return {
    initializeForgotPassword: ctx => initializeForgotPassword(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'forgot-password.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
login/login.js
// /static/js/login/login.js
import { log } from '../core/logger.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { setCookie } from '../core/cookies.js';
import { setAuthToken } from '../core/auth.js';
import { withElement, toggleViewState } from '../utils/dom-manipulation.js';
import { API_ENDPOINTS } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Initializes the login form in the specified section.
 * @param {string} context - The context or module name.
 * @param {string} targetSection - The ID of the section to initialize (e.g., 'info').
 * @returns {Promise<void>}
 */
export async function initializeLogin(context, targetSection) {
  log(context, `Initializing login form in section: ${targetSection}`);
  await withElement(context, targetSection, async (section) => {
    // Ensure all other sections are hidden
    document.querySelectorAll('.section').forEach(s => {
      if (s.id !== targetSection) s.style.display = 'none';
    });
    // Show the target section
    section.style.display = 'block';
    toggleViewState(context, { [targetSection]: true });

    // Set up form submission
    submitConfiguredForm(context, 'loginForm', API_ENDPOINTS.LOGIN, 'login', {
      onSuccess: data => {
        log(context, 'Login successful, setting token and cookie');
        setAuthToken(data.token);
        if (data.user_id) localStorage.setItem('userId', data.user_id);
        setCookie('authToken', data.token, 7);
        window.location.reload();
      },
    });

    // Set up password toggle
    const togglePassword = section.querySelector('.toggle-password, .toggle-password-icon');
    if (togglePassword) {
      log(context, 'Toggle-password element found, binding event listener');
      togglePassword.addEventListener('click', () => {
        log(context, 'Toggle-password clicked');
        const passwordInput = section.querySelector('#loginPassword');
        const icon = togglePassword.querySelector('i') || togglePassword;
        if (passwordInput) {
          if (passwordInput.type === 'password') {
            passwordInput.type = 'text';
            icon.classList.replace('fa-eye', 'fa-eye-slash');
            log(context, 'Password visibility toggled to text');
          } else {
            passwordInput.type = 'password';
            icon.classList.replace('fa-eye-slash', 'fa-eye');
            log(context, 'Password visibility toggled to password');
          }
        } else {
          log(context, 'Password input #loginPassword not found');
        }
      });
    } else {
      log(context, 'Toggle-password element not found in section');
    }

    // Set up existing Forgot Password button
    const forgotPasswordButton = document.getElementById('forgotPasswordButton');
    if (forgotPasswordButton) {
      log(context, 'Forgot Password button found, binding event listener');
      forgotPasswordButton.addEventListener('click', (e) => {
        e.preventDefault();
        toggleViewState(context, { forgotPasswordContainer: true });
      });
    } else {
      log(context, 'Forgot Password button not found');
    }
  });
}

/**
 * Initializes the login module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Login instance with public methods.
 */
export function initializeLoginModule(registry) {
  const context = 'login.js';
  log(context, 'Initializing login module for module registry');
  return {
    initializeLogin: (ctx, ...args) => initializeLogin(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'login.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
login/set-password.js
// /static/js/login/set-password.js
import { log } from '../core/logger.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { withElement } from '../utils/dom-manipulation.js';
import { API_ENDPOINTS } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';

const context = 'set-password.js';

/**
 * Initializes the set password form in the specified section.
 * @param {string} context - The context or module name.
 * @param {string} sectionId - The ID of the section containing the form.
 * @returns {Promise<void>}
 */
export async function initializeSetPassword(context, sectionId) {
  log(context, `Initializing set password form in section: ${sectionId}`);
  await withElement(context, sectionId, async (section) => {
    // Hide other sections
    document.querySelectorAll('.section').forEach(s => {
      if (s.id !== sectionId) s.style.display = 'none';
    });
    // Show the target section
    section.style.display = 'block';

    // Set up form submission to the correct endpoint
    submitConfiguredForm(context, 'setPasswordForm', API_ENDPOINTS.COMPLETE_SIGNUP, 'setPassword', {
      onSuccess: (data) => {
        log(context, 'Password set successfully');
        // Redirect or update UI as needed
        window.location.href = '/';
      },
      onError: (err) => {
        log(context, 'Error setting password:', err.message);
      },
    });
  });
}

/**
 * Initializes the set password module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Module instance with public methods.
 */
export function initializeSetPasswordModule(registry) {
  log(context, 'Initializing set password module');
  return {
    initializeSetPassword: (ctx, ...args) => initializeSetPassword(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
login/signup.js
// /static/js/login/signup.js
import { log } from '../core/logger.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { setupFormFieldEvents } from '../utils/event-listeners.js';
import { toggleViewState, withElement } from '../utils/dom-manipulation.js';
import { API_ENDPOINTS } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';

const context = 'signup';

/**
 * Initializes the signup section on the login page.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeSignup(context) {
    log(context, 'Initializing signup section');

    await withElement(context, 'signupContainer', async (section) => {
        // Hide other sections and show signupContainer
        document.querySelectorAll('.section').forEach(s => {
            if (s.id !== 'signupContainer') s.style.display = 'none';
        });
        toggleViewState(context, { signupContainer: true });

        // Configure the signup form submission
        await withElement(context, 'signupForm', async (form) => {
            // Ensure "Community" is the default signup type
            document.querySelectorAll('.option').forEach(option => option.classList.remove('selected'));
            const communityOption = form.querySelector('input[value="community"]');
            if (communityOption) {
                communityOption.checked = true;
                communityOption.closest('.option').classList.add('selected');
            }

            log(context, 'Configuring signup form submission');
            submitConfiguredForm(context, 'signupForm', API_ENDPOINTS.SIGNUP, 'signup', {
                onSuccess: async (response, formData) => {
                    log(context, 'Signup successful, response:', response);
                    // Get the role from the form data or response
                    const role = response.signup_type || formData.get('signup_type');
                    if (!role) {
                        log(context, 'Error: No role specified in response or form data');
                        alert('Signup successful, but no role specified. Please try again.');
                        return;
                    }

                    if (response.account_link) {
                        log(context, 'Redirecting to Stripe:', response.account_link);
                        window.location.href = response.account_link;
                    } else {
                        log(context, 'Error: account_link missing in response');
                        alert('Signup successful, but unable to redirect to Stripe. Please try again later.');
                    }
                },
                onError: (err) => {
                    log(context, 'Signup error:', err.message);
                    alert(`Signup failed: ${err.message}`);
                }
            });

            // Set up radio button events for signup type selection
            setupFormFieldEvents(context, {
                selector: 'input[name="signup_type"]',
                eventType: 'change',
                handler: e => {
                    document.querySelectorAll('.option').forEach(option => {
                        option.classList.toggle('selected', option.contains(e.target));
                    });
                    log(context, 'Selected signup type:', e.target.value);
                },
            });
        }, 10, 100, false);
    }, 10, 100, false);
}

/**
 * Initializes the signup module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Signup instance with public methods.
 */
export function initializeSignupModule(registry) {
    log(context, 'Initializing signup module for module registry');
    return {
        initializeSignup: ctx => initializeSignup(ctx),
    };
}

// Initialize module with lifecycle logging
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
login-page.js
// /static/js/login-page.js
import { log, warn, error as logError } from './core/logger.js';
import { withErrorHandling } from './utils/error.js';
import { toggleViewState, withElement } from './utils/dom-manipulation.js';
import { getMenu } from './config/menus.js';
import { initializeRoleNavigation, defineSectionHandlers } from './modules/navigation.js';
import { hideOverlay, getDefaultSectionFromQuery, shouldInitializeForPageType } from './utils/initialization.js';
import { withScriptLogging } from './utils/logging-utils.js';
import { initializeLogin } from './login/login.js';
import { initializeSignup } from './login/signup.js';
import { initializeForgotPassword } from './login/forgot-password.js';
import { initializeSetPassword } from './login/set-password.js';
import { error as notifyError } from './core/notifications.js';
import { submitConfiguredForm } from './utils/form-submission.js';

const context = 'login-page.js';

export async function initializeLoginPage({ registry }) {
    log(context, 'Starting initializeLoginPage');
    try {
        const metaPageType = document.querySelector('meta[name="page-type"]')?.content || 'login';
        log(context, `Page type: ${metaPageType}`);
        if (metaPageType !== 'login') {
            log(context, 'Skipping initialization for non-login page');
            return;
        }
        const loginForms = document.querySelectorAll('#loginForm');
        if (loginForms.length > 1) {
            log(context, `Found ${loginForms.length} loginForms, removing duplicates`);
            Array.from(loginForms).slice(1).forEach(form => form.remove());
        }
        const sectionHandlers = {
            'info': async () => {
                log(context, 'Initializing info section (login form)');
                await initializeLogin(context, 'info');
            },
            'signupContainer': async () => {
                log(context, 'Initializing signup section');
                await initializeSignup(context);
            },
            'forgotPasswordContainer': async () => {
                log(context, 'Initializing forgot-password section');
                await initializeForgotPassword(context);
            },
            'completeSignup': async () => {
                log(context, 'Initializing completeSignup section');
                toggleViewState(context, { completeSignup: true });
                await initializeSetPassword(context, 'completeSignup');
                submitConfiguredForm(context, 'setPasswordForm', '/complete-signup', 'completeSignup', {
                    onSuccess: async (response) => {
                        log(context, 'Complete signup successful, response:', response);
                        window.location.href = '/';
                    },
                    onError: (err) => {
                        logError(context, 'Complete signup error:', err.message);
                        notifyError(context, err.message || 'Error completing signup');
                    }
                });
            },
            'failSignupContainer': async () => {
                log(context, 'Initializing failSignup section');
                toggleViewState(context, { failSignupContainer: true });
                notifyError(context, 'Signup failed. Please try again.');
            }
        };
        log(context, 'Defined section handlers:', Object.keys(sectionHandlers));
        const role = 'login';
        const initialSection = await getDefaultSectionFromQuery(context, role, 'info');
        log(context, `Initial section from query: ${initialSection}`);
        const menu = getMenu(role);
        log(context, `Menu for role ${role}: ${JSON.stringify(menu)}`);
        await withElement(context, 'menu', async (menuElement) => {
            log(context, 'Menu element found, rendering buttons');
            menuElement.innerHTML = '';
            menuElement.style.display = 'block';
            if (!menu || !Array.isArray(menu) || menu.length === 0) {
                warn(context, `Invalid or empty menu for role: ${role}, rendering fallback buttons`);
                menuElement.innerHTML = `
                    <button data-section="forgotPasswordContainer" style="display: inline-block; margin: 5px;">
                        <i class="fas fa-lock"></i> Forgot Password
                    </button>
                    <button data-section="signupContainer" style="display: inline-block; margin: 5px;">
                        <i class="fas fa-user-plus"></i> Sign Up
                    </button>
                `;
            } else {
                try {
                    await initializeRoleNavigation(menuElement, menu, { 
                        sectionHandlers, 
                        defaultSection: initialSection 
                    });
                    log(context, 'Menu rendering completed');
                } catch (error) {
                    logError(context, `Menu rendering failed: ${error.message}`);
                    menuElement.innerHTML = `
                        <button data-section="forgotPasswordContainer" style="display: inline-block; margin: 5px;">
                            <i class="fas fa-lock"></i> Forgot Password
                        </button>
                        <button data-section="signupContainer" style="display: inline-block; margin: 5px;">
                            <i class="fas fa-user-plus"></i> Sign Up
                        </button>
                    `;
                }
                const buttons = menuElement.querySelectorAll('button');
                if (buttons.length === 0) {
                    warn(context, 'No buttons rendered, forcing fallback');
                    menuElement.innerHTML = `
                        <button data-section="forgotPasswordContainer" style="display: inline-block; margin: 5px;">
                            <i class="fas fa-lock"></i> Forgotten Password
                        </button>
                        <button data-section="signupContainer" style="display: inline-block; margin: 5px;">
                            <i class="fas fa-user-plus"></i> Sign Up
                        </button>
                    `;
                } else {
                    log(context, `Rendered ${buttons.length} menu buttons`);
                }
            }
            if (initialSection && sectionHandlers[initialSection]) {
                log(context, `Triggering initial section handler for: ${initialSection}`);
                await sectionHandlers[initialSection]();
            } else {
                log(context, `No handler found for initial section: ${initialSection}, defaulting to info`);
                await sectionHandlers['info']();
            }
        }, 3, 50, false);
        hideOverlay();
    } catch (err) {
        logError(context, `initializeLoginPage failed: ${err.message}, ${err.stack}`);
    }
    log(context, 'initializeLoginPage completed');
}

export function initializeLoginPageModule(registry) {
    log(context, 'Initializing login page for module registry');
    return {
        initializeLoginPage: (options) => initializeLoginPage(options),
    };
}

if (shouldInitializeForPageType('login')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
} else {
    log(context, 'Skipping initialization for non-login page');
}
main.js
// /static/js/main.js
// Purpose: Entry point for the application, initializing modules based on page type and handling referral tracking.

import { log, error as logError } from './core/logger.js';
import { withErrorHandling } from './utils/error.js';
import { parsePageType, hideOverlay } from './utils/initialization.js';
import { initializeNotificationsModule } from './core/notifications.js';
import { initializeLoggerModule } from './core/logger.js';
import { initializeCookies } from './core/cookies.js';
import { initializeEndpointsModule } from './config/endpoints.js';
import { initializePagesModule } from './config/pages.js';
import * as auth from './core/auth.js';
import { initializeMenusModule } from './config/menus.js';
import { initializeNavigationModule } from './modules/navigation.js';
import { initializeIconsModule } from './utils/icons.js';
import { initializeDomManipulationModule } from './utils/dom-manipulation.js';
import { initializeInitializationModule } from './utils/initialization.js';
import { initializeLoginPageModule } from './login-page.js';
import { initializeAdminPageModule } from './admin-page.js';
import { initializeMerchantPageModule } from './merchant-page.js';
import { initializeCommunityPageModule } from './community-page.js';
import { initializePartnerPageModule } from './partner-page.js';
import { error as notifyError } from './core/notifications.js';
import { withScriptLogging } from './utils/logging-utils.js';
import { initializeMarkdownModule } from './core/markdown.js';
import { API_ENDPOINTS } from './config/endpoints.js';

const context = 'main.js';

// Module registry to store initialized modules
const registry = new Map();

// Define page-specific module initialization configurations
const PAGE_MODULES = {
    login: [{ name: 'login-page', initializer: initializeLoginPageModule }],
    admin: [{ name: 'admin-page', initializer: initializeAdminPageModule }],
    merchant: [{ name: 'merchant-page', initializer: initializeMerchantPageModule }],
    community: [{ name: 'community-page', initializer: initializeCommunityPageModule }],
    partner: [{ name: 'partner-page', initializer: initializePartnerPageModule }],
};

/**
 * Sends a click event to the /event endpoint based on URL query parameters.
 */
async function trackReferralClick(context) {
    log(context, 'Checking for referral tracking parameters');
    const urlParams = new URLSearchParams(window.location.search);
    const sourceUserId = urlParams.get('source_user_id');
    const destinationUserId = urlParams.get('destination_user_id');

    if (!sourceUserId || !destinationUserId) {
        log(context, 'No source_user_id or destination_user_id in URL, skipping referral tracking');
        return;
    }

    await withErrorHandling(`${context}:trackReferralClick`, async () => {
        const data = { source_user_id: sourceUserId, destination_user_id: destinationUserId };
        log(context, `Sending click event to ${API_ENDPOINTS.EVENT}:`, data);

        const response = await fetch(API_ENDPOINTS.EVENT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data),
        });

        const result = await response.json();
        if (response.ok && result.status === 'success') {
            log(context, 'Click event recorded successfully:', result.message);
        } else {
            throw new Error(result.message || 'Failed to record click event');
        }
    }, 'Failed to track referral click', (err) => {
        logError(context, `Referral tracking error: ${err.message}`);
        notifyError(context, 'Failed to track referral');
    });
}

/**
 * Initializes core modules required for all pages.
 */
async function initializeCoreModules() {
    log(context, 'Initializing core modules');
    await withErrorHandling(`${context}:initializeCoreModules`, async () => {
        registry.set('logger', initializeLoggerModule(registry));
        registry.set('cookies', {
            setCookie: (name, value, days) => import('./core/cookies.js').then(m => m.setCookie(name, value, days)),
            getCookie: name => import('./core/cookies.js').then(m => m.getCookie(name)),
            removeCookie: name => import('./core/cookies.js').then(m => m.removeCookie(name)),
        });
        initializeCookies();
        registry.set('endpoints', initializeEndpointsModule(registry));
        registry.set('pages', initializePagesModule(registry));
        registry.set('auth', {
            setAuthToken: auth.setAuthToken,
            getAuthToken: auth.getAuthToken,
            removeAuthToken: auth.removeAuthToken,
            authenticatedFetch: auth.authenticatedFetch,
            withAuthenticatedUser: auth.withAuthenticatedUser,
        });
        registry.set('notifications', initializeNotificationsModule(registry));
        registry.set('menus', initializeMenusModule(registry));
        registry.set('navigation', initializeNavigationModule(registry));
        registry.set('icons', initializeIconsModule(registry));
        registry.set('dom-manipulation', initializeDomManipulationModule(registry));
        registry.set('initialization', initializeInitializationModule(registry));
        registry.set('markdown', initializeMarkdownModule(registry));
    }, 'Failed to initialize core modules');
}

/**
 * Initializes the application by setting up core modules and page-specific modules.
 */
async function initializeApp() {
    log(context, 'Initializing application');

    await initializeCoreModules();
    await trackReferralClick(context);

    let pageType = document.querySelector('meta[name="page-type"]')?.content || 'login';
    log(context, `Initial page type from meta: ${pageType}`);

    const validPageTypes = ['login', 'admin', 'merchant', 'community', 'partner'];
    if (!validPageTypes.includes(pageType)) {
        log(context, `Invalid page type from meta: ${pageType}, falling back to parsePageType`);
        pageType = await parsePageType(context, 'page', 'login');
    }
    log(context, `Resolved page type: ${pageType}`);

    if (!validPageTypes.includes(pageType)) {
        log(context, `Invalid page type: ${pageType}, redirecting to login with section`);
        const section = pageType === 'signup' ? 'signupContainer' : 'info';
        window.location.href = `/?section=${section}`;
        return;
    }

    const modules = PAGE_MODULES[pageType] || [];
    if (modules.length === 0) {
        logError(context, `No modules defined for page type: ${pageType}`);
        notifyError(context, `Failed to load ${pageType} page. Please refresh the page.`);
        return;
    }

    if (pageType === 'login') {
        for (const module of modules) {
            try {
                log(context, `Initializing module: ${module.name}`);
                const instance = module.initializer(registry);
                registry.set(module.name, instance);
                await instance.initializeLoginPage({ registry });
                log(context, `Module ${module.name} initialized successfully`);
            } catch (err) {
                logError(context, `Failed to initialize module ${module.name}: ${err.message}, ${err.stack}`);
                notifyError(context, `Failed to load ${module.name} module. Please refresh the page.`);
            }
        }
    } else {
        const token = auth.getAuthToken();
        if (!token) {
            log(context, 'No auth token found, redirecting to login');
            window.location.href = '/?section=info';
            return;
        }

        for (const module of modules) {
            try {
                log(context, `Initializing module: ${module.name}`);
                const instance = module.initializer(registry);
                registry.set(module.name, instance);
                if (pageType === 'admin') {
                    await instance.initializeAdmin('admin');
                } else if (pageType === 'merchant') {
                    await instance.initializeMerchantPage(context);
                } else if (pageType === 'community') {
                    await instance.initializeCommunityPage(context);
                } else if (pageType === 'partner') {
                    await instance.initializePartnerPage(context);
                }
                log(context, `Module ${module.name} initialized successfully`);
            } catch (err) {
                logError(context, `Failed to initialize module ${module.name}: ${err.message}, ${err.stack}`);
                notifyError(context, `Failed to load ${module.name} module. Please refresh the page.`);
            }
        }
    }

    // Allow specific form submissions handled by their respective modules
    document.addEventListener('submit', event => {
        const form = event.target;
        if ((form.id === 'siteRequestForm' && form.dataset.siteRequestHandled) || 
            form.id === 'category-form') {
            log(context, `Allowing submission for form ID: ${form.id}, handled by respective module`);
            // Do not prevent default or stop propagation, let module-specific handlers manage
        } else {
            log(context, `Form submission detected for form ID: ${form.id || 'unknown'}`);
            event.preventDefault(); // Prevent direct submission for unhandled forms
        }
    }, { capture: true });

    // Prevent redundant click handlers for saveSiteRequest
    document.addEventListener('click', event => {
        if (event.target.dataset.action === 'saveSiteRequest') {
            const form = document.querySelector('#siteRequestForm');
            if (form && form.dataset.saveSiteRequestHandled) {
                log(context, 'Save Site Request button already handled, ignoring');
                event.preventDefault();
                event.stopPropagation();
            }
        }
    }, { capture: true });

    log(context, 'All modules initialized');
    hideOverlay();
}

/**
 * Initializes the main module with lifecycle logging.
 */
withScriptLogging(context, async () => {
    await initializeApp();
    log(context, 'Module initialized');
});
merchant/api-keys-events.js
// /static/js/merchant/api-keys-events.js
import { log } from '../core/logger.js';
import { setupEventListeners } from '../utils/event-listeners.js';
import { fetchData } from '../utils/data-fetch.js';
import { success, error } from '../core/notifications.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';

const context = 'merchant/api-keys-events.js';

export function setupApiKeyEvents(context) {
    log(context, 'Setting up API key event listeners');
    setupEventListeners(context, [
        {
            eventType: 'submit',
            selector: '#api-keys-form',
            handler: async (event) => {
                event.preventDefault();
                await withErrorHandling(`${context}:submitApiKeyForm`, async () => {
                    const form = event.target;
                    const keyType = form.dataset.keyType;
                    const fields = {};
                    Array.from(form.querySelectorAll('input')).forEach(input => {
                        fields[input.name] = input.value;
                    });
                    await fetchData(context, `/settings/api_key/${keyType}`, {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(fields),
                    });
                    success(context, SUCCESS_MESSAGES.SETTINGS_UPDATED);
                    log(context, `Settings updated for ${keyType}`);
                }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED, (err) => {
                    error(context, `Failed to update API key settings: ${err.message}`);
                });
            },
        },
    ]);
}

withScriptLogging(context, () => {
    log(context, 'Module initialized');
    setupApiKeyEvents(context);
});
merchant/api-keys.js
// /static/js/merchant/api-keys.js
import { log, warn } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { createIcon } from '../utils/icons.js';
import { withElement, toggleViewState } from '../utils/dom-manipulation.js';
import { error, success } from '../core/notifications.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { renderMarkdown } from '../core/markdown.js'; // Added import for markdown rendering

const context = 'merchant/api-keys.js';

/**
 * Loads API key settings and renders icons for each setting.
 * @param {string} context - Logging context
 */
export async function loadApiKeys(context) {
    log(context, 'Loading API keys');
    await withErrorHandling(`${context}:loadApiKeys`, async () => {
        await withElement(context, 'api-keys-icons', async (iconsContainer) => {
            const data = await fetchData(context, API_ENDPOINTS.API_KEY, { method: 'GET' });
            log(context, `API response for ${API_ENDPOINTS.API_KEY}: ${JSON.stringify(data)}`);
            if (!data.settings || !Array.isArray(data.settings) || data.settings.length === 0) {
                iconsContainer.innerHTML = '<p>No API keys available.</p>';
                error(context, 'No API keys available');
                return;
            }
            log(context, `Number of settings: ${data.settings.length}`);
            await renderApiKeyIcons(context, data.settings, iconsContainer);
            await renderApiKeyFields(context, data.settings[0]);
            // Removed toggleViewState call here; handled by navigation handler
        });
    });
}

/**
 * Renders icons for each API key setting in the provided container.
 * @param {string} context - Logging context
 * @param {Array} settings - Array of API key settings
 * @param {HTMLElement} container - DOM element to render icons into
 */
async function renderApiKeyIcons(context, settings, container) {
    log(context, 'Rendering API key icons');
    container.innerHTML = '';
    for (const [index, setting] of settings.entries()) {
        const iconClass = setting.icon || 'fas fa-key';
        const icon = await createIcon(context, iconClass, { 'data-key-type': setting.key_type });
        icon.classList.add('affiliate-icon');
        if (index === 0) icon.classList.add('selected');
        Object.assign(icon.style, {
            width: '24px',
            height: '24px',
            display: 'inline-block',
            margin: '5px',
            cursor: 'pointer'
        });
        icon.addEventListener('click', async (event) => {
            event.preventDefault();
            log(context, `Icon clicked for ${setting.key_type}`);
            container.querySelectorAll('.affiliate-icon').forEach(i => i.classList.remove('selected'));
            icon.classList.add('selected');
            await renderApiKeyFields(context, setting);
            document.getElementById('api-keys').style.display = 'block';
        });
        container.appendChild(icon);
    }
}

/**
 * Renders the fields and details for a selected API key setting.
 * @param {string} context - Logging context
 * @param {Object} setting - The API key setting to display
 */
async function renderApiKeyFields(context, setting) {
    log(context, `Rendering fields for API key: ${setting.key_type}`);

    const staticContainer = document.getElementById('api-keys-static-content');
    const formContainer = document.getElementById('api-keys-settings-container');
    const readmeContainer = document.getElementById('api-keys-readme-content');
    const form = document.getElementById('api-keys-form');

    if (!staticContainer || !formContainer || !readmeContainer || !form) {
        warn(context, 'Missing required DOM elements for API keys details');
        error(context, 'Missing required DOM elements for API keys details');
        return;
    }

    staticContainer.innerHTML = '';
    const header = document.createElement('div');
    header.id = 'api-keys-header';
    header.style.display = 'flex';
    header.style.alignItems = 'center';
    header.style.marginBottom = '15px';

    const icon = document.createElement('i');
    icon.className = `selected-affiliate-icon ${setting.icon || 'fas fa-key'}`;
    icon.style.fontSize = '16px';
    icon.style.color = 'currentColor';
    icon.style.marginRight = '10px';
    header.appendChild(icon);

    const title = document.createElement('h3');
    title.className = 'affiliate-comment-heading';
    title.style.display = 'inline-block';
    title.style.verticalAlign = 'middle';
    title.style.margin = '0';
    title.textContent = setting.comment || `${setting.key_type} Settings`;
    header.appendChild(title);

    const linksContainer = document.createElement('div');
    linksContainer.style.marginLeft = 'auto';
    linksContainer.style.display = 'flex';
    linksContainer.style.gap = '10px';

    if (Array.isArray(setting.doc_link) && setting.doc_link.length > 0) {
        setting.doc_link.forEach(doc => {
            const linkElement = document.createElement('a');
            linkElement.className = `affiliate-${doc.title}-link`;
            linkElement.style.color = 'currentColor';
            linkElement.innerHTML = `<i class="fas fa-${doc.title === 'api' ? 'link' : doc.title === 'signup' ? 'user-plus' : 'book'}" style="font-size: 16px;"></i>`;
            linkElement.href = doc.link;
            linkElement.style.display = 'inline-block';
            linkElement.target = '_blank';
            linkElement.title = doc.title.charAt(0).toUpperCase() + doc.title.slice(1);
            linksContainer.appendChild(linkElement);
        });
    }

    header.appendChild(linksContainer);
    staticContainer.appendChild(header);

    const descriptionText = setting._description || setting.description || 'Use this section to manage your API key settings.';
    const description = document.createElement('p');
    description.className = 'affiliate-description';
    description.style.marginBottom = '15px';
    description.textContent = descriptionText;
    staticContainer.appendChild(description);

    const readmeLinkObj = setting.doc_link ? setting.doc_link.find(link => link.title === 'readme') : null;
    if (readmeLinkObj) {
        const mdLinkElement = staticContainer.querySelector('.affiliate-readme-link');
        const keysLinkElement = document.createElement('a');
        keysLinkElement.className = 'affiliate-keys-link';
        keysLinkElement.style.color = 'currentColor';
        keysLinkElement.innerHTML = '<i class="fas fa-key" style="font-size: 16px;"></i>';
        keysLinkElement.style.display = 'none';
        keysLinkElement.title = 'Back to Keys';
        linksContainer.appendChild(keysLinkElement);

        if (mdLinkElement) {
            mdLinkElement.addEventListener('click', async (e) => {
                e.preventDefault();
                try {
                    const markdown = await renderMarkdown(context, readmeLinkObj.link);
                    readmeContainer.innerHTML = markdown;
                    formContainer.style.display = 'none';
                    readmeContainer.style.display = 'block';
                    mdLinkElement.style.display = 'none';
                    keysLinkElement.style.display = 'inline-block';
                    log(context, `Readme loaded for ${setting.key_type}`);
                } catch (err) {
                    error(context, 'Failed to load readme');
                    log(context, `Error loading readme: ${err.message}`);
                }
            });

            keysLinkElement.addEventListener('click', (e) => {
                e.preventDefault();
                formContainer.style.display = 'block';
                readmeContainer.style.display = 'none';
                keysLinkElement.style.display = 'none';
                mdLinkElement.style.display = 'inline-block';
                log(context, `Returned to form view for ${setting.key_type}`);
            });
        }
    }

    const fieldsContainer = form.querySelector('#api-keys-fields');
    if (fieldsContainer) {
        fieldsContainer.innerHTML = '';
        Object.entries(setting.fields || {}).forEach(([name, value]) => {
            const div = document.createElement('div');
            div.style.marginBottom = '10px';
            div.innerHTML = `
                <label for="${name}">${name}:</label>
                <input type="text" id="${name}" name="${name}" value="${value || ''}">
            `;
            fieldsContainer.appendChild(div);
        });
        form.dataset.keyType = setting.key_type;
    }

    formContainer.style.display = 'block';
    readmeContainer.style.display = 'none';

    if (!form._submitListenerAttached) {
        form.addEventListener('submit', async (event) => {
            event.preventDefault();
            const keyType = form.dataset.keyType;
            log(context, `Form submission - keyType: ${keyType}`);
            if (!keyType) {
                warn(context, 'No keyType set for form submission');
                error(context, 'Failed to update settings: No keyType specified');
                return;
            }
            const fields = {};
            Array.from(form.querySelectorAll('input')).forEach(input => {
                fields[input.name] = input.value;
            });
            try {
                await fetchData(context, `${API_ENDPOINTS.API_KEY}/${keyType}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(fields),
                });
                success(context, SUCCESS_MESSAGES.SETTINGS_UPDATED);
                log(context, `Settings updated for ${keyType}`);
            } catch (err) {
                error(context, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
                log(context, `Error updating settings: ${err.message}`);
            }
        });
        form._submitListenerAttached = true;
        log(context, 'Submit event listener attached to form');
    }
}

// Initialize the script with logging (no automatic loadApiKeys call)
withScriptLogging(context, () => {
    log(context, 'Module initialized');
});
merchant/documentation.js
// /static/js/merchant/documentation.js
// Purpose: Handles rendering of documentation content and submenu for the merchant page.

import { log } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { renderMarkdownContent } from '../utils/form-rendering.js';
import { withElement, toggleViewState } from '../utils/dom-manipulation.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { API_ENDPOINTS } from '../config/api-endpoints.js';

/**
 * Renders documentation content and populates the submenu with API key settings.
 * @param {string} context - The context or module name.
 * @param {string} defaultPath - The default markdown file path to render.
 * @param {string} containerId - The ID of the container to render markdown content.
 * @returns {Promise<void>}
 */
export async function renderDocumentation(context, defaultPath, containerId) {
  log(context, `Rendering documentation for path: ${defaultPath}`);
  await withErrorHandling(`${context}:renderDocumentation`, async () => {
    await withElement(context, containerId, async (container) => {
      // Fetch API key settings for submenu
      const settings = await fetchData(context, API_ENDPOINTS.API_KEY);
      const submenu = document.getElementById('documentation-submenu');
      if (submenu && settings) {
        submenu.innerHTML = settings.map(setting => `
          <button class="md-link" data-md-path="${setting.readme_path}">
            ${setting.name}
          </button>
        `).join('');
      } else {
        log(context, 'No submenu or settings found, rendering default content only');
      }

      // Render default markdown content
      await renderMarkdownContent(context, defaultPath, container);

      // Show the documentation section
      toggleViewState(context, { [containerId]: true });
    });
  }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Initializes the documentation module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Documentation instance with public methods.
 */
export function initializeDocumentationModule(registry) {
  const context = 'documentation.js';
  log(context, 'Initializing documentation module for module registry');
  return {
    renderDocumentation: (ctx, ...args) => renderDocumentation(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'documentation.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
merchant/navigation.js
// File path: /static/js/merchant/navigation.js
import { log, error as logError } from '../core/logger.js';
import { defineSectionHandlers } from '../modules/navigation.js';
import { toggleViewState } from '../utils/dom-manipulation.js';
import { loadApiKeys } from './api-keys.js';
import { loadProducts } from './products.js';
import { initializeReferralsPage } from './referrals-page.js';
import { selectPeriod, renderPeriodIcons } from './referrals-ui.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { error as notifyError } from '../core/notifications.js';

const context = 'merchant/navigation.js';

const topLevelSections = ['info', 'my-products', 'api-keys', 'logsIntro'];
const allSections = ['info', 'my-products', 'api-keys', 'logsIntro', 'logs'];

export function defineMerchantSectionHandlers(contextParameter) {
    log(contextParameter, 'Defining section handlers for the merchant interface');

    const specificHandlers = [
        {
            id: 'info',
            handler: async function() {
                log(contextParameter, 'Loading the information section');
                const state = allSections.reduce(function(accumulator, section) {
                    accumulator[section] = section === 'info';
                    return accumulator;
                }, {});
                toggleViewState(contextParameter, state);
            },
        },
        {
            id: 'my-products',
            handler: async function() {
                log(contextParameter, 'Loading the my products section');
                await loadProducts(contextParameter);
                const state = allSections.reduce(function(accumulator, section) {
                    accumulator[section] = section === 'my-products';
                    return accumulator;
                }, {});
                toggleViewState(contextParameter, state);
            },
        },
        {
            id: 'api-keys',
            handler: async function() {
                log(contextParameter, 'Loading the API keys section');
                await loadApiKeys(contextParameter);
                const state = allSections.reduce(function(accumulator, section) {
                    accumulator[section] = section === 'api-keys';
                    return accumulator;
                }, {});
                toggleViewState(contextParameter, state);
            },
        },
        {
            id: 'logsIntro',
            handler: async function(show) {
                log(contextParameter, 'Loading the logs introduction section');
                toggleViewState(contextParameter, { logsIntro: show });
            },
        },
        {
            id: 'logs',
            handler: async function(show, role, type) {
                log(contextParameter, `Loading logs section with type: ${type || 'none'}`);
                if (show) {
                    if (!type || !['click', 'order'].includes(type)) {
                        logError(contextParameter, `Invalid or missing log type: ${type}`);
                        notifyError(contextParameter, 'Please select a log type (Click or Order Events)');
                        toggleViewState(contextParameter, { logs: false, logsIntro: true });
                        return;
                    }

                    const logsSection = document.getElementById('logs');
                    if (!logsSection) {
                        logError(contextParameter, 'Logs section element not found');
                        notifyError(contextParameter, 'Logs section not found');
                        return;
                    }

                    logsSection.dataset.type = type;
                    log(contextParameter, `Set data-type="${type}" on logs section`);

                    toggleViewState(contextParameter, { logs: true, info: false });

                    try {
                        await initializeReferralsPage(type);
                        renderPeriodIcons();
                        log(contextParameter, `Initialized logs UI for type: ${type}`);
                    } catch (err) {
                        logError(contextParameter, `Failed to initialize logs UI: ${err.message}`);
                        notifyError(contextParameter, 'Failed to load logs');
                    }
                } else {
                    toggleViewState(contextParameter, { logs: false });
                }
            },
        },
    ];

    const sectionHandlers = defineSectionHandlers(contextParameter, 'merchant', specificHandlers);
    return sectionHandlers;
}

export function initializeNavigationModule(registry) {
    log(context, 'Initializing the navigation module for the module registry');
    return {
        defineMerchantSectionHandlers: function(contextParameter) {
            return defineMerchantSectionHandlers(contextParameter);
        },
    };
}

withScriptLogging(context, function() {
    log(context, 'Module initialized');
});
merchant/products.js
// /static/js/merchant/products.js
// Purpose: Manages product data fetching and rendering for the merchant page.

import { log } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { renderDataTable } from '../utils/ui-components.js';
import { withElement } from '../utils/dom-manipulation.js';
import { error } from '../core/notifications.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';

const context = 'products.js';

/**
 * Loads and renders product data in a table.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function loadProducts(context) {
    log(context, 'Loading products');
    log(context, 'API_ENDPOINTS.PRODUCTS:', API_ENDPOINTS.PRODUCTS);
    await withErrorHandling(`${context}:loadProducts`, async () => {
        await withElement(context, 'productList', async productList => {
            log(context, 'Accessing productList element');
            const endpoint = typeof API_ENDPOINTS.PRODUCTS === 'string' ? API_ENDPOINTS.PRODUCTS : '/settings/products';
            log(context, 'Using endpoint:', endpoint);
            const data = await fetchData(context, endpoint, { method: 'GET' });
            log(context, 'Fetch response:', data);
            if (!data.products || data.products.length === 0) {
                log(context, 'No products found in response');
                productList.innerHTML = '<p>No products available.</p>';
                error(context, ERROR_MESSAGES.NO_DATA('products'));
                return;
            }

            // Define headers to match merchant.html table structure, including hidden ID column
            const headers = ['ID', 'Category', 'Title', 'URL', 'Price', 'Original', 'Image', 'QTY'];

            const rowMapper = product => {
                log(context, 'Mapping product:', product);
                const imageElement = document.createElement('img');
                imageElement.src = product.image_url || '';
                imageElement.alt = product.title || 'Product Image';
                imageElement.style.width = '50px';
                imageElement.style.height = '50px';
                imageElement.onerror = () => {
                    log(context, `Image failed to load: ${product.image_url}, using fallback`);
                    imageElement.src = 'https://via.placeholder.com/50?text=Image+Not+Found';
                    imageElement.alt = 'Image Not Available';
                };

                return [
                    product.id || 'N/A', // Include ID to match headers
                    product.category || 'N/A',
                    product.title || product.name || 'N/A',
                    product.product_url ? `<a href="${product.product_url}" target="_blank">Link</a>` : 'N/A',
                    product.current_price != null ? product.current_price : 'N/A',
                    product.original_price != null ? product.original_price : 'N/A',
                    imageElement,
                    product.qty != null ? product.qty : 'N/A',
                ];
            };

            log(context, 'Rendering table with products:', data.products);
            const tableContent = await renderDataTable(context, {
                data: data.products,
                headers,
                rowMapper,
                emptyMessage: ERROR_MESSAGES.NO_DATA('products'),
            });
            log(context, 'Rendered table content:', tableContent.outerHTML);
            productList.innerHTML = '';
            while (tableContent.firstChild) {
                productList.appendChild(tableContent.firstChild);
            }
            log(context, 'Table rows appended to productList');
        });
    }, ERROR_MESSAGES.FETCH_FAILED('products'));
}

/**
 * Initializes the products module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Products instance with public methods.
 */
export function initializeProductsModule(registry) {
    log(context, 'Initializing products module for module registry');
    return {
        loadProducts: ctx => loadProducts(ctx),
    };
}

// Initialize module with lifecycle logging
withScriptLogging(context, () => {
    log(context, 'Module initialized');
});
merchant/referrals-data.js
// /static/js/merchant/referrals-data.js
import { log } from '../core/logger.js';
import { authenticatedFetch } from '../core/auth.js';
import { withErrorHandling } from '../utils/error.js';
import { parsePageType, shouldInitializeForPageType } from '../utils/initialization.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';

const context = 'merchant/referrals-data.js';

/**
 * Fetches events for the given event type and period.
 * @param {string} eventType - 'referral' or 'sale'
 * @param {string} period - Temporal filter (e.g., 'today')
 * @returns {Promise<Array>} Array of event objects
 */
export async function fetchEvents(eventType, period) {
    const pageType = parsePageType(context, 'page', 'merchant');
    if (pageType === 'login') {
        log(context, `Skipping ${eventType} events fetch on login page`);
        return [];
    }
    log(context, `Fetching ${eventType} events for period: ${period}`);
    return await withErrorHandling(`${context}:fetchEvents`, async () => {
        const response = await authenticatedFetch(`/events/${eventType}?period=${period}`);
        const data = await response.json();
        if (data.status === 'error') {
            throw new Error(data.message || ERROR_MESSAGES.FETCH_FAILED(`${eventType} events`));
        }
        return data.events || [];
    }, ERROR_MESSAGES.FETCH_FAILED(`${eventType} events`), () => []);
}

if (shouldInitializeForPageType('merchant')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
} else {
    log(context, 'Skipping initialization for non-merchant page');
}
merchant/referrals-page.js
// /static/js/merchant/referrals-page.js
import { log } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { withAuthenticatedUser } from '../core/auth.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { renderPeriodIcons } from './referrals-ui.js';
import { shouldInitializeForPageType } from '../utils/initialization.js';
import { withScriptLogging } from '../utils/logging-utils.js';

const context = 'merchant/referrals-page.js';

/**
 * Initializes the referrals page with the specified log type ('referral' or 'sale').
 * @param {string} logType - The type of logs to display ('referral' or 'sale').
 * @returns {Promise<void>}
 */
export async function initializeReferralsPage(logType) {
    log(context, `Initializing referrals page for log type: ${logType}`);
    await withAuthenticatedUser(context, async () => {
        await withErrorHandling(`${context}:initializeReferralsPage`, async () => {
            const logsSection = document.getElementById('logs');
            if (logsSection) {
                logsSection.dataset.type = logType;
                renderPeriodIcons();
            } else {
                log(context, 'Error: logs section not found.');
            }
        }, ERROR_MESSAGES.FETCH_FAILED('referrals page initialization'));
    }, 'initializeReferralsPage');
}

if (shouldInitializeForPageType('merchant')) {
    withScriptLogging(context, () => {
        log(context, 'Module initialized');
    });
} else {
    log(context, 'Skipping initialization for non-merchant page');
}
merchant/referrals-ui.js
// File path: /static/js/merchant/referrals-ui.js
import { log } from '../core/logger.js';
import { fetchEvents } from './referrals-data.js';

// Define available log periods with their icons and labels
const periods = [
    { name: 'today', icon: 'fa-calendar-day', label: 'Today' },
    { name: 'yesterday', icon: 'fa-calendar-day', label: 'Yesterday' },
    { name: 'this_week', icon: 'fa-calendar-week', label: 'This Week' },
    { name: 'last_week', icon: 'fa-calendar-week', label: 'Last Week' },
    { name: 'this_month', icon: 'fa-calendar', label: 'This Month' },
    { name: 'last_month', icon: 'fa-calendar', label: 'Last Month' }
];

// Define icons for each log type using FontAwesome classes
const logTypeIcons = {
    'click': 'fas fa-mouse-pointer',
    'order': 'fas fa-shopping-cart'
};

/**
 * Formats a timestamp string to UK format (DD/MM/YYYY HH:MM).
 * @param {string} timestamp - The timestamp to format (expected in ISO format).
 * @returns {string} - The formatted timestamp or 'N/A' if invalid.
 */
function formatTimestamp(timestamp) {
    if (!timestamp) return 'N/A';
    const date = new Date(timestamp);
    if (isNaN(date.getTime())) return 'N/A'; // Invalid date
    const options = {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        hour12: false
    };
    return date.toLocaleString('en-GB', options).replace(',', '');
}

/**
 * Renders period icons in the log_period_icon container and sets up click handlers.
 * Initializes with 'today' as the default selected period.
 */
export function renderPeriodIcons() {
    const container = document.getElementById('log_period_icon');
    if (!container) {
        log('merchant/referrals-ui', 'Error: log_period_icon container not found.');
        return;
    }
    container.innerHTML = ''; // Clear existing content
    periods.forEach((period, index) => {
        const icon = document.createElement('i');
        icon.className = `fa-solid ${period.icon} period-icon`;
        icon.dataset.period = period.name;
        if (index === 0) icon.classList.add('selected'); // Default to 'today'
        icon.addEventListener('click', () => selectPeriod(period.name));
        container.appendChild(icon);
    });
    selectPeriod('today'); // Load logs for 'today' initially
}

/**
 * Selects a period, updates the UI, and triggers log loading for that period.
 * Updates the logs-description element with the log type icon and period label.
 * @param {string} periodName - The name of the period to select (e.g., 'today').
 */
export function selectPeriod(periodName) {
    const icons = document.querySelectorAll('.period-icon');
    icons.forEach(icon => icon.classList.remove('selected'));
    const selectedIcon = document.querySelector(`.period-icon[data-period="${periodName}"]`);
    if (selectedIcon) {
        selectedIcon.classList.add('selected');
    }
    const period = periods.find(p => p.name === periodName);
    if (period) {
        const logsSection = document.getElementById('logs');
        const type = logsSection ? logsSection.dataset.type : null;
        updateDescription(type, period.label); // Update description with icon and text
        loadLogs(type, period.name);
    }
}

/**
 * Updates the logs-description element with the log type icon and text.
 * @param {string} type - The log type (e.g., 'click', 'order').
 * @param {string} periodLabel - The label of the selected period (e.g., 'Today').
 */
function updateDescription(type, periodLabel) {
    const descriptionElement = document.getElementById('logs-description');
    if (descriptionElement) {
        const typeLabel = type ? type.charAt(0).toUpperCase() + type.slice(1) : 'Unknown';
        const iconClass = logTypeIcons[type] || 'fa-question'; // Default to question mark if type unknown
        descriptionElement.innerHTML = `<i class="fa-solid ${iconClass}"></i> ${typeLabel} logs for ${periodLabel}`;
    } else {
        log('merchant/referrals-ui', 'Warning: logs-description element not found.');
    }
}

/**
 * Fetches logs for a given type and period, then renders them.
 * @param {string} type - The event type ('click' or 'order').
 * @param {string} period - The period for which to fetch logs (e.g., 'today').
 */
export async function loadLogs(type, period) {
    if (!type) {
        log('merchant/referrals-ui', 'Error: No type set for logs section.');
        return;
    }
    try {
        const events = await fetchEvents(type, period);
        renderEventsTable(events);
    } catch (error) {
        log('merchant/referrals-ui', `Error loading logs: ${error.message}`);
        document.getElementById('logs-table-container').innerHTML = `
            <p>Error: ${error.message}</p>
            <button onclick="loadLogs('${type}', '${period}')">Retry</button>
        `;
    }
}

/**
 * Renders the events data into a table within the logs-table-container.
 * @param {Array} events - Array of event objects to display.
 */
export function renderEventsTable(events) {
    const container = document.getElementById('logs-table-container');
    if (!container) {
        log('merchant/referrals-ui', 'Error: logs-table-container not found.');
        return;
    }
    container.innerHTML = ''; // Clear existing content
    const table = document.createElement('table');
    table.innerHTML = `
        <thead>
            <tr>
                <th>Timestamp</th>
                <th>Details</th>
            </tr>
        </thead>
        <tbody>
            ${events.map(event => `
                <tr>
                    <td>${formatTimestamp(event.timestamp)}</td>
                    <td>${event.details || 'N/A'}</td>
                </tr>
            `).join('')}
        </tbody>
    `;
    container.appendChild(table);
}
merchant/setup.js
// /static/js/merchant/setup.js
// Purpose: Handles additional initialization tasks for the merchant page.

import { log } from '../core/logger.js';
import { hasAdminPermission } from '../config/menus.js';
import { toggleViewState } from '../utils/dom-manipulation.js';
import { initializeSiteRequest } from '../modules/site-request.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Initializes merchant-specific modules and performs additional setup tasks.
 * @param {string} context - The context or module name.
 * @param {string} pageType - The type of page to initialize (e.g., 'info', 'store-request').
 * @returns {Promise<void>}
 */
export async function initializeMerchantModules(context, pageType) {
  log(context, `Initializing merchant modules for pageType: ${pageType}`);
  await withErrorHandling(`${context}:initializeMerchantModules`, async () => {
    // Check admin permission and toggle back button visibility
    if (hasAdminPermission(context)) {
      log(context, 'Admin permission detected, showing back button');
      toggleViewState(context, { 'button[data-role="admin"]': true });
    } else {
      toggleViewState(context, { 'button[data-role="admin"]': false });
    }

    // Initialize site request if pageType is store-request
    if (pageType === 'store-request') {
      log(context, 'Initializing site request module');
      await initializeSiteRequest(context, 'store-request');
    }

    // Additional setup (e.g., collapsible sections, other modules)
    if (typeof window.setupCollapsibleSections === 'function') {
      window.setupCollapsibleSections();
    }
  }, ERROR_MESSAGES.MODULE_INIT_FAILED);
}

/**
 * Initializes the setup module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Setup instance with public methods.
 */
export function initializeSetupModule(registry) {
  const context = 'setup.js';
  log(context, 'Initializing setup module for module registry');
  return {
    initializeMerchantModules: (ctx, ...args) => initializeMerchantModules(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'setup.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
merchant/user-settings.js
// /static/js/merchant/user-settings.js
// Purpose: Manages user settings for the merchant page, including rendering, form submission, and validation.

import { log } from '../core/logger.js';
import { renderSettingsForm } from '../utils/settings-renderer.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { setupEventListeners } from '../utils/event-listeners.js';
import { withErrorHandling } from '../utils/error.js';
import { SETTINGS } from '../config/settings.js';
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Loads and renders user settings.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function loadUserSettings(context) {
  log(context, 'Loading user settings');
  const settingsConfig = SETTINGS.userSettings || {
    containerId: 'user-settings-icons',
    formId: 'settingsForm',
    fieldsId: 'user-settings-fields',
    endpoint: '/settings/user',
    type: 'user-settings',
    iconClass: 'fas fa-user',
  };
  await withErrorHandling(`${context}:loadUserSettings`, async () => {
    await renderSettingsForm(context, settingsConfig);
    setupUserSettingsEvents(context);
  }, ERROR_MESSAGES.RENDER_FAILED('user settings'));
}

/**
 * Sets up event listeners for user settings form submission.
 * @param {string} context - The context or module name.
 */
function setupUserSettingsEvents(context) {
  log(context, 'Setting up user settings event listeners');
  setupEventListeners(context, [
    {
      eventType: 'submit',
      selector: '#settingsForm',
      handler: async event => {
        event.preventDefault();
        await withErrorHandling(`${context}:submitUserSettings`, async () => {
          await submitConfiguredForm(context, 'settingsForm', '/settings/user', 'userSettings');
        }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
      },
    },
  ]);
}

/**
 * Transforms user settings form data for submission.
 * @param {FormData} formData - The form data.
 * @returns {Object} Transformed data for API submission.
 */
export function transformUserSettings(formData) {
  log('user-settings.js', 'Transforming user settings form data');
  return {
    contactName: formData.get('contactName')?.trim(),
    emailAddress: formData.get('emailAddress')?.trim(),
    websiteUrl: formData.get('websiteUrl')?.trim() || null,
    phoneNumber: formData.get('phoneNumber')?.trim() || null,
  };
}

/**
 * Validates user settings form data.
 * @param {FormData} formData - The form data.
 * @returns {boolean} True if valid, false otherwise.
 */
export function validateUserSettings(formData) {
  log('user-settings.js', 'Validating user settings form data');
  return formData.get('contactName')?.trim() && formData.get('emailAddress')?.trim();
}

/**
 * Initializes the user settings module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} User settings instance with public methods.
 */
export function initializeUserSettingsModule(registry) {
  return createModuleInitializer('user-settings.js', {
    loadUserSettings,
    transformUserSettings,
    validateUserSettings,
  });
}

// Initialize module with lifecycle logging
const context = 'user-settings.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
merchant-page.js
// /static/js/merchant-page.js
import { log } from './core/logger.js';
import { parsePageType, initializeRolePage, hideOverlay, getDefaultSectionFromQuery, shouldInitializeForPageType } from './utils/initialization.js';
import { toggleViewState } from './utils/dom-manipulation.js';
import { withScriptLogging } from './utils/logging-utils.js';
import { defineMerchantSectionHandlers } from './merchant/navigation.js';
import { initializeMerchantModules } from './merchant/setup.js';
import { getMenu } from './config/menus.js';
import { initializeRoleNavigation } from './modules/navigation.js';

const context = 'merchant-page.js';

/**
 * Initializes the merchant page with navigation and default section visibility.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializeMerchantPage(context) {
  log(context, 'Initializing merchant page');
  const pageType = parsePageType(context, 'page', 'products');
  if (pageType === 'login') {
    log(context, 'Skipping merchant page initialization for login page');
    return;
  }
  const role = 'merchant';
  const fallbackSection = 'info';
  const defaultSection = getDefaultSectionFromQuery(context, role, fallbackSection);

  await initializeRolePage(context, role, pageType, async () => {
    const sectionHandlers = defineMerchantSectionHandlers(context);
    
    const menuElement = document.getElementById('menu');
    if (menuElement) {
      const menu = getMenu(role);
      await initializeRoleNavigation(menuElement, menu, { sectionHandlers, defaultSection });
      log(context, 'Navigation initialized with default section:', defaultSection);
    } else {
      log(context, 'Menu element not found, skipping navigation setup');
    }

    // Initialize additional merchant modules, avoiding #siteRequestForm handlers
    const form = document.querySelector('#siteRequestForm');
    if (form && form.dataset.siteRequestHandled) {
      log(context, 'Skipping form handler setup for #siteRequestForm, handled by site-request.js');
    }
    await initializeMerchantModules(context, pageType);

    toggleViewState(context, { [defaultSection]: true });
    log(context, `Default section '${defaultSection}' set to visible`);
  });
}

export function initializeMerchantPageModule(registry) {
  log(context, 'Initializing merchant-page module for module registry');
  return {
    initializeMerchantPage: ctx => initializeMerchantPage(ctx),
  };
}

if (shouldInitializeForPageType('merchant')) {
  withScriptLogging(context, async () => {
    log(context, 'Module initialized');
    await initializeMerchantPage(context);
    hideOverlay();
  });
} else {
  log(context, 'Skipping initialization for non-merchant page');
}
modules/dataLoader.js
// /static/js/modules/dataLoader.js
// Purpose: Provides a centralized data loading utility for fetching data from API endpoints.

import { log } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Loads data from the specified endpoint, retained for compatibility with existing modules.
 * @param {string} context - The context or module name.
 * @param {string} endpoint - The API endpoint to fetch data from.
 * @returns {Promise<Object>} The fetched data.
 */
export async function load(context, endpoint) {
  log(context, `Loading data from endpoint: ${endpoint}`);
  return await withErrorHandling(`${context}:load`, async () => {
    const data = await fetchData(endpoint, { method: 'GET' });
    if (data.status === 'error') {
      throw new Error(ERROR_MESSAGES.FETCH_FAILED(endpoint));
    }
    return data;
  }, ERROR_MESSAGES.FETCH_FAILED(endpoint));
}

/**
 * Initializes the dataLoader module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} DataLoader instance with public methods.
 */
export function initializeDataLoaderModule(registry) {
  const context = 'dataLoader.js';
  log(context, 'Initializing dataLoader module for module registry');
  return {
    load: (ctx, ...args) => load(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'dataLoader.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
modules/navigation.js
// File path: /static/js/modules/navigation.js
import { log, error as logError } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { toggleViewState } from '../utils/dom-manipulation.js';
import { getMenu } from '../config/menus.js';
import { withScriptLogging } from '../utils/logging-utils.js';

const context = 'navigation.js';

// Tracks the currently open menu tree
let activeMenuTree = [];

// **Overlay Functions**
/**
 * Shows the loading overlay by removing the 'hidden' class from the element with id 'loadingOverlay'.
 */
function showLoadingOverlay() {
    const overlay = document.getElementById('loadingOverlay');
    if (overlay) {
        overlay.classList.remove('hidden');
    }
}

/**
 * Hides the loading overlay by adding the 'hidden' class to the element with id 'loadingOverlay'.
 */
function hideLoadingOverlay() {
    const overlay = document.getElementById('loadingOverlay');
    if (overlay) {
        overlay.classList.add('hidden');
    }
}

/**
 * Normalizes a type value by converting it to lowercase and trimming spaces.
 * @param {string|null} type - The type value to normalize.
 * @returns {string|null} The normalized type value, or null if the input is null.
 */
function normalizeType(type) {
    return type ? type.toLowerCase().trim() : null;
}

/**
 * Recursively collects all section IDs from the menu configuration.
 * @param {Array} menu - The menu configuration.
 * @returns {Array} An array of all section IDs.
 */
function getAllSections(menu) {
    let sections = [];
    menu.forEach(item => {
        if (item.section) sections.push(item.section);
        if (item.submenu) {
            sections = sections.concat(getAllSections(item.submenu));
        }
    });
    return sections;
}

/**
 * Synchronizes the active state of menu buttons with the currently visible section.
 * @param {HTMLElement} menuElement - The menu element containing the buttons.
 */
function syncActiveState(menuElement) {
    log(context, 'START: Syncing active state with visible section');
    
    const allSections = document.querySelectorAll('.section');
    let activeSection = null;
    let activeType = null;

    let visibleCount = 0;
    allSections.forEach(section => {
        // Check if section is defined and has a style property
        if (section && section.style && section.style.display === 'block') {
            visibleCount++;
            if (!activeSection && section.id) { // Ensure section.id exists
                activeSection = section.id;
                activeType = section.dataset && section.dataset.type ? normalizeType(section.dataset.type) : null;
                log(context, `Detected active section: ${activeSection}${activeType ? `, type: ${activeType}` : ''}`);
            } else {
                section.style.display = 'none';
                log(context, `Hid extra visible section: ${section.id || 'unknown'}`);
            }
        }
    });

    if (visibleCount > 1) {
        log(context, `Multiple sections were visible; corrected to show only: ${activeSection || 'none'}`);
    }

    if (menuElement) {
        log(context, 'Before clearing active state, buttons with active class:', 
            Array.from(menuElement.querySelectorAll('.menu-button.active'))
                .map(btn => `${btn.textContent.trim()} (section: ${btn.dataset.section}${btn.dataset.type ? `, type: ${btn.dataset.type}` : ''})`)
        );

        menuElement.querySelectorAll('.menu-button').forEach(btn => {
            btn.classList.remove('active');
        });
        log(context, 'Cleared active class from all menu buttons');

        if (activeSection && activeSection !== 'info') {
            let selector = `.menu-button[data-section="${activeSection}"]`;
            if (activeType) {
                selector += `[data-type="${activeType}"]`;
            }
            log(context, `Looking for button with selector: ${selector}`);

            let activeButton = menuElement.querySelector(selector);
            if (!activeButton && activeType) {
                selector = `.menu-button[data-section="${activeSection}"]`;
                activeButton = menuElement.querySelector(selector);
                log(context, `No button matched with type; fell back to section-only selector: ${selector}`);
            }

            if (activeButton) {
                activeButton.classList.add('active');
                log(context, `Set active class on button: ${activeButton.textContent.trim()} (section: ${activeSection}${activeType ? `, type: ${activeType}` : ''})`);

                let parentButton = activeButton;
                while (parentButton && parentButton.dataset && parentButton.dataset.level !== '0') {
                    parentButton = parentButton.parentElement && parentButton.parentElement.previousElementSibling;
                    if (parentButton && parentButton.classList && parentButton.classList.contains('menu-button')) {
                        parentButton.classList.add('submenu-open');
                        const caret = parentButton.querySelector('.menu-submenu-caret');
                        if (caret) {
                            caret.classList.replace('fa-caret-right', 'fa-caret-down');
                        }
                        const submenu = parentButton.nextElementSibling;
                        if (submenu && submenu.classList && submenu.classList.contains('menu-submenu')) {
                            submenu.style.display = 'block';
                        }
                        log(context, `Highlighted parent button: ${parentButton.textContent.trim()} (section: ${parentButton.dataset.section})`);
                    }
                }
            } else {
                logError(context, `No menu button found for active section: ${activeSection}${activeType ? `, type: ${activeType}` : ''}, even after fallback`);
            }
        } else if (activeSection === 'info') {
            log(context, 'Info section is active; no menu button will be marked as active');
        }

        log(context, 'After sync, buttons with active class:', 
            Array.from(menuElement.querySelectorAll('.menu-button.active'))
                .map(btn => `${btn.textContent.trim()} (section: ${btn.dataset.section}${btn.dataset.type ? `, type: ${btn.dataset.type}` : ''})`)
        );
    }
    log(context, 'END: Syncing active state with visible section');
}

/**
 * Retries setting the data-type attribute on a section element until the element is found.
 * @param {string} sectionId - The ID of the section element.
 * @param {string|null} type - The type to set (or null to remove).
 * @param {number} maxAttempts - Maximum number of retry attempts.
 * @param {number} delayMs - Delay between attempts in milliseconds.
 * @returns {Promise<void>}
 */
async function setSectionDataType(sectionId, type, maxAttempts = 10, delayMs = 100) {
    let attempts = 0;
    const normalizedType = normalizeType(type);
    while (attempts < maxAttempts) {
        const sectionElement = document.getElementById(sectionId);
        if (sectionElement) {
            if (normalizedType) {
                sectionElement.dataset.type = normalizedType;
                log(context, `Set data-type="${normalizedType}" on section element: ${sectionId}`);
            } else {
                delete sectionElement.dataset.type;
                log(context, `Removed data-type from section element: ${sectionId}`);
            }
            return;
        }
        log(context, `Section element ${sectionId} not found; retrying (${attempts + 1}/${maxAttempts})`);
        await new Promise(resolve => setTimeout(resolve, delayMs));
        attempts++;
    }
    logError(context, `Failed to set data-type on section element ${sectionId} after ${maxAttempts} attempts`);
}

/**
 * Resets the navigation state by hiding all sections, clearing active menu states, and re-rendering the menu.
 * @param {string} context - The context or module name for logging.
 * @returns {Promise<void>}
 */
export async function resetNavigation(context) {
    log(context, 'Resetting navigation state');
    await withErrorHandling(`${context}:resetNavigation`, async () => {
        const allSections = document.querySelectorAll('.section');
        allSections.forEach(section => {
            if (section && section.style) {
                section.style.display = 'none';
                log(context, `Hid section: ${section.id || 'unknown'}`);
            }
        });

        const menuElement = document.getElementById('menu');
        if (menuElement) {
            menuElement.querySelectorAll('button').forEach(button => {
                button.classList.remove('active');
                log(context, `Cleared active state for button: ${button.dataset.section || 'unknown'}`);
            });
        } else {
            logError(context, 'Menu element not found during reset');
        }

        if (menuElement) {
            const role = document.body.dataset && document.body.dataset.pageType || 'default';
            const defaultSection = 'info';
            const menu = getMenu(role);
            const sectionHandlers = defineSectionHandlers(context, role);
            menuElement.innerHTML = '';
            await initializeRoleNavigation(menuElement, menu, { sectionHandlers, defaultSection });
            log(context, 'Re-rendered menu to reset event listeners');
        }

        const layoutWrapper = document.querySelector('.layout-wrapper');
        if (layoutWrapper) {
            layoutWrapper.style.display = 'block';
            log(context, 'Ensured layout wrapper is visible');
        } else {
            logError(context, 'Layout wrapper not found during reset');
        }

        const infoElement = document.getElementById('info');
        if (infoElement) {
            allSections.forEach(section => {
                if (section && section.id !== 'info' && section.style) {
                    section.style.display = 'none';
                }
            });
            infoElement.style.display = 'block';
            toggleViewState(context, { info: true });
            log(context, 'Fallback: Ensured info section is visible after reset');
            if (menuElement) {
                menuElement.querySelectorAll('.menu-button').forEach(btn => btn.classList.remove('active'));
                log(context, 'Cleared active state from all menu buttons as Info section is shown');
            }
        } else {
            logError(context, 'Fallback failed: Info section not found during reset');
        }
    }, 'Failed to reset navigation state');
}

/**
 * Defines section handlers for a given role, ensuring all sections including common ones and DOM sections have handlers.
 * @param {string} context - The context or module name for logging.
 * @param {string} role - The role for which to define section handlers.
 * @param {Array} handlers - Optional array of custom handler configurations with id and handler properties.
 * @returns {Object} An object mapping section IDs to handler functions.
 */
export function defineSectionHandlers(context, role, handlers = []) {
    log(context, `Defining section handlers for role: ${role}`);
    const menu = getMenu(role);
    const allSections = getAllSections(menu);
    const commonSections = ['my-account', 'contact-details', 'change-password', 'settings'];
    const sectionHandlers = {};

    commonSections.forEach(section => {
        sectionHandlers[section] = async (show = true) => {
            log(context, `Navigating to common section ${section}, show: ${show}`);
            const allDomSections = document.querySelectorAll('.section');
            allDomSections.forEach(sec => {
                if (sec && sec.style) sec.style.display = 'none';
            });
            const state = {
                [section]: show,
                info: section === 'info' ? show : false,
            };
            toggleViewState(context, state);
            const menuElement = document.getElementById('menu');
            if (menuElement) {
                menuElement.querySelectorAll('.menu-button').forEach(btn => btn.classList.remove('active'));
                if (show) {
                    const button = menuElement.querySelector(`.menu-button[data-section="${section}"]`);
                    if (button) {
                        button.classList.add('active');
                        log(context, `Set active class on button for section: ${section}`);
                    } else {
                        logError(context, `No menu button found for section: ${section}`);
                    }
                }
                syncActiveState(menuElement);
            }
        };
    });

    allSections.forEach(section => {
        if (!commonSections.includes(section)) {
            const handlerConfig = handlers.find(h => h && h.id === section);
            if (handlerConfig && handlerConfig.handler) {
                sectionHandlers[section] = async (show = true, roleOverride, type) => {
                    log(context, `Navigating to section ${section}, show: ${show}, role: ${roleOverride || role}${type ? `, type: ${type}` : ''}`);
                    const allDomSections = document.querySelectorAll('.section');
                    allDomSections.forEach(sec => {
                        if (sec && sec.style) sec.style.display = 'none';
                    });
                    const state = {
                        [section]: show,
                        info: section === 'info' ? show : false,
                    };
                    const normalizedType = normalizeType(type);
                    await setSectionDataType(section, normalizedType);
                    toggleViewState(context, state);
                    await handlerConfig.handler(show, roleOverride || role, normalizedType);
                    const menuElement = document.getElementById('menu');
                    if (menuElement) {
                        syncActiveState(menuElement);
                    }
                };
            } else {
                sectionHandlers[section] = async (show = true, roleOverride, type) => {
                    log(context, `Navigating to section ${section} with generic handler, show: ${show}${type ? `, type: ${type}` : ''}`);
                    const allDomSections = document.querySelectorAll('.section');
                    allDomSections.forEach(sec => {
                        if (sec && sec.style) sec.style.display = 'none';
                    });
                    const state = {
                        [section]: show,
                        info: section === 'info' ? show : false,
                    };
                    const normalizedType = normalizeType(type);
                    await setSectionDataType(section, normalizedType);
                    toggleViewState(context, state);
                    const menuElement = document.getElementById('menu');
                    if (menuElement) {
                        syncActiveState(menuElement);
                    }
                };
            }
        }
    });

    const allDomSections = Array.from(document.querySelectorAll('.section'))
        .filter(el => el && el.id)
        .map(el => el.id);
    allDomSections.forEach(section => {
        if (!sectionHandlers[section]) {
            sectionHandlers[section] = async (show = true, roleOverride, type) => {
                log(context, `Navigating to section ${section} with default handler, show: ${show}${type ? `, type: ${type}` : ''}`);
                const allDomSections = document.querySelectorAll('.section');
                allDomSections.forEach(sec => {
                    if (sec && sec.style) sec.style.display = 'none';
                });
                const state = {
                    [section]: show,
                    info: section === 'info' ? show : false,
                };
                const normalizedType = normalizeType(type);
                await setSectionDataType(section, normalizedType);
                toggleViewState(context, state);
                const menuElement = document.getElementById('menu');
                if (menuElement) {
                    syncActiveState(menuElement);
                }
            };
        }
    });

    if (!sectionHandlers['info']) {
        sectionHandlers['info'] = async (show = true) => {
            log(context, 'Default info section handler triggered');
            const allDomSections = document.querySelectorAll('.section');
            allDomSections.forEach(sec => {
                if (sec && sec.id !== 'info' && sec.style) {
                    sec.style.display = 'none';
                }
            });
            toggleViewState(context, { info: show });
            const menuElement = document.getElementById('menu');
            if (menuElement && show) {
                menuElement.querySelectorAll('.menu-button').forEach(btn => btn.classList.remove('active'));
                log(context, 'Cleared active state from all menu buttons as Info section is shown');
                syncActiveState(menuElement);
            }
        };
    }

    log(context, `Section handlers defined for role ${role}:`, Object.keys(sectionHandlers));
    return sectionHandlers;
}

/**
 * Closes all submenus not in the active menu tree.
 * @param {Array} activeTree - The current active menu tree path.
 */
function closeIrrelevantSubmenus(activeTree) {
    document.querySelectorAll('.menu-submenu').forEach(submenu => {
        const menuSection = submenu.previousElementSibling && submenu.previousElementSibling.dataset && submenu.previousElementSibling.dataset.section;
        if (!activeTree.includes(menuSection)) {
            submenu.style.display = 'none';
        }
    });
    document.querySelectorAll('#menu button').forEach(btn => {
        const btnSection = btn.dataset && btn.dataset.section;
        if (!activeTree.includes(btnSection)) {
            btn.classList.remove('submenu-open');
            const caret = btn.querySelector('.menu-submenu-caret');
            if (caret) {
                caret.classList.replace('fa-caret-down', 'fa-caret-right');
            }
        }
    });
}

/**
 * Renders a menu item and its submenus recursively as buttons with carets.
 * @param {Object} item - The menu item configuration with section, label, icons, action, type, and optional submenu.
 * @param {number} level - The nesting level (0 for top-level items).
 * @param {Object} sectionHandlers - Section handler functions.
 * @param {Array} buttons - Array to collect button elements.
 * @param {Array} parentTree - The parent menu tree path.
 */
function renderMenuItem(item, level, sectionHandlers, buttons, parentTree = []) {
    log(context, `Rendering menu item: ${item.label}, level: ${level}, section: ${item.section || 'none'}${item.type ? `, type: ${item.type}` : ''}`);
    const button = document.createElement('button');
    button.className = 'menu-button';
    button.dataset.section = item.section || 'action';
    button.dataset.level = level.toString();
    if (item.role) button.dataset.role = item.role;
    if (item.action) button.dataset.action = 'true';
    if (item.type) {
        button.dataset.type = normalizeType(item.type);
        log(context, `Set button data-type="${button.dataset.type}" for item: ${item.label}`);
    }

    const iconsHTML = Array.isArray(item.icons)
        ? item.icons.map(icon => `<i class="${icon} menu-icon"></i>`).join('')
        : '';

    const caretHTML = Array.isArray(item.submenu) && item.submenu.length > 0
        ? `<i class="fas fa-caret-right menu-submenu-caret"></i>`
        : '';

    button.innerHTML = `${iconsHTML}${item.label}${caretHTML}`;

    button.addEventListener('click', async () => {
        showLoadingOverlay();
        try {
            log(context, `START: Button clicked: ${item.label}, section: ${item.section || 'none'}${item.role ? `, role: ${item.role}` : ''}${item.type ? `, type: ${item.type}` : ''}`);

            if (item.action) {
                log(context, `Executing action for ${item.label}`);
                item.action();
                return;
            }

            const currentTree = [...parentTree, item.section];
            if (level === 0) {
                closeIrrelevantSubmenus(currentTree);
                log(context, `Level 0: Closed irrelevant submenus; active tree: ${currentTree.join(' -> ')}`);
            }

            const handler = sectionHandlers[item.section];
            if (handler) {
                const typeToPass = item.type ? normalizeType(item.type) : null;
                log(context, `Calling handler for section: ${item.section}${typeToPass ? ` with type: ${typeToPass}` : ''}`);

                if (typeToPass) {
                    log(context, `Ensuring data-type="${typeToPass}" is set on section: ${item.section}`);
                    await setSectionDataType(item.section, typeToPass);
                }

                const event = new CustomEvent('sectionChange', {
                    detail: { section: item.section, role: item.role || null, type: typeToPass }
                });
                document.dispatchEvent(event);
                log(context, `Dispatched sectionChange event for section: ${item.section}${typeToPass ? `, type: ${typeToPass}` : ''}`);

                await handler(true, item.role || null, typeToPass);

                const menuElement = document.getElementById('menu');
                if (menuElement) {
                    log(context, 'Before clearing active state, buttons with active class:', 
                        Array.from(menuElement.querySelectorAll('.menu-button.active'))
                            .map(btn => `${btn.textContent.trim()} (section: ${btn.dataset.section}${btn.dataset.type ? `, type: ${btn.dataset.type}` : ''})`)
                    );

                    menuElement.querySelectorAll('.menu-button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    log(context, 'Cleared active class from all menu buttons');

                    button.classList.add('active');
                    log(context, `Set active class on ${item.label}${item.type ? ` with data-type="${typeToPass}"` : ''}`);

                    log(context, 'After setting active class, buttons with active class:', 
                        Array.from(menuElement.querySelectorAll('.menu-button.active'))
                            .map(btn => `${btn.textContent.trim()} (section: ${btn.dataset.section}${btn.dataset.type ? `, type: ${btn.dataset.type}` : ''})`)
                    );

                    log(context, 'Calling syncActiveState to ensure consistency');
                    syncActiveState(menuElement);

                    let parentButton = button;
                    while (parentButton && parentButton.dataset && parentButton.dataset.level !== '0') {
                        parentButton = parentButton.parentElement && parentButton.parentElement.previousElementSibling;
                        if (parentButton && parentButton.classList && parentButton.classList.contains('menu-button')) {
                            parentButton.classList.add('submenu-open');
                            const caret = parentButton.querySelector('.menu-submenu-caret');
                            if (caret) {
                                caret.classList.replace('fa-caret-right', 'fa-caret-down');
                            }
                            const submenu = parentButton.nextElementSibling;
                            if (submenu && submenu.classList && submenu.classList.contains('menu-submenu')) {
                                submenu.style.display = 'block';
                            }
                            log(context, `Highlighted parent button: ${parentButton.textContent.trim()} (section: ${parentButton.dataset.section})`);
                        }
                    }
                } else {
                    logError(context, 'Menu element not found when handling click');
                }
            } else {
                logError(context, `No handler found for section: ${item.section}`);
            }

            if (Array.isArray(item.submenu) && item.submenu.length > 0) {
                const submenuContainer = button.nextElementSibling;
                const isOpen = submenuContainer && submenuContainer.style && submenuContainer.style.display === 'block';
                if (isOpen) {
                    submenuContainer.style.display = 'none';
                    button.classList.remove('submenu-open');
                    const caret = button.querySelector('.menu-submenu-caret');
                    if (caret) {
                        caret.classList.replace('fa-caret-down', 'fa-caret-right');
                    }
                    activeMenuTree = activeMenuTree.filter(section => section !== item.section);
                    log(context, `Closed submenu for ${item.label}; updated activeMenuTree: ${activeMenuTree.join(' -> ')}`);
                } else if (submenuContainer) {
                    submenuContainer.style.display = 'block';
                    button.classList.add('submenu-open');
                    const caret = button.querySelector('.menu-submenu-caret');
                    if (caret) {
                        caret.classList.replace('fa-caret-right', 'fa-caret-down');
                    }
                    activeMenuTree = currentTree;
                    log(context, `Opened submenu for ${item.label}; updated activeMenuTree: ${activeMenuTree.join(' -> ')}`);
                }
            }

            log(context, `END: Button click handler for ${item.label}`);
        } catch (err) {
            logError(context, `Error during navigation: ${err.message}`);
        } finally {
            hideLoadingOverlay();
        }
    });

    buttons.push(button);

    if (Array.isArray(item.submenu) && item.submenu.length > 0) {
        const submenuContainer = document.createElement('div');
        submenuContainer.className = 'menu-submenu';
        submenuContainer.style.display = 'none';
        const submenuButtons = [];
        item.submenu.forEach(subItem => {
            renderMenuItem(subItem, level + 1, sectionHandlers, submenuButtons, [...parentTree, item.section]);
        });
        submenuButtons.forEach(btn => submenuContainer.appendChild(btn));
        buttons.push(submenuContainer);
    }
}

/**
 * Initializes navigation for a role by rendering the menu and setting up section handlers.
 * @param {HTMLElement} element - The DOM element to render the menu into.
 * @param {Array} menu - The menu configuration for the role.
 * @param {Object} options - Options for navigation setup.
 * @param {Object} options.sectionHandlers - Section handler functions.
 * @param {string} options.defaultSection - The default section to display.
 */
export async function initializeRoleNavigation(element, menu, { sectionHandlers, defaultSection }) {
    log(context, 'Initializing role navigation with menu:', menu.map(item => item.label));
    log(context, 'Received section handlers:', Object.keys(sectionHandlers));

    await withErrorHandling(`${context}:initializeRoleNavigation`, async () => {
        if (!element) {
            logError(context, 'Navigation element not provided');
            toggleViewState(context, { info: true });
            const infoElement = document.getElementById('info');
            if (infoElement) {
                infoElement.style.display = 'block';
                infoElement.classList.add('active');
                log(context, 'Fallback: Info section set to visible due to missing navigation element');
            }
            return;
        }

        if (!Array.isArray(menu)) {
            logError(context, 'Invalid menu configuration; expected an array');
            toggleViewState(context, { info: true });
            const infoElement = document.getElementById('info');
            if (infoElement) {
                infoElement.style.display = 'block';
                infoElement.classList.add('active');
                log(context, 'Fallback: Info section set to visible due to invalid menu');
            }
            return;
        }

        element.innerHTML = '';
        log(context, 'Cleared existing menu content');

        const buttons = [];
        menu.forEach(item => renderMenuItem(item, 0, sectionHandlers, buttons));
        buttons.forEach(button => element.appendChild(button));
        log(context, `Appended ${buttons.length} buttons to menu element`);

        syncActiveState(element);

        const allSections = document.querySelectorAll('.section');
        let activeSection = null;
        allSections.forEach(section => {
            if (section && section.style && section.style.display === 'block' && section.id) {
                activeSection = section.id;
            }
        });

        if (!activeSection && defaultSection && sectionHandlers[defaultSection]) {
            log(context, `Activating default section: ${defaultSection}`);
            await sectionHandlers[defaultSection](true);
            toggleViewState(context, { [defaultSection]: true, info: defaultSection === 'info' });
            if (defaultSection !== 'info') {
                const defaultButton = element.querySelector(`.menu-button[data-section="${defaultSection}"]`);
                if (defaultButton) {
                    element.querySelectorAll('.menu-button').forEach(btn => btn.classList.remove('active'));
                    defaultButton.classList.add('active');
                    log(context, `Set active class on default button: ${defaultSection}`);
                } else {
                    logError(context, `Default button for section ${defaultSection} not found in DOM`);
                }
            } else {
                log(context, 'Skipping menu button activation for info section');
                element.querySelectorAll('.menu-button').forEach(btn => btn.classList.remove('active'));
            }
        } else if (!activeSection) {
            logError(context, `No handler found for default section: ${defaultSection}`);
            if (sectionHandlers['info']) {
                await sectionHandlers['info'](true);
                toggleViewState(context, { info: true });
                log(context, 'Info section activated via fallback');
                element.querySelectorAll('.menu-button').forEach(btn => btn.classList.remove('active'));
            } else {
                const infoElement = document.getElementById('info');
                if (infoElement) {
                    const allDomSections = document.querySelectorAll('.section');
                    allDomSections.forEach(sec => {
                        if (sec && sec.id !== 'info' && sec.style) {
                            sec.style.display = 'none';
                        }
                    });
                    toggleViewState(context, { info: true });
                    infoElement.style.display = 'block';
                    infoElement.classList.add('active');
                    log(context, 'Ultimate fallback: Info section set to visible via direct DOM manipulation');
                    element.querySelectorAll('.menu-button').forEach(btn => btn.classList.remove('active'));
                } else {
                    logError(context, 'Ultimate fallback failed: Info section not found');
                }
            }
        }

        const observer = new MutationObserver(() => {
            syncActiveState(element);
        });
        document.querySelectorAll('.section').forEach(section => {
            if (section) {
                observer.observe(section, { attributes: true, attributeFilter: ['style', 'data-type'] });
            }
        });
        log(context, 'Added MutationObserver to re-sync active state on section visibility changes');
    }, 'Failed to initialize navigation');
}

/**
 * Initializes the navigation module for use with the module registry.
 * @param {Map} registry - The module registry instance.
 * @returns {Object} Module instance with public methods.
 */
export function initializeNavigationModule(registry) {
    log(context, 'Initializing navigation module for module registry');
    return {
        defineSectionHandlers: (ctx, role, handlers) => defineSectionHandlers(ctx, role, handlers),
        initializeRoleNavigation: (element, menu, options) => initializeRoleNavigation(element, menu, options),
        resetNavigation: ctx => resetNavigation(ctx),
    };
}

// Initialize the module with lifecycle logging
withScriptLogging(context, () => {
    log(context, 'Module initialized');
});
modules/pageSetup.js
// /static/js/modules/pageSetup.js
// Purpose: Provides utilities for setting up page-specific configurations and navigation.

import { log } from '../core/logger.js';
import { parsePageType } from '../utils/initialization.js';
import { withAuthenticatedUser } from '../core/auth.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Sets up a page with role-based navigation and user authentication.
 * @param {string} context - The context or module name.
 * @param {string} role - The role associated with the page (e.g., 'admin', 'merchant').
 * @param {string} defaultSection - The default section to show.
 * @param {Function} setupCallback - Callback to execute after setup.
 * @returns {Promise<void>}
 */
export async function setupPage(context, role, defaultSection, setupCallback) {
  log(context, `Setting up page for role: ${role}, default section: ${defaultSection}`);
  await withAuthenticatedUser(async userId => {
    await withErrorHandling(`${context}:setupPage`, async () => {
      const userIdInput = document.getElementById('userId');
      if (userIdInput) userIdInput.value = userId;
      await setupCallback();
      window.setupCollapsibleSections?.();
    }, ERROR_MESSAGES.MODULE_INIT_FAILED);
  });
}

/**
 * Initializes the pageSetup module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} PageSetup instance with public methods.
 */
export function initializePageSetupModule(registry) {
  const context = 'pageSetup.js';
  log(context, 'Initializing pageSetup module for module registry');
  return {
    setupPage: (ctx, ...args) => setupPage(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'pageSetup.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
modules/site-request.js
// /static/js/modules/site-request.js
import { log, error as logError } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { withAuthenticatedUser } from '../core/auth.js';
import { withElement, toggleViewState } from '../utils/dom-manipulation.js';
import { initializeTinyMCE } from '../core/mce.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';

const context = 'site-request.js';

/**
 * Initializes the site request form for a given section.
 * @param {string} context - The context or module name.
 * @param {string} sectionId - The ID of the section (e.g., 'create-store', 'no_website').
 */
export async function initializeSiteRequest(context, sectionId) {
    log(context, `Initializing site request for section: ${sectionId}`);
    await withAuthenticatedUser(context, async (userId) => {
        await withErrorHandling(`${context}:initializeSiteRequest`, async () => {
            log(context, `Starting initialization with userId: ${userId}`);
            await loadSiteRequest(context, sectionId, userId);
            setupSiteRequestEvents(context, sectionId, userId);
            log(context, 'Initialization completed successfully');
        }, ERROR_MESSAGES.MODULE_INIT_FAILED);
    }, 'initializeSiteRequest');
}

/**
 * Loads existing site request data into the form.
 * @param {string} context - The context or module name.
 * @param {string} sectionId - The section ID.
 * @param {string} userId - The authenticated user ID.
 */
async function loadSiteRequest(context, sectionId, userId) {
    log(context, `Loading site request data for section: ${sectionId}, userId: ${userId}`);
    await withErrorHandling(`${context}:loadSiteRequest`, async () => {
        await withElement(context, sectionId, async (section) => {
            const form = section.querySelector('#siteRequestForm');
            if (!form) {
                logError(context, `Form #siteRequestForm not found in section: ${sectionId}`);
                return;
            }
            log(context, 'Form #siteRequestForm found');
            form.dataset.siteRequestHandled = 'true'; // Mark as handled to avoid conflicts

            const data = await fetchData(context, API_ENDPOINTS.SITE_REQUEST);
            log(context, 'Fetched site request data:', data);
            const siteRequest = data?.siterequest || {};

            if (Object.keys(siteRequest).length > 0) {
                form.dataset.siteRequestId = 'exists';
                log(context, 'Set dataset.siteRequestId to "exists"');
            }

            // Populate static fields
            const fields = {
                name: siteRequest.communityName || '',
                about: siteRequest.aboutCommunity || '',
                colorPrefs: siteRequest.colorPrefs || '',
                stylingDetails: siteRequest.stylingDetails || '',
                preferredDomain: siteRequest.preferredDomain || '',
            };
            Object.entries(fields).forEach(([id, value]) => {
                const input = form.querySelector(`#${id}`);
                if (input) {
                    input.value = value;
                    log(context, `Populated ${id} with: ${value}`);
                }
            });

            // Populate emails
            const emailsContainer = form.querySelector('#emailsContainer');
            if (emailsContainer) {
                const emails = siteRequest.emails || [''];
                emailsContainer.innerHTML = emails.map((email, index) => `
                    <div class="email-entry">
                        <input type="email" name="email_${index}" value="${email}">
                        ${emails.length > 1 ? '<button type="button" class="remove-email">Remove</button>' : ''}
                    </div>
                `).join('');
                log(context, 'Populated emails:', emails);
            }

            // Populate pages
            const pagesContainer = form.querySelector('#pagesContainer');
            if (pagesContainer) {
                const pages = siteRequest.pages || [];
                pagesContainer.innerHTML = pages.length > 0 ? pages.map((page, index) => {
                    const isMandatory = page.mandatory || false;
                    return `
                        <div class="page-entry" data-mandatory="${isMandatory}">
                            <input type="text" name="page_${index}_title" value="${page.title || ''}" ${isMandatory ? 'readonly' : ''}>
                            <textarea name="page_${index}_content" id="page_${index}_content" class="mce-editor">${page.content || ''}</textarea>
                            <input type="file" name="page_${index}_images" multiple>
                            <input type="hidden" name="page_${index}_mandatory" value="${isMandatory}">
                            ${isMandatory ? '' : '<button type="button" class="remove-page">Remove</button>'}
                        </div>
                    `;
                }).join('') : `
                    <div class="page-entry" data-mandatory="false">
                        <input type="text" name="page_0_title" placeholder="Page Title">
                        <textarea name="page_0_content" id="page_0_content" class="mce-editor" placeholder="Page Content"></textarea>
                        <input type="file" name="page_0_images" multiple>
                        <input type="hidden" name="page_0_mandatory" value="false">
                        <button type="button" class="remove-page">Remove</button>
                    </div>
                `;
                log(context, 'Populated pages:', pages);

                // Initialize TinyMCE for pages' textareas
                const textareas = pagesContainer.querySelectorAll('.mce-editor');
                for (let i = 0; i < textareas.length; i++) {
                    const textarea = textareas[i];
                    if (!textarea.id) textarea.id = `page_${i}_content`; // Ensure unique ID
                    await initializeTinyMCE(context, `#${textarea.id}`);
                }
                log(context, `Initialized TinyMCE for ${textareas.length} textareas`);
            }

            // Initialize TinyMCE for static .mce-editor textareas (e.g., about, stylingDetails)
            const staticMceTextareas = form.querySelectorAll('.mce-editor:not(#pagesContainer .mce-editor)');
            for (let i = 0; i < staticMceTextareas.length; i++) {
                const textarea = staticMceTextareas[i];
                if (!textarea.id) {
                    textarea.id = `static_mce_${i}`; // Assign a unique ID if not present
                }
                await initializeTinyMCE(context, `#${textarea.id}`);
            }
            log(context, `Initialized TinyMCE for ${staticMceTextareas.length} static textareas`);

            toggleViewState(context, { [sectionId]: true });
        });
    }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Sets up event listeners for form interactions and submission.
 * @param {string} context - The context or module name.
 * @param {string} sectionId - The section ID.
 * @param {string} userId - The user ID.
 */
function setupSiteRequestEvents(context, sectionId, userId) {
    log(context, `Setting up events for section: ${sectionId}`);
    const form = document.getElementById('siteRequestForm');
    if (!form) {
        logError(context, 'Form #siteRequestForm not found for event setup');
        return;
    }

    // Event delegation for dynamic elements
    form.addEventListener('click', async event => {
        const target = event.target;
        if (target.classList.contains('remove-email')) {
            const emailEntry = target.closest('.email-entry');
            const emailsContainer = form.querySelector('#emailsContainer');
            if (emailsContainer.querySelectorAll('.email-entry').length > 1) {
                emailEntry.remove();
                log(context, 'Removed an email entry');
            }
        } else if (target.classList.contains('remove-page')) {
            const pageEntry = target.closest('.page-entry');
            const isMandatory = pageEntry.dataset.mandatory === 'true';
            if (!isMandatory) {
                pageEntry.remove();
                log(context, 'Removed a page entry');
            } else {
                log(context, 'Cannot remove mandatory page');
                // Optionally, alert the user: alert('Mandatory pages cannot be removed.');
            }
        } else if (target.dataset.action === 'addEmail') {
            const emailsContainer = form.querySelector('#emailsContainer');
            const index = emailsContainer.querySelectorAll('.email-entry').length;
            emailsContainer.insertAdjacentHTML('beforeend', `
                <div class="email-entry">
                    <input type="email" name="email_${index}" placeholder="Enter email">
                    <button type="button" class="remove-email">Remove</button>
                </div>
            `);
            log(context, `Added email entry ${index}`);
        } else if (target.dataset.action === 'addPage') {
            const pagesContainer = form.querySelector('#pagesContainer');
            const index = pagesContainer.querySelectorAll('.page-entry').length;
            const pageHtml = `
                <div class="page-entry" data-mandatory="false">
                    <input type="text" name="page_${index}_title" placeholder="Page Title">
                    <textarea name="page_${index}_content" id="page_${index}_content" class="mce-editor" placeholder="Page Content"></textarea>
                    <input type="file" name="page_${index}_images" multiple>
                    <input type="hidden" name="page_${index}_mandatory" value="false">
                    <button type="button" class="remove-page">Remove</button>
                </div>
            `;
            pagesContainer.insertAdjacentHTML('beforeend', pageHtml);
            await initializeTinyMCE(context, `#page_${index}_content`);
            log(context, `Added page entry ${index} with TinyMCE`);
        }
    });

    // Configure form submission with TinyMCE save
    submitConfiguredForm(context, 'siteRequestForm', API_ENDPOINTS.SITE_REQUEST, 'siteRequest', {
        method: form => form.dataset.siteRequestId === 'exists' ? 'PATCH' : 'POST',
        onSuccess: (response) => {
            log(context, 'Form submission successful:', response);
            form.dataset.siteRequestId = 'exists';
        },
        onError: (err) => {
            logError(context, 'Form submission failed:', err.message);
        },
        data: () => {
            if (window.tinymce) {
                window.tinymce.triggerSave();
                log(context, 'Triggered TinyMCE save before form data collection');
            }
            const formData = new FormData(form);
            log(context, 'Collected form data:', Array.from(formData.entries()));
            return formData;
        },
    });
    log(context, 'Form submission handler configured');
}

export function initializeSiteRequestModule(registry) {
    log(context, 'Initializing site-request module');
    return {
        initializeSiteRequest,
        loadSiteRequest,
    };
}

withScriptLogging(context, () => {
    log(context, 'Module initialized');
});
modules/userSettings.js
// /static/js/modules/userSettings.js
// Purpose: Manages user settings form submission and UI rendering.

import { log } from '../core/logger.js';
import { renderSettings } from '../utils/settings-renderer.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { setupEventListeners } from '../utils/event-listeners.js';
import { SETTINGS } from '../config/settings.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Loads and renders user settings.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function loadUserSettings(context) {
  log(context, 'Loading user settings');
  const settingsConfig = SETTINGS.userSettings || {
    containerId: 'userSettingsIcons',
    formId: 'userSettingsForm',
    fieldsId: 'userSettingsFields',
    endpoint: '/settings/user',
    type: 'user-settings',
    iconClass: 'fas fa-user',
  };
  await renderSettings(context, settingsConfig);
  setupUserSettingsEvents(context);
}

/**
 * Sets up event listeners for user settings form submission.
 * @param {string} context - The context or module name.
 */
function setupUserSettingsEvents(context) {
  log(context, 'Setting up user settings event listeners');
  setupEventListeners(context, [
    {
      eventType: 'submit',
      selector: '#userSettingsForm',
      handler: async event => {
        event.preventDefault();
        await submitConfiguredForm(context, 'userSettingsForm', '/settings/user', 'userSettings');
      },
    },
  ]);
}

/**
 * Initializes the userSettings module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} UserSettings instance with public methods.
 */
export function initializeUserSettingsModule(registry) {
  const context = 'userSettings.js';
  log(context, 'Initializing userSettings module for module registry');
  return {
    loadUserSettings: ctx => loadUserSettings(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'userSettings.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
partner/initializer.js
// /static/js/partner/initializer.js
import { log } from '../core/logger.js';
import { withAuthenticatedUser } from '../core/auth.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';

const context = 'initializer.js';

/**
 * Initializes partner modules and sets up additional page elements.
 * @param {string} context - The context or module name.
 * @param {string} pageType - The type of page to initialize (e.g., 'integrations').
 * @returns {Promise<void>}
 */
export async function initializePartnerModules(context, pageType) {
    log(context, `Initializing partner modules for page type: ${pageType}`);
    await withAuthenticatedUser(context, async (userId) => {
        await withErrorHandling(`${context}:initializePartnerModules`, async () => {
            const userIdInput = document.getElementById('userId');
            if (userIdInput) {
                userIdInput.value = userId;
                log(context, `Set userId input to: ${userId}`);
            } else {
                log(context, 'userId input not found');
            }
            // Additional initialization can be added here if needed
            window.setupCollapsibleSections?.();
            log(context, 'Collapsible sections setup completed');
        }, ERROR_MESSAGES.MODULE_INIT_FAILED);
    }, 'initializePartnerModules');
}

/**
 * Initializes the initializer module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Initializer module instance.
 */
export function initializeInitializerModule(registry) {
    log(context, 'Initializing initializer module for module registry');
    return {
        initializePartnerModules: (ctx, pageType) => initializePartnerModules(ctx, pageType),
    };
}

withScriptLogging(context, () => {
    log(context, 'Module initialized');
});
partner/integrations-data.js
// /static/js/partner/integrations-data.js
// Purpose: Manages data fetching for integration settings on the partner page.

import { log } from '../core/logger.js';
import { fetchData } from '../utils/data-fetch.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Loads integration settings from the server.
 * @param {string} context - The context or module name.
 * @returns {Promise<Array>} The fetched integration settings.
 */
export async function loadIntegrations(context) {
  log(context, 'Loading integration settings');
  return await withErrorHandling(`${context}:loadIntegrations`, async () => {
    const data = await fetchData(context, API_ENDPOINTS.CLIENT_API);
    return data.settings || [];
  }, ERROR_MESSAGES.FETCH_FAILED('integrations'), () => []);
}

/**
 * Initializes the integrations-data module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} IntegrationsData instance with public methods.
 */
export function initializeIntegrationsDataModule(registry) {
  const context = 'integrations-data.js';
  log(context, 'Initializing integrations-data module for module registry');
  return {
    loadIntegrations: ctx => loadIntegrations(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'integrations-data.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
partner/integrations-ui.js
// /static/js/partner/integrations-ui.js
// Purpose: Manages UI rendering for integration settings on the partner page.

import { log } from '../core/logger.js';
import { renderSettingsForm } from '../utils/settings-renderer.js';
import { toggleViewState } from '../utils/dom-manipulation.js';
import { renderMarkdownContent } from '../utils/form-rendering.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Renders integration settings based on the provided data and container.
 * @param {string} context - The context or module name.
 * @param {Array} settings - The integration settings data.
 * @param {string} containerId - The ID of the container to render into.
 * @returns {Promise<void>}
 */
export async function renderIntegrations(context, settings, containerId) {
  log(context, `Rendering integration settings in container: ${containerId}`);
  await withErrorHandling(`${context}:renderIntegrations`, async () => {
    await renderSettingsForm(context, {
      containerId,
      formId: 'integrationsForm',
      fieldsId: 'integrationsFields',
      settings,
      type: 'integrations',
      endpoint: '/client-api',
      iconClass: 'fas fa-plug',
      onIconClick: (setting, fieldsContainer, form) => {
        toggleViewState(context, { integrationsFields: true });
        Array.from(document.getElementById(containerId).children).forEach(child => {
          child.style.color = child.dataset.keyType === setting.keyType ? '#007bff' : '#C0C0C0';
        });
      },
      onReadmeClick: async setting => {
        const readmeLink = setting.docLink?.find(link => link.title === 'readme')?.link;
        if (readmeLink) {
          await renderMarkdownContent(context, readmeLink, `mdContent-${setting.keyType}`);
          toggleViewState(context, { [`mdContent-${setting.keyType}`]: true });
        }
      },
    });
  }, ERROR_MESSAGES.RENDER_FAILED('integrations'));
}

/**
 * Initializes the integrations-ui module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} IntegrationsUi instance with public methods.
 */
export function initializeIntegrationsUiModule(registry) {
  return createModuleInitializer('integrations-ui.js', {
    renderIntegrations,
  });
}

// Initialize module with lifecycle logging
const context = 'integrations-ui.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
partner/integrations.js
// /static/js/partner/integrations.js
// Purpose: Orchestrates the integrations settings page, coordinating data fetching, UI rendering, and event setup.

import { log } from '../core/logger.js';
import { withErrorHandling } from '../utils/error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { loadIntegrations } from './integrations-data.js';
import { renderIntegrations } from './integrations-ui.js';
import { setupPartnerEvents } from './partner-events.js';
import { withScriptLogging } from '../utils/logging-utils.js';

/**
 * Loads and renders integration settings.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function loadIntegrationsSettings(context) {
  log(context, 'Loading integration settings');
  await withErrorHandling(`${context}:loadIntegrationsSettings`, async () => {
    const settings = await loadIntegrations(context);
    await renderIntegrations(context, settings, 'integrationsIconsBar');
    setupPartnerEvents(context);
  }, ERROR_MESSAGES.FETCH_FAILED('integrations'));
}

/**
 * Initializes the integrations module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Integrations instance with public methods.
 */
export function initializeIntegrationsModule(registry) {
  const context = 'integrations.js';
  log(context, 'Initializing integrations module for module registry');
  return {
    loadIntegrationsSettings: ctx => loadIntegrationsSettings(ctx),
  };
}

// Initialize module with lifecycle logging
const context = 'integrations.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
partner/navigation.js
// /static/js/partner/navigation.js
import { log } from '../core/logger.js';
import { defineSectionHandlers } from '../modules/navigation.js';
import { toggleViewState } from '../utils/dom-manipulation.js';
import { withScriptLogging } from '../utils/logging-utils.js';

const context = 'partner/navigation.js';

/**
 * Defines section handlers for the partner page.
 * @param {string} context - The context or module name.
 * @returns {Object} Section handlers object.
 */
export function definePartnerSectionHandlers(context) {
    log(context, 'Defining partner section handlers');

    const specificHandlers = [
        {
            id: 'info',
            handler: async () => {
                log(context, 'Loading info section');
                toggleViewState(context, { info: true });
            },
        },
        {
            id: 'integrations',
            handler: async () => {
                log(context, 'Loading integrations section');
                await import('./integrations.js').then(m => m.loadIntegrationsSettings(context));
                toggleViewState(context, { integrations: true });
            },
        },
        {
            id: 'settings',
            handler: async () => {
                log(context, 'Loading settings section');
                toggleViewState(context, { settings: true });
            },
        },
        {
            id: 'referrals',
            handler: async () => {
                log(context, 'Loading referrals section');
                toggleViewState(context, { referrals: true });
            },
        },
    ];

    // Use defineSectionHandlers to include generic handlers for all menu sections
    const sectionHandlers = defineSectionHandlers(context, 'partner', specificHandlers);
    log(context, `Section handlers defined: ${Object.keys(sectionHandlers).join(', ')}`);
    return sectionHandlers;
}

/**
 * Initializes the navigation module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Navigation module instance.
 */
export function initializeNavigationModule(registry) {
    log(context, 'Initializing navigation module for module registry');
    return {
        definePartnerSectionHandlers: ctx => definePartnerSectionHandlers(ctx),
    };
}

withScriptLogging(context, () => {
    log(context, 'Module initialized');
});
partner/partner-events.js
// /static/js/partner/partner-events.js
import { log } from '../core/logger.js';
import { setupEventListeners } from '../utils/event-listeners.js';
import { submitConfiguredForm } from '../utils/form-submission.js';
import { toggleViewState } from '../utils/dom-manipulation.js';
import { withErrorHandling } from '../utils/error.js';
import { API_ENDPOINTS, ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { createModuleInitializer } from '../utils/initialization.js';

const context = 'partner-events.js';

/**
 * Sets up event listeners for partner page interactions.
 * @param {string} context - The context or module name.
 * @returns {void}
 */
export function setupPartnerEvents(context) {
    log(context, 'Setting up partner event listeners');
    withErrorHandling(`${context}:setupPartnerEvents`, () => {
        setupEventListeners(context, [
            {
                eventType: 'submit',
                selector: '#integrationsForm',
                handler: async event => {
                    event.preventDefault();
                    await withErrorHandling(`${context}:submitIntegrationsForm`, async () => {
                        await submitConfiguredForm(context, 'integrationsForm', API_ENDPOINTS.CLIENT_API, 'integrations', {
                            successMessage: SUCCESS_MESSAGES.SETTINGS_UPDATED,
                            onSuccess: () => {
                                log(context, 'Integration settings updated successfully');
                                toggleViewState(context, { integrationsFields: true });
                            },
                        });
                    }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
                },
            },
            {
                eventType: 'click',
                selector: '#partnerNavToggle',
                handler: async () => {
                    await withErrorHandling(`${context}:toggleNavigation`, async () => {
                        log(context, 'Toggling partner navigation');
                        toggleViewState(context, { partnerNav: true });
                    }, ERROR_MESSAGES.SECTION_TOGGLE_FAILED);
                },
            },
        ]);
    }, ERROR_MESSAGES.EVENT_HANDLER_FAILED);
}

/**
 * Initializes the partner events module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Partner events module instance.
 */
export function initializePartnerEventsModule(registry) {
    return createModuleInitializer('partner-events.js', {
        setupPartnerEvents,
    });
}

withScriptLogging(context, () => {
    log(context, 'Module initialized');
});
partner-page.js
// /static/js/partner-page.js
import { log } from './core/logger.js';
import { parsePageType, initializeRolePage, hideOverlay, getDefaultSectionFromQuery, shouldInitializeForPageType } from './utils/initialization.js';
import { toggleViewState } from './utils/dom-manipulation.js';
import { withScriptLogging } from './utils/logging-utils.js';
import { definePartnerSectionHandlers } from './partner/navigation.js';
import { initializePartnerModules } from './partner/initializer.js';
import { getMenu } from './config/menus.js';
import { initializeRoleNavigation } from './modules/navigation.js';

const context = 'partner-page.js';

/**
 * Initializes the partner page with navigation and default section visibility.
 * @param {string} context - The context or module name.
 * @returns {Promise<void>}
 */
export async function initializePartnerPage(context) {
    log(context, 'Initializing partner page');
    const pageType = parsePageType(context, 'page', 'integrations');
    if (pageType === 'login') {
        log(context, 'Skipping partner page initialization for login page');
        return;
    }
    const role = 'partner';
    const fallbackSection = 'info';
    const defaultSection = getDefaultSectionFromQuery(context, role, fallbackSection);

    await initializeRolePage(context, role, pageType, async () => {
        // Define section handlers
        const sectionHandlers = definePartnerSectionHandlers(context);
        
        // Set up navigation
        const menuElement = document.getElementById('menu');
        if (menuElement) {
            const menu = getMenu(role);
            log(context, `Menu items for ${role}: ${menu.map(item => item.section).join(', ')}`);
            await initializeRoleNavigation(menuElement, menu, { sectionHandlers, defaultSection });
            log(context, 'Navigation initialized with default section:', defaultSection);
        } else {
            log(context, 'Menu element not found, skipping navigation setup');
        }

        // Initialize additional partner modules
        await initializePartnerModules(context, pageType);

        // Ensure the default section is visible
        toggleViewState(context, { [defaultSection]: true });
        log(context, `Default section '${defaultSection}' set to visible`);
    });
}

/**
 * Initializes the partner page module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Partner page module instance.
 */
export function initializePartnerPageModule(registry) {
    log(context, 'Initializing partner-page module for module registry');
    return {
        initializePartnerPage: ctx => initializePartnerPage(ctx),
    };
}

if (shouldInitializeForPageType('partner')) {
    withScriptLogging(context, async () => {
        log(context, 'Module initialized');
        await initializePartnerPage(context);
        hideOverlay();
    });
} else {
    log(context, 'Skipping initialization for non-partner page');
}
utils/data-fetch.js
// /static/js/utils/data-fetch.js
// Purpose: Provides a centralized utility for fetching data from API endpoints.

import { log } from '../core/logger.js';
import { authenticatedFetch } from '../core/auth.js'; // Updated import to core/auth.js
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/messages.js'; // Updated import to messages.js
import { withScriptLogging } from './logging-utils.js';

const context = 'data-fetch.js';

/**
 * Fetches data from the specified endpoint with optional fetch options.
 * @param {string} context - The context or module name.
 * @param {string} endpoint - The API endpoint URL.
 * @param {Object} [options={}] - Fetch options (e.g., method, headers, body).
 * @param {boolean} [useAuth=true] - Whether to use authenticated fetch (default: true).
 * @returns {Promise<Object>} The fetched data.
 */
export async function fetchData(context, endpoint, options = {}, useAuth = true) {
  log(context, `Fetching data from endpoint: ${endpoint}, useAuth: ${useAuth}`);
  
  // Ensure endpoint is correctly formatted (relative path)
  if (!endpoint.startsWith('/')) {
    endpoint = `/${endpoint}`;
  }
  
  const fetchFunction = useAuth ? authenticatedFetch : fetch; // Use authenticatedFetch or regular fetch
  const response = await fetchFunction(endpoint, options);
  const data = await response.json();
  if (data.status === 'error') {
    throw new Error(data.message || ERROR_MESSAGES.FETCH_FAILED(endpoint));
  }
  return data;
}

/**
 * Initializes the data-fetch module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} DataFetch instance with public methods.
 */
export function initializeDataFetchModule(registry) {
  log(context, 'Initializing data-fetch module for module registry');
  return {
    fetchData: (ctx, ...args) => fetchData(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/dom-events.js
// /static/js/utils/dom-events.js
// Purpose: Provides utilities for managing DOM events.

import { log } from '../core/logger.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from './logging-utils.js';

/**
 * Registers a single DOM event listener with error handling.
 * @param {string} context - The context or module name.
 * @param {string} eventType - The event type (e.g., 'click', 'submit').
 * @param {string} selector - The CSS selector for the target element.
 * @param {Function} handler - The event handler function.
 * @returns {void}
 */
export function registerEventListener(context, eventType, selector, handler) {
  log(context, `Registering ${eventType} event listener for selector: ${selector}`);
  withErrorHandling(`${context}:registerEventListener`, () => {
    const elements = document.querySelectorAll(selector);
    if (elements.length === 0) {
      log(context, `No elements found for selector: ${selector}`);
      return;
    }
    elements.forEach(element => {
      element.addEventListener(eventType, async event => {
        await withErrorHandling(`${context}:eventHandler`, () => handler(event), ERROR_MESSAGES.EVENT_HANDLER_FAILED);
      });
    });
  }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Initializes the dom-events module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} DomEvents instance with public methods.
 */
export function initializeDomEventsModule(registry) {
  const context = 'dom-events.js';
  log(context, 'Initializing dom-events module for module registry');
  return {
    registerEventListener: (ctx, ...args) => registerEventListener(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'dom-events.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/dom-manipulation.js
// /static/js/utils/dom-manipulation.js
// Purpose: Provides utilities for DOM manipulation with retry logic and visibility toggling.

import { log, warn } from '../core/logger.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from './logging-utils.js';

// Cache for DOM elements to reduce repeated queries
export const elementCache = new Map(); // Export elementCache

/**
 * Executes a callback with a DOM element, retrying if the element is not found.
 * @param {string} context - The context or module name.
 * @param {string} elementId - The ID of the DOM element.
 * @param {Function} callback - The callback to execute with the element.
 * @param {number} [maxAttempts=3] - Maximum retry attempts.
 * @param {number} [retryDelay=50] - Delay between retries in milliseconds.
 * @param {boolean} [checkVisibility=false] - Whether to check element visibility.
 * @returns {Promise<any>} The result of the callback or null if the element is not found.
 */
export async function withElement(context, elementId, callback, maxAttempts = 3, retryDelay = 50, checkVisibility = false) {
    log(context, `Accessing element: ${elementId}`);
    if (elementCache.has(elementId)) {
        log(context, `Using cached element: ${elementId}`);
        return await callback(elementCache.get(elementId));
    }
    return await withErrorHandling(`${context}:withElement`, async () => {
        const element = await waitForElement(context, elementId, maxAttempts, retryDelay);
        if (checkVisibility && element.offsetParent === null) {
            throw new Error(`Element ${elementId} is not visible`);
        }
        elementCache.set(elementId, element);
        log(context, `Element ${elementId} cached and callback executing`);
        return await callback(element);
    }, ERROR_MESSAGES.ELEMENT_NOT_FOUND, () => {
        warn(context, `Failed to find element ${elementId} after ${maxAttempts} attempts, returning null`);
        return null;
    });
}

/**
 * Fetches multiple DOM elements and returns them as an object.
 * @param {string} context - The context or module name.
 * @param {string[]} elementIds - Array of DOM element IDs to fetch.
 * @param {number} [maxAttempts=3] - Maximum retry attempts.
 * @param {number} [retryDelay=50] - Delay between retries in milliseconds.
 * @returns {Promise<Object>} Object mapping element IDs to DOM elements or null for unfound elements.
 */
export async function getElements(context, elementIds, maxAttempts = 3, retryDelay = 50) {
    log(context, `Fetching elements: ${elementIds.join(', ')}`);
    return await withErrorHandling(`${context}:getElements`, async () => {
        const elements = {};
        for (const id of elementIds) {
            if (elementCache.has(id)) {
                elements[id] = elementCache.get(id);
                log(context, `Using cached element: ${id}`);
                continue;
            }
            try {
                const element = await waitForElement(context, id, maxAttempts, retryDelay);
                elementCache.set(id, element);
                elements[id] = element;
            } catch (err) {
                warn(context, `Failed to find element ${id}: ${err.message}`);
                elements[id] = null;
            }
        }
        return elements;
    }, ERROR_MESSAGES.ELEMENT_NOT_FOUND, () => {
        warn(context, 'Failed to fetch elements, returning partial results');
        return elementIds.reduce((acc, id) => ({ ...acc, [id]: null }), {});
    });
}

/**
 * Waits for a DOM element to be available, retrying if not found.
 * @param {string} context - The context or module name.
 * @param {string} elementId - The ID of the DOM element.
 * @param {number} maxAttempts - Maximum retry attempts.
 * @param {number} retryDelay - Delay between retries in milliseconds.
 * @returns {Promise<HTMLElement>} The found element.
 * @throws {Error} If the element is not found after maxAttempts.
 */
async function waitForElement(context, elementId, maxAttempts, retryDelay) {
    log(context, `Waiting for element: ${elementId} with ${maxAttempts} attempts, ${retryDelay}ms delay`);
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        const element = document.getElementById(elementId);
        if (element) {
            log(context, `Element ${elementId} found on attempt ${attempt}`);
            return element;
        }
        warn(context, `Element ${elementId} not found, attempt ${attempt}/${maxAttempts}`);
        await new Promise(resolve => setTimeout(resolve, retryDelay));
    }
    throw new Error(`Element ${elementId} not found after ${maxAttempts} attempts`);
}

/**
 * Toggles the visibility of elements based on a state object, preserving info section visibility unless explicitly hidden.
 * @param {string} context - The context or module name.
 * @param {Object.<string, boolean>} state - Object mapping element IDs to visibility states.
 * @returns {void}
 */
export function toggleViewState(context, state) {
    log(context, 'Toggling view state:', state);
    try {
        const allSections = document.querySelectorAll('.section');
        log(context, 'Found sections:', Array.from(allSections).map(s => s.id || 'no-id')); // Debug log
        if (allSections.length === 0) {
            log(context, 'No sections found with class "section"');
            return;
        }
        allSections.forEach(section => {
            const id = section.id;
            if (!id) {
                log(context, 'Section found without ID, outerHTML:', section.outerHTML); // Debug log
                return;
            }
            if (id === 'info') {
                if (state.hasOwnProperty('info')) {
                    const shouldShow = state['info'];
                    section.style.display = shouldShow ? 'block' : 'none';
                    if (shouldShow) {
                        section.classList.add('active');
                    } else {
                        section.classList.remove('active');
                    }
                    log(context, `Set info display to ${shouldShow ? 'block' : 'none'}, active: ${shouldShow}`);
                } else {
                    const isOtherSectionShown = Object.values(state).some(val => val === true);
                    if (!isOtherSectionShown) {
                        section.style.display = 'block';
                        section.classList.add('active');
                        log(context, `Preserved info display as block, active: true (no other section shown)`);
                    } else {
                        section.style.display = 'none';
                        section.classList.remove('active');
                        log(context, `Hid info section as another section is being shown`);
                    }
                }
            } else if (state.hasOwnProperty(id)) {
                const shouldShow = state[id];
                section.style.display = shouldShow ? 'block' : 'none';
                if (shouldShow) {
                    section.classList.add('active');
                } else {
                    section.classList.remove('active');
                }
                log(context, `Set ${id} display to ${shouldShow ? 'block' : 'none'}, active: ${shouldShow}`);
            } else {
                section.style.display = 'none';
                section.classList.remove('active');
                log(context, `Hid section ${id} as it's not in the state object`);
            }
        });
        // Check if state keys exist in DOM
        Object.keys(state).forEach(key => {
            if (!document.getElementById(key) && key !== 'info') {
                log(context, `Warning: State key ${key} does not match any section ID`);
            }
        });
    } catch (err) {
        log(context, `Error in toggleViewState: ${err.message}`);
        throw new Error(ERROR_MESSAGES.ELEMENT_NOT_FOUND);
    }
}

/**
 * Sets up event listeners for collapsible sections.
 * @param {string} context - The context or module name.
 * @returns {void}
 */
export function setupCollapsibleSections(context) {
    log(context, 'Setting up collapsible sections');
    withErrorHandling(`${context}:setupCollapsibleSections`, () => {
        const toggleSections = document.querySelectorAll('.toggle-section');
        toggleSections.forEach(section => {
            section.addEventListener('click', () => {
                const targetId = section.getAttribute('data-toggle');
                const targetContent = document.getElementById(targetId);
                if (targetContent) {
                    const isOpen = targetContent.classList.contains('open');
                    const parentSection = section.closest('.section');
                    if (parentSection) {
                        parentSection.querySelectorAll('.toggle-content.open').forEach(content => {
                            content.classList.remove('open');
                            content.style.display = 'none';
                        });
                    }
                    if (!isOpen) {
                        targetContent.classList.add('open');
                        targetContent.style.display = 'block';
                    }
                } else {
                    log(context, `Target content not found for ID: ${targetId}`);
                }
            });
        });
    }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Initializes the dom-manipulation module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} DomManipulation instance with public methods.
 */
export function initializeDomManipulationModule(registry) {
    const context = 'dom-manipulation.js';
    log(context, 'Initializing dom-manipulation module for module registry');
    return {
        withElement: (ctx, ...args) => withElement(ctx, ...args),
        getElements: (ctx, ...args) => getElements(ctx, ...args),
        toggleViewState: (ctx, ...args) => toggleViewState(ctx, ...args),
        setupCollapsibleSections: (ctx) => setupCollapsibleSections(ctx),
    };
}

// Initialize module with lifecycle logging
const context = 'dom-manipulation.js';
withScriptLogging(context, () => {
    log(context, 'Module initialized');
});
utils/error.js
// /static/js/utils/error.js
// Purpose: Provides error handling utilities.

import { log } from '../core/logger.js';
import { ERROR_MESSAGES } from '../config/messages.js';

const context = 'error.js';

/**
 * Wraps a function with error handling, logging errors and throwing a default message if needed.
 * @param {string} context - The context or module name.
 * @param {Function} fn - The function to execute.
 * @param {string} operation - The operation name for logging.
 * @returns {Promise<*>} The result of the function execution.
 * @throws {Error} If the function fails and no default message is provided.
 */
export async function withErrorHandling(context, fn, operation) {
    log(context, `Executing ${operation || 'operation'} with error handling`);
    try {
        return await fn();
    } catch (error) {
        log(context, `Error during ${operation || 'operation'}: ${error.message}`);
        throw new Error(error.message || ERROR_MESSAGES.DEFAULT);
    }
}

// Note: Lifecycle logging was removed to avoid circular dependencies.
// Original commented code:
// withScriptLogging(context, () => {
//     log(context, 'Module initialized');
// });
utils/event-listeners.js
// /static/js/utils/event-listeners.js
// Purpose: Provides utilities for setting up DOM event listeners.

import { log } from '../core/logger.js';
import { registerEventListener } from './dom-events.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from '../utils/logging-utils.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Event configuration registry for common event patterns.
 * @type {Object.<string, Object>}
 */
const EVENT_CONFIGS = {
  formSubmit: {
    eventType: 'submit',
    selector: '#{formId}',
    handler: async (context, event, formId, endpoint, configKey, options) => {
      event.preventDefault();
      const { submitConfiguredForm } = await import('../utils/form-submission.js');
      await withErrorHandling(`${context}:formSubmit`, () => submitConfiguredForm(context, formId, endpoint, configKey, options), ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
    },
  },
  navigationToggle: {
    eventType: 'click',
    selector: '#{navToggleId}',
    handler: async (context, event, navId) => {
      const { toggleViewState } = await import('./dom-manipulation.js');
      await withErrorHandling(`${context}:navigationToggle`, () => {
        log(context, `Toggling navigation: ${navId}`);
        toggleViewState(context, { [navId]: true });
      }, ERROR_MESSAGES.SECTION_TOGGLE_FAILED);
    },
  },
  permissionChange: {
    eventType: 'change',
    selector: '#userList input[data-userId][data-permission]',
    handler: async (context, event) => {
      const { updateUserPermission } = await import('../admin/users-data.js');
      const { userId, permission, role } = event.target.dataset;
      const isChecked = event.target.checked;
      await withErrorHandling(`${context}:permissionChange`, async () => {
        log(context, `Processing permission change for user ${userId}, permission ${permission}, role ${role}`);
        await updateUserPermission(context, userId, permission, isChecked, role);
      }, ERROR_MESSAGES.FETCH_FAILED('permission update'), () => {
        event.target.checked = !isChecked; // Revert checkbox on error
      });
    },
  },
  modifyPermissions: {
    eventType: 'click',
    selector: '#userList .modify-permissions',
    handler: async (context, event) => {
      const { fetchUserForPermissions } = await import('../admin/users-data.js');
      const { renderPermissionsModal } = await import('../admin/users-ui.js');
      const { setupAdminEvents } = await import('../admin/admin-events.js');
      const { userId, role } = event.target.dataset;
      await withErrorHandling(`${context}:modifyPermissions`, async () => {
        log(context, `Initiating permissions modification for user ${userId}, role ${role}`);
        const userData = await fetchUserForPermissions(context, userId);
        await renderPermissionsModal(context, userId, userData, role);
        setupAdminEvents(context); // Re-apply modal events
      }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
    },
  },
  categoryCheckboxChange: {
    eventType: 'change',
    selector: 'input[data-deselected]',
    handler: async (context, event) => {
      const { updateDeselectedCategories } = await import('../community/categories-data.js');
      const { updateFormState } = await import('../utils/form-submission.js');
      const { withElement } = await import('./dom-manipulation.js');
      await withErrorHandling(`${context}:categoryCheckboxChange`, async () => {
        await withElement(context, 'deselected', async (deselectedInput) => {
          await withElement(context, 'previousDeselected', async (previousDeselectedInput) => {
            const allCategories = Array.from(document.querySelectorAll('input[name="selected"]')).map(cb => cb.value);
            const selectedCategories = Array.from(document.querySelectorAll('input[name="selected"]:checked')).map(cb => cb.value);
            const { deselected, previousDeselected } = updateDeselectedCategories(context, selectedCategories, allCategories);
            await updateFormState(context, 'categoryForm', {
              deselected: JSON.stringify(deselected),
              previousDeselected: JSON.stringify(previousDeselected),
            });
            log(context, 'Updated deselections:', deselected);
          });
        }, 10, 100, true);
      }, ERROR_MESSAGES.DATA_PROCESSING_FAILED);
    },
  },
};

/**
 * Sets up multiple event listeners based on the provided configurations.
 * @param {string} context - The context or module name.
 * @param {Array<{eventType: string, selector: string, handler: Function}>} listeners - Array of listener configurations.
 * @returns {void}
 */
export function setupEventListeners(context, listeners) {
  log(context, 'Setting up event listeners');
  withErrorHandling(`${context}:setupEventListeners`, () => {
    listeners.forEach(({ eventType, selector, handler }) => {
      registerEventListener(context, eventType, selector, async event => {
        await withErrorHandling(`${context}:eventHandler`, () => handler(event), ERROR_MESSAGES.EVENT_HANDLER_FAILED);
      });
    });
  }, ERROR_MESSAGES.EVENT_HANDLER_FAILED);
}

/**
 * Registers event listeners from the event configuration registry.
 * @param {string} context - The context or module name.
 * @param {Array<string>} configKeys - Array of event configuration keys.
 * @param {Object} [params={}] - Parameters to customize selectors and handlers.
 * @returns {void}
 */
export function registerEvents(context, configKeys, params = {}) {
  log(context, `Registering events: ${configKeys.join(', ')}`);
  withErrorHandling(`${context}:registerEvents`, () => {
    configKeys.forEach(key => {
      const config = EVENT_CONFIGS[key];
      if (!config) {
        log(context, `Event configuration not found: ${key}`);
        return;
      }
      let selector = config.selector;
      if (selector.includes('{')) {
        selector = selector.replace(/{(\w+)}/g, (_, param) => params[param] || '');
      }
      registerEventListener(context, config.eventType, selector, async event => {
        await withErrorHandling(`${context}:${key}`, () => config.handler(context, event, ...Object.values(params)), ERROR_MESSAGES.EVENT_HANDLER_FAILED);
      });
    });
  }, ERROR_MESSAGES.EVENT_HANDLER_FAILED);
}

/**
 * Sets up event listeners for form field interactions (e.g., radio buttons, checkboxes).
 * @param {string} context - The context or module name.
 * @param {Object} config - Configuration object.
 * @returns {void}
 */
export function setupFormFieldEvents(context, { selector, eventType, handler }) {
  log(context, `Setting up form field events for selector: ${selector}`);
  registerEventListener(context, eventType, selector, async event => {
    await withErrorHandling(`${context}:formFieldEvent`, () => handler(event), ERROR_MESSAGES.EVENT_HANDLER_FAILED);
  });
}

/**
 * Initializes the event-listeners module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} EventListeners instance with public methods.
 */
export function initializeEventListenersModule(registry) {
  return createModuleInitializer('event-listeners.js', {
    setupEventListeners,
    registerEvents,
    setupFormFieldEvents,
  });
}

// Initialize module with lifecycle logging
const context = 'event-listeners.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/form-rendering.js
// /static/js/utils/form-rendering.js
// Purpose: Provides utilities for rendering form elements based on configurations.

import { log } from '../core/logger.js';
import { renderMarkdown } from '../core/markdown.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from './logging-utils.js';
import { getFormConfig } from '../config/form-configs.js';

/**
 * Generates a style string or object for form elements.
 * @param {string} type - The type of form element (e.g., 'categories').
 * @param {Object} styles - Style properties to apply.
 * @returns {string} A CSS style string.
 */
export function renderStyles(type, styles) {
    const context = 'form-rendering.js';
    log(context, `Rendering styles for type: ${type}`);
    return Object.entries(styles)
        .map(([key, value]) => `${key.replace(/([A-Z])/g, '-$1').toLowerCase()}: ${value}`)
        .join('; ');
}

/**
 * Renders a form based on the provided configuration and either appends it to the container or returns the HTML.
 * @param {Object} formConfig - The form configuration object (must contain id, action, method, etc.).
 * @param {Object} [config={}] - Additional rendering configuration options.
 * @param {HTMLElement|null} [container=null] - The container element to render the form in. If null, returns the HTML as a string.
 * @returns {string|void} Returns the rendered form HTML as a string if container is null; otherwise, appends to the container.
 */
export function renderForm(formConfig, config = {}, container = null) {
    const context = 'form-rendering.js';
    log(context, 'Rendering form with formId:', formConfig, 'config:', config, 'container:', container);
    return withErrorHandling(`${context}:renderForm`, () => {
        // Validate formConfig
        if (!formConfig || typeof formConfig !== 'object' || !formConfig.id) {
            throw new Error('Invalid form configuration: formConfig must be an object with an id property');
        }

        const { id = formConfig.id, action = '', method = 'POST', fields = [], customFields = [], submitButtonText = 'Submit', extraButtons = [], wrapper } = formConfig;

        // Validate fields array
        if (!Array.isArray(fields)) {
            throw new Error('Form configuration must include a fields array');
        }

        // Render form fields
        const fieldHtml = fields
            .map(field => {
                if (!field.name || !field.type) {
                    log(context, `Warning: Field missing name or type: ${JSON.stringify(field)}`);
                    return '';
                }
                let inputHtml;
                switch (field.type) {
                    case 'textarea':
                        inputHtml = `
                            <textarea id="${field.id || field.name}" name="${field.name}" ${field.required ? 'required' : ''} rows="${field.rows || 4}" cols="${field.cols || 50}" style="${field.style || ''}">${field.value || ''}</textarea>
                        `;
                        break;
                    case 'hidden':
                        inputHtml = `<input type="hidden" id="${field.id || field.name}" name="${field.name}" value="${field.value || ''}">`;
                        break;
                    default:
                        inputHtml = `
                            <input type="${field.type}" id="${field.id || field.name}" name="${field.name}" value="${field.value || ''}" ${field.required ? 'required' : ''} style="${field.style || ''}" ${field.attributes ? Object.entries(field.attributes).map(([k, v]) => `${k}="${v}"`).join(' ') : ''}>
                        `;
                }
                const extraButtonsHtml = field.extraButtons
                    ? field.extraButtons.map(btn => {
                          const btnAttributes = Object.entries(btn)
                              .filter(([key]) => key !== 'text')
                              .map(([key, value]) => `${key}="${value}"`)
                              .join(' ');
                          return `<button ${btnAttributes}>${btn.text}</button>`;
                      }).join('')
                    : '';
                const fieldWrapperStyle = field.wrapper ? `class="${field.wrapper.class || ''}" style="${field.wrapper.style || ''}"` : '';
                return `
                    <div ${fieldWrapperStyle}>
                        <label for="${field.id || field.name}">${field.label || ''}</label>
                        ${inputHtml}
                        ${extraButtonsHtml}
                    </div>
                `;
            })
            .join('');

        // Render custom fields (e.g., checkbox lists)
        const customFieldHtml = customFields
            .map(field => {
                if (field.type === 'checkboxList' && field.render) {
                    return field.render(field.items, field.selected);
                }
                return '';
            })
            .join('');

        // Render form-level buttons
        const buttonsHtml = `
            <button type="submit">${submitButtonText}</button>
            ${extraButtons.map(btn => `<button type="${btn.type || 'button'}" data-action="${btn.dataAction || ''}" style="${btn.style || ''}">${btn.text}</button>`).join('')}
        `;

        // Apply form wrapper styles
        const wrapperStyle = wrapper ? `class="${wrapper.class || ''}" style="${wrapper.style || ''}"` : '';

        // Combine HTML
        const formHtml = `
            <form id="${id}" action="${action}" method="${method}">
                <div ${wrapperStyle}>
                    ${fieldHtml}
                    ${customFieldHtml}
                    ${buttonsHtml}
                </div>
            </form>
        `;

        // If container is provided, append the form to it; otherwise, return the HTML
        if (container && container instanceof HTMLElement) {
            container.innerHTML = formHtml;
            log(context, `Form ${id} rendered successfully in container with ${fields.length} fields`);
            return;
        }

        log(context, `Form ${id} rendered as HTML string with ${fields.length} fields`);
        return formHtml;
    }, ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
}

/**
 * Renders markdown content into a container.
 * @param {string} context - The context or module name.
 * @param {string} markdownPath - The path to the markdown file.
 * @param {string} targetId - The ID of the container to render into.
 * @returns {Promise<void>}
 */
export async function renderMarkdownContent(context, markdownPath, targetId) {
    log(context, `Rendering markdown content into: ${targetId}`);
    await withErrorHandling(`${context}:renderMarkdownContent`, async () => {
        const htmlContent = await renderMarkdown(context, markdownPath);
        const target = document.getElementById(targetId);
        if (!target) {
            throw new Error(`Target element ${targetId} not found`);
        }
        target.innerHTML = htmlContent;
    }, ERROR_MESSAGES.MARKDOWN_RENDER_FAILED);
}

/**
 * Initializes the form-rendering module for use with the module registry.
 * @param {Map} registry - The module registry instance.
 * @returns {Object} FormRendering instance with public methods.
 */
export function initializeFormRenderingModule(registry) {
    const context = 'form-rendering.js';
    log(context, 'Initializing form-rendering module for module registry');
    return {
        renderForm: (formConfig, config, container) => renderForm(formConfig, config, container),
        renderMarkdownContent: (ctx, ...args) => renderMarkdownContent(ctx, ...args),
    };
}

/**
 * Initializes the form-rendering module.
 */
export function initializeFormRendering() {
    withScriptLogging('form-rendering.js', () => {
        log('form-rendering.js', 'Module initialized');
    });
}
utils/form-submission.js
// /static/js/utils/form-submission.js
import { log } from '../core/logger.js';
import { getFormConfig } from '../config/form-configs.js';
import { success, error as notifyError } from '../core/notifications.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from './logging-utils.js';

const context = 'form-submission.js';

/**
 * Validates a UK phone number.
 * @param {string} context - The context or module name.
 * @param {string} phone - The phone number to validate.
 * @returns {boolean} True if valid, false otherwise.
 */
export function validatePhoneNumber(context, phone) {
    log(context, `Validating phone number: ${phone}`);
    return withErrorHandling(`${context}:validatePhoneNumber`, () => {
        const isValid = phone && /^[0-9]{10,11}$/.test(phone.trim());
        log(context, `Phone number validation result: ${isValid}`);
        return isValid;
    }, 'Phone number validation failed');
}

/**
 * Configures and submits a form to the specified endpoint.
 * @param {string} context - The context or module name.
 * @param {string} formId - The form's ID.
 * @param {string} endpoint - The submission endpoint.
 * @param {string} configKey - The form config key.
 * @param {Object} [options={}] - Submission options.
 * @returns {Promise<Object>} The response data or throws an error.
 */
export async function submitConfiguredForm(context, formId, endpoint, configKey, options = {}) {
    log(context, `Starting form submission configuration for formId: ${formId}, endpoint: ${endpoint}, configKey: ${configKey}`);
    let formData = null;
    try {
        // Check if the form exists
        const form = document.getElementById(formId);
        if (!form) {
            log(context, `Form ${formId} not found`);
            throw new Error(`Form ${formId} not found`);
        }
        log(context, `Form ${formId} found`);

        // Retrieve form configuration
        const config = getFormConfig(context, configKey);
        if (!config || !config.method) {
            log(context, `No valid form configuration for key: ${configKey}`);
            throw new Error(`No valid form configuration for key: ${configKey}`);
        }
        log(context, `Form configuration retrieved for key: ${configKey}`);

        // Collect form data
        log(context, `Collecting form data for formId: ${formId}`);
        formData = new FormData(form);
        log(context, `Form data collected:`, Array.from(formData.entries()));

        // Validate form data if applicable
        if (config.validate) {
            log(context, `Validating form data for formId: ${formId}`);
            config.validate(formData);
            log(context, `Form data validation passed for formId: ${formId}`);
        }

        // Transform data if applicable
        const transformedData = config.transform ? config.transform(formData) : Object.fromEntries(formData);
        log(context, `Transformed data:`, transformedData);

        // Make API call
        log(context, `Making request to ${endpoint} for formId: ${formId}`);
        const response = await fetch(endpoint, {
            method: config.method || 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(transformedData),
        });
        log(context, `API response status: ${response.status}`);

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API request failed with status ${response.status}: ${errorText}`);
        }

        let responseData;
        try {
            responseData = await response.json();
        } catch (parseError) {
            log(context, `Failed to parse response as JSON: ${parseError.message}`);
            throw new Error(`Invalid JSON response from server`);
        }
        log(context, `API response data:`, responseData);

        // Handle success
        success(context, options.successMessage || config.successMessage || 'Form submitted successfully');
        if (options.onSuccess) {
            log(context, `Invoking onSuccess for formId: ${formId}`);
            options.onSuccess(responseData);
        }

        return responseData;
    } catch (error) {
        log(context, `Form submission failed for formId: ${formId}: ${error.message}`);
        console.error('Detailed error:', error);
        if (options.onError) {
            log(context, `Invoking onError for formId: ${formId}`);
            options.onError(error, formData);
        }
        notifyError(context, error.message || ERROR_MESSAGES.FORM_SUBMISSION_FAILED);
        throw error; // Rethrow to allow caller to handle
    } finally {
        log(context, `Submission process completed for formId: ${formId}`);
    }
}

/**
 * Updates form field values dynamically.
 * @param {string} context - The context or module name.
 * @param {string} formId - The form's ID.
 * @param {Object} updates - Field name-value pairs to update.
 */
export async function updateFormState(context, formId, updates) {
    log(context, `Starting form state update for formId: ${formId}`);
    await withErrorHandling(`${context}:updateFormState`, async () => {
        const form = document.getElementById(formId);
        if (!form) {
            log(context, `Form ${formId} not found for state update`);
            throw new Error(`Form ${formId} not found`);
        }
        log(context, `Form ${formId} found for state update`);
        Object.entries(updates).forEach(([name, value]) => {
            const input = form.querySelector(`[name="${name}"]`);
            if (input) {
                input.value = value;
                log(context, `Updated field ${name} to ${value} in form ${formId}`);
            } else {
                log(context, `Field ${name} not found in form ${formId}`);
            }
        });
    }, ERROR_MESSAGES.ELEMENT_NOT_FOUND);
}

/**
 * Initializes the form submission module.
 * @param {Object} registry - The registry object.
 * @returns {Object} Module functions.
 */
export function initializeFormSubmissionModule(registry) {
    log(context, 'Initializing form-submission module');
    return {
        submitConfiguredForm,
        updateFormState,
        validatePhoneNumber,
    };
}

withScriptLogging(context, () => {
    log(context, 'Module initialized');
});
utils/form-validation-utils.js
// /static/js/utils/form-validation-utils.js
// Purpose: Provides helper functions for form validation.

import { log } from '../core/logger.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from './logging-utils.js';

/**
 * Checks if a form field is empty.
 * @param {string} context - The context or module name.
 * @param {string} value - The field value.
 * @returns {boolean} True if the field is empty, false otherwise.
 */
export function isEmpty(context, value) {
  log(context, `Checking if value is empty: ${value}`);
  return !value || value.trim() === '';
}

/**
 * Validates an email address format.
 * @param {string} context - The context or module name.
 * @param {string} email - The email address to validate.
 * @returns {boolean} True if the email is valid, false otherwise.
 */
export function isValidEmail(context, email) {
  log(context, `Validating email: ${email}`);
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return withErrorHandling(`${context}:isValidEmail`, () => emailRegex.test(email), ERROR_MESSAGES.FORM_VALIDATION_FAILED);
}

/**
 * Initializes the form-validation-utils module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} FormValidationUtils instance with public methods.
 */
export function initializeFormValidationUtilsModule(registry) {
  const context = 'form-validation-utils.js';
  log(context, 'Initializing form-validation-utils module for module registry');
  return {
    isEmpty: (ctx, ...args) => isEmpty(ctx, ...args),
    isValidEmail: (ctx, ...args) => isValidEmail(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'form-validation-utils.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/form-validation.js
// /static/js/utils/form-validation.js
// Purpose: Provides form validation utilities for common form fields.

import { log } from '../core/logger.js';
import { withErrorHandling } from './error.js';
import { isValidEmail } from './form-validation-utils.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from './logging-utils.js';

/**
 * Validates required fields in a form.
 * @param {string} context - The context or module name.
 * @param {FormData} formData - The form data.
 * @param {string[]} requiredFields - Array of required field names.
 * @returns {boolean} True if all required fields are valid, false otherwise.
 */
export function validateRequiredFields(context, formData, requiredFields) {
  log(context, `Validating required fields: ${requiredFields.join(', ')}`);
  return withErrorHandling(`${context}:validateRequiredFields`, () => {
    return requiredFields.every(field => {
      const value = formData.get(field)?.trim();
      if (!value) {
        log(context, `Required field missing: ${field}`);
        return false;
      }
      if (field.includes('email') && !isValidEmail(context, value)) {
        log(context, `Invalid email format: ${value}`);
        return false;
      }
      return true;
    });
  }, ERROR_MESSAGES.FORM_VALIDATION_FAILED);
}

/**
 * Validates password fields, ensuring they match and meet requirements.
 * @param {string} context - The context or module name.
 * @param {FormData} formData - The form data.
 * @param {string} passwordField - The name of the password field.
 * @param {string} confirmField - The name of the confirm password field.
 * @returns {boolean} True if passwords are valid and match, false otherwise.
 */
export function validatePassword(context, formData, passwordField, confirmField) {
  log(context, `Validating password fields: ${passwordField}, ${confirmField}`);
  return withErrorHandling(`${context}:validatePassword`, () => {
    const password = formData.get(passwordField);
    const confirmPassword = formData.get(confirmField);
    if (!password || !confirmPassword) {
      log(context, 'Password or confirm password missing');
      return false;
    }
    if (password !== confirmPassword) {
      log(context, 'Passwords do not match');
      return false;
    }
    if (password.length < 8) {
      log(context, 'Password must be at least 8 characters');
      return false;
    }
    return true;
  }, ERROR_MESSAGES.FORM_VALIDATION_FAILED);
}

/**
 * Validates a phone number based on signup type.
 * @param {string} context - The context or module name.
 * @param {FormData} formData - The form data.
 * @param {string} phoneField - The name of the phone field.
 * @param {string} typeField - The name of the signup type field.
 * @returns {boolean} True if the phone number is valid, false otherwise.
 */
export function validatePhoneNumber(context, formData, phoneField, typeField) {
  log(context, `Validating phone number: ${phoneField}`);
  return withErrorHandling(`${context}:validatePhoneNumber`, () => {
    const signupType = formData.get(typeField);
    const phone = formData.get(phoneField)?.trim();
    if (signupType === 'merchant' && !phone) {
      log(context, 'Phone number required for merchant signup');
      return false;
    }
    if (phone) {
      const phoneRegex = /^\+?[1-9]\d{1,14}$/;
      if (!phoneRegex.test(phone)) {
        log(context, `Invalid phone number format: ${phone}`);
        return false;
      }
    }
    return true;
  }, ERROR_MESSAGES.FORM_VALIDATION_FAILED);
}

/**
 * Validates the forgot password form.
 * @param {string} context - The context or module name.
 * @param {FormData} formData - The form data.
 * @returns {boolean} True if the form is valid, false otherwise.
 */
export function validateForgotPassword(context, formData) {
  log(context, 'Validating forgot password form');
  return validateRequiredFields(context, formData, ['email']);
}

/**
 * Validates the OTP verification form.
 * @param {string} context - The context or module name.
 * @param {FormData} formData - The form data.
 * @returns {boolean} True if the form is valid, false otherwise.
 */
export function validateVerifyOtp(context, formData) {
  log(context, 'Validating OTP verification form');
  return validateRequiredFields(context, formData, ['email', 'otp', 'new_password', 'confirm_new_password']) &&
         validatePassword(context, formData, 'new_password', 'confirm_new_password');
}

/**
 * Initializes the form-validation module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} FormValidation instance with public methods.
 */
export function initializeFormValidationModule(registry) {
  const context = 'form-validation.js';
  log(context, 'Initializing form-validation module for module registry');
  return {
    validateRequiredFields: (ctx, ...args) => validateRequiredFields(ctx, ...args),
    validatePassword: (ctx, ...args) => validatePassword(ctx, ...args),
    validatePhoneNumber: (ctx, ...args) => validatePhoneNumber(ctx, ...args),
    validateForgotPassword: (ctx, ...args) => validateForgotPassword(ctx, ...args),
    validateVerifyOtp: (ctx, ...args) => validateVerifyOtp(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'form-validation.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/icons.js
// /static/js/utils/icons.js
// Purpose: Provides utilities for creating and managing icons in the DOM.

import { log } from '../core/logger.js';
import { withErrorHandling } from './error.js';
import { withScriptLogging } from './logging-utils.js';

const context = 'icons.js';

/**
 * Creates an icon element with the specified class and optional attributes.
 * @param {string} context - The context or module name for logging.
 * @param {string} iconClass - The CSS class for the icon (e.g., 'fas fa-user').
 * @param {Object} attributes - Additional attributes to set on the icon element.
 * @returns {HTMLElement} The created icon element.
 */
export function createIcon(context, iconClass, attributes = {}) {
    return withErrorHandling(`${context}:createIcon`, () => {
        log(context, `Creating icon with class: ${iconClass}`);
        const icon = document.createElement('i');

        // Validate and apply icon class, falling back to 'fas fa-link' if invalid
        const isValidClass = iconClass && typeof iconClass === 'string' && iconClass.trim() !== '';
        const appliedClass = isValidClass ? iconClass.trim() : 'fas fa-link';
        icon.className = appliedClass;

        if (!isValidClass) {
            log(context, `Invalid icon class provided: ${iconClass}, falling back to 'fas fa-link'`, 'warn');
        }

        // Apply additional attributes
        Object.entries(attributes).forEach(([key, value]) => {
            if (value !== undefined && value !== null) {
                icon.setAttribute(key, value);
            }
        });

        log(context, `Icon created with class: ${appliedClass}`);
        return icon;
    }, 'Failed to create icon', () => {
        const fallbackIcon = document.createElement('i');
        fallbackIcon.className = 'fas fa-link';
        log(context, 'Returning fallback icon with class: fas fa-link');
        return fallbackIcon;
    });
}

/**
 * Initializes the icons module for use with the module registry.
 * @param {Map} registry - The module registry instance.
 * @returns {Object} Module instance with public methods.
 */
export function initializeIconsModule(registry) {
    log(context, 'Initializing icons module for module registry');
    return {
        createIcon: (ctx, iconClass, attributes) => createIcon(ctx, iconClass, attributes)
    };
}

// Initialize the module with lifecycle logging
withScriptLogging(context, () => {
    log(context, 'Module initialized');
});
utils/initialization.js
// /static/js/utils/initialization.js
// Purpose: Provides utilities for module initialization, page setup, and navigation.

import { log, error as logError } from '../core/logger.js';
import { withAuthenticatedUser } from '../core/auth.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { defineSectionHandlers } from '../modules/navigation.js';
import { withScriptLogging } from './logging-utils.js';
import { toggleViewState } from './dom-manipulation.js';
import { getMenu } from '../config/menus.js';

const context = 'initialization.js';

/**
 * Determines if the module should be initialized based on the current page type.
 * @param {string} expectedPageType - The page type expected for the module.
 * @returns {boolean} True if the current page type matches the expected page type, false otherwise.
 */
export function shouldInitializeForPageType(expectedPageType) {
    const metaPageType = document.querySelector('meta[name="page-type"]')?.content;
    const shouldInitialize = metaPageType === expectedPageType;
    log(context, `Checking page type: current=${metaPageType}, expected=${expectedPageType}, shouldInitialize=${shouldInitialize}`);
    return shouldInitialize;
}

/**
 * Shows the specified section and hides others.
 * @param {string} sectionId - The ID of the section to show.
 */
function showSection(sectionId) {
    const sections = document.querySelectorAll('.section');
    sections.forEach(section => {
        if (section.id === sectionId) {
            section.style.display = 'block';
        } else {
            section.style.display = 'none';
        }
    });
}

/**
 * Creates a module initializer for the registry with standardized method wrapping.
 * @param {string} context - The context or module name.
 * @param {Object} methods - Object mapping method names to functions.
 * @returns {Object} Module instance with wrapped methods.
 */
export function createModuleInitializer(context, methods) {
    log(context, `Initializing ${context} module for module registry`);
    return Object.keys(methods).reduce((acc, key) => {
        acc[key] = (ctx, ...args) => methods[key](ctx, ...args);
        return acc;
    }, {});
}

/**
 * Parses the page type from a meta tag, DOM element, or query parameter.
 * @param {string} context - The context or module name.
 * @param {string} param - The query parameter name or DOM element ID.
 * @param {string} defaultType - The default page type.
 * @returns {string} The parsed page type.
 */
export function parsePageType(context, param, defaultType) {
    log(context, `Parsing page type from param: ${param}`);
    try {
        const metaPageType = document.querySelector('meta[name="page-type"]')?.content;
        if (metaPageType && ['admin', 'community', 'merchant', 'partner', 'login'].includes(metaPageType)) {
            log(context, `Page type resolved from meta tag: ${metaPageType}`);
            return metaPageType;
        }
        const pageTypeElement = document.getElementById(param);
        if (pageTypeElement) {
            const pageType = pageTypeElement.value || defaultType;
            log(context, `Page type resolved from DOM element: ${pageType}`);
            return pageType;
        }
        const urlParams = new URLSearchParams(window.location.search);
        const pageType = urlParams.get(param) || defaultType;
        log(context, `Page type resolved from query parameter: ${pageType}`);
        return pageType;
    } catch (error) {
        logError(context, `Error parsing page type: ${error.message}`);
        return defaultType;
    }
}

/**
 * Retrieves and validates the default section from the `section` query parameter.
 * @param {string} context - The context or module name.
 * @param {string} role - The role associated with the page (e.g., 'admin', 'merchant').
 * @param {string} fallbackSection - The fallback section if the query parameter is invalid.
 * @returns {string} The validated section ID.
 */
export function getDefaultSectionFromQuery(context, role, fallbackSection) {
    log(context, `Parsing default section for role: ${role}, fallback: ${fallbackSection}`);
    try {
        const urlParams = new URLSearchParams(window.location.search);
        const sectionParam = urlParams.get('section');
        if (!sectionParam) {
            log(context, `No section query parameter found, using fallback: ${fallbackSection}`);
            return fallbackSection;
        }

        const validSections = role === 'login' 
            ? ['info', 'signupContainer', 'forgotPasswordContainer', 'completeSignup', 'failSignupContainer']
            : getMenu(role).map(item => item.section);

        if (validSections.includes(sectionParam)) {
            log(context, `Valid section found in query: ${sectionParam}`);
            return sectionParam;
        } else {
            log(context, `Invalid section parameter: ${sectionParam}, using fallback: ${fallbackSection}`);
            return fallbackSection;
        }
    } catch (error) {
        logError(context, `Error getting default section: ${error.message}`);
        return fallbackSection;
    }
}

/**
 * Initializes role-based navigation for a page.
 * @param {HTMLElement} element - The DOM element to render the menu into.
 * @param {Array} menu - The menu configuration for the role.
 * @param {Object} options - Options for navigation setup.
 * @param {Object} options.sectionHandlers - Section handler functions.
 * @param {string} options.defaultSection - The default section to display.
 * @returns {Promise<void>}
 */
export async function initializeRoleNavigation(element, menu, { sectionHandlers, defaultSection }) {
    log(context, 'Initializing role navigation with menu:', menu);
    await withErrorHandling(`${context}:initializeRoleNavigation`, async () => {
        if (!element) {
            log(context, 'Navigation element not provided');
            return;
        }
        if (!Array.isArray(menu)) {
            log(context, 'Invalid menu configuration; expected an array');
            return;
        }
        element.innerHTML = '';
        log(context, 'Cleared existing menu content');
        const buttons = [];
        menu.forEach(item => {
            const button = document.createElement('button');
            button.dataset.section = item.section;
            button.innerHTML = `
                ${item.icons ? item.icons.map(icon => `<i class="${icon}"></i>`).join('') : ''}
                ${item.label}
            `;
            button.addEventListener('click', () => {
                log(context, `Navigating to section: ${item.section}`);
                const handler = sectionHandlers[item.section];
                if (handler) {
                    handler(true, item.role);
                    toggleViewState(context, { [item.section]: true });
                } else if (item.action) {
                    item.action();
                } else {
                    log(context, `No handler or action found for section: ${item.section}`);
                }
            });
            buttons.push(button);
        });
        buttons.forEach(button => element.appendChild(button));
        log(context, `Appended ${buttons.length} buttons to menu element`);
        const resolvedDefaultSection = defaultSection;
        if (resolvedDefaultSection && sectionHandlers[resolvedDefaultSection]) {
            log(context, `Activating default section: ${resolvedDefaultSection}`);
            await sectionHandlers[resolvedDefaultSection](true);
            toggleViewState(context, { [resolvedDefaultSection]: true });
            const defaultButton = element.querySelector(`[data-section="${resolvedDefaultSection}"]`);
            if (defaultButton) {
                defaultButton.classList.add('active');
                log(context, `Set active class on default button: ${resolvedDefaultSection}`);
            }
        } else {
            log(context, `No handler found for default section: ${resolvedDefaultSection}`);
        }
    }, ERROR_MESSAGES.NAVIGATION_INIT_FAILED);
}

/**
 * Initializes a role-based page with authentication, navigation, and custom setup.
 * @param {string} context - The context or module name.
 * @param {string} role - The role associated with the page (e.g., 'admin', 'merchant').
 * @param {string} pageType - The type of page to initialize (e.g., 'products', 'integrations').
 * @param {Function} callback - The callback to execute for role-specific setup.
 * @returns {Promise<void>}
 */
export async function initializeRolePage(context, role, pageType, callback) {
    log(context, `Initializing ${role} page with type: ${pageType}`);
    if (role === 'login') {
        await withErrorHandling(`${context}:initializeRolePage`, async () => {
            const userIdInput = document.getElementById('userId');
            if (userIdInput) userIdInput.value = localStorage.getItem('userId') || '';
            await callback();
        }, ERROR_MESSAGES.MODULE_INIT_FAILED);
    } else {
        await withAuthenticatedUser(context, async () => {
            await withErrorHandling(`${context}:initializeRolePage`, async () => {
                const userIdInput = document.getElementById('userId');
                if (userIdInput) userIdInput.value = localStorage.getItem('userId') || '';
                await callback();
            }, ERROR_MESSAGES.MODULE_INIT_FAILED);
        }, 'initializeRolePage');
    }
}

/**
 * Hides the loading overlay and shows the layout wrapper with fallback.
 */
export function hideOverlay() {
    log(context, 'Attempting to hide loadingOverlay');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const layoutWrapper = document.querySelector('.layout-wrapper');
    if (!loadingOverlay) {
        log(context, 'Error: loadingOverlay element not found');
        return;
    }
    if (!layoutWrapper) {
        log(context, 'Error: layoutWrapper element not found');
        return;
    }
    log(context, 'Hiding loadingOverlay and showing layoutWrapper');
    loadingOverlay.classList.add('hidden');
    loadingOverlay.style.display = 'none';
    layoutWrapper.style.display = '';
    setTimeout(() => {
        if (loadingOverlay.style.display !== 'none') {
            log(context, 'Fallback: Forcing loadingOverlay to hide');
            loadingOverlay.style.display = 'none';
        }
    }, 2000);
}

/**
 * Initializes the initialization module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} Initialization instance with public methods.
 */
export function initializeInitializationModule(registry) {
    return createModuleInitializer('initialization.js', {
        withScriptLogging,
        createModuleInitializer,
        parsePageType,
        getDefaultSectionFromQuery,
        initializeRoleNavigation,
        initializeRolePage,
        hideOverlay,
        shouldInitializeForPageType
    });
}

// Global event listener for the button in roles.inc
document.addEventListener('click', (event) => {
    const infoButton = event.target.closest('button[data-section="info"]');
    if (infoButton) {
        console.log('Info button clicked');
        showSection('info');
    }
});

// Initialize module with lifecycle logging
withScriptLogging(context, () => {
    log(context, 'Module initialized');
});
utils/logging-utils.js
// /static/js/utils/logging-utils.js
// Purpose: Provides logging utilities for script lifecycle management.

import { log } from '../core/logger.js';

/**
 * Wraps a module initialization function with lifecycle logging.
 * @param {string} context - The context or module name.
 * @param {Function} initFn - The initialization function to wrap.
 * @returns {void}
 */
export function withScriptLogging(context, initFn) {
  log(context, 'Starting module initialization');
  try {
    const result = initFn();
    log(context, 'Module initialization completed');
    return result;
  } catch (error) {
    log(context, `Module initialization failed: ${error.message}`);
    throw error;
  }
}

/**
 * Initializes the logging-utils module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} LoggingUtils instance with public methods.
 */
export function initializeLoggingUtilsModule(registry) {
  log('logging-utils.js', 'Initializing logging-utils module for module registry');
  return {
    withScriptLogging,
  };
}

// Initialize module with lifecycle logging
const context = 'logging-utils.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/settings-data.js
// /static/js/utils/settings-data.js
// Purpose: Provides utilities for fetching settings data.

import { log } from '../core/logger.js';
import { fetchData } from './data-fetch.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from './logging-utils.js';

/**
 * Loads settings data from the specified endpoint.
 * @param {string} context - The context or module name.
 * @param {string} endpoint - The API endpoint to fetch settings from.
 * @returns {Promise<Array>} The fetched settings data.
 */
export async function loadSettings(context, endpoint) {
  log(context, `Loading settings from endpoint: ${endpoint}`);
  return await withErrorHandling(`${context}:loadSettings`, async () => {
    const data = await fetchData(context, endpoint);
    return data.settings || [];
  }, ERROR_MESSAGES.FETCH_FAILED('settings'), () => []);
}

/**
 * Initializes the settings-data module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} SettingsData instance with public methods.
 */
export function initializeSettingsDataModule(registry) {
  const context = 'settings-data.js';
  log(context, 'Initializing settings-data module for module registry');
  return {
    loadSettings: (ctx, ...args) => loadSettings(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'settings-data.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/settings-events.js
// /static/js/utils/settings-events.js
// Purpose: Provides utilities for setting up settings-related event listeners.

import { log } from '../core/logger.js';
import { setupEventListeners } from './event-listeners.js';
import { fetchData } from './data-fetch.js';
import { success } from '../core/notifications.js';
import { withScriptLogging } from './logging-utils.js';

/**
 * Sets up event listeners for settings form submissions.
 * @param {string} context - The context or module name.
 * @param {string} formId - The ID of the form.
 * @param {string} endpoint - The API endpoint for submission.
 * @param {string} settingType - The type of setting (e.g., 'api', 'affiliate').
 * @returns {void}
 */
export function setupSettingsEvents(context, formId, endpoint, settingType) {
  log(context, `Setting up settings events for form: ${formId}`);
  setupEventListeners(context, [
    {
      eventType: 'submit',
      selector: `#${formId}`,
      handler: async e => {
        e.preventDefault();
        const fields = {};
        Array.from(e.target.querySelectorAll('input')).forEach(input => {
          fields[input.name] = input.value;
        });
        await fetchData(context, `${endpoint}/${settingType}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(fields),
        });
        success(context, `Settings for ${settingType} updated successfully`);
      },
    },
  ]);
}

/**
 * Initializes the settings-events module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} SettingsEvents instance with public methods.
 */
export function initializeSettingsEventsModule(registry) {
  const context = 'settings-events.js';
  log(context, 'Initializing settings-events module for module registry');
  return {
    setupSettingsEvents: (ctx, ...args) => setupSettingsEvents(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'settings-events.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/settings-renderer.js
// /static/js/utils/settings-renderer.js
// Purpose: Provides utilities for rendering settings UI components.

import { log } from '../core/logger.js';
import { renderSettingsFields } from './settings-ui.js';
import { setupSettingsEvents } from './settings-events.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from './logging-utils.js';
import { createModuleInitializer } from '../utils/initialization.js';

/**
 * Renders a settings form based on the provided configuration.
 * @param {string} context - The context or module name.
 * @param {Object} config - Settings configuration object.
 * @returns {Promise<void>}
 */
export async function renderSettingsForm(context, config) {
  log(context, `Rendering settings form for type: ${config.type}`);
  await withErrorHandling(`${context}:renderSettingsForm`, async () => {
    await renderSettingsFields(context, config.settings || [], {
      containerId: config.containerId,
      formId: config.formId,
      fieldsId: config.fieldsId,
      type: config.type,
      iconClass: config.iconClass,
      onIconClick: config.onIconClick,
      onReadmeClick: config.onReadmeClick,
    });
    setupSettingsEvents(context, config.formId, config.endpoint || '/settings', config.type);
  }, ERROR_MESSAGES.RENDER_FAILED('settings form'));
}

/**
 * Renders settings based on the provided configuration (legacy, prefer renderSettingsForm).
 * @param {string} context - The context or module name.
 * @param {Object} config - Settings configuration object.
 * @returns {Promise<void>}
 */
export async function renderSettings(context, config) {
  log(context, `Rendering settings for type: ${config.type} (legacy)`);
  await renderSettingsForm(context, config);
}

/**
 * Initializes the settings-renderer module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} SettingsRenderer instance with public methods.
 */
export function initializeSettingsRendererModule(registry) {
  return createModuleInitializer('settings-renderer.js', {
    renderSettings,
    renderSettingsForm,
  });
}

// Initialize module with lifecycle logging
const context = 'settings-renderer.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/settings-ui.js
// /static/js/utils/settings-ui.js
// Purpose: Provides low-level utilities for rendering settings fields and UI components.

import { log } from '../core/logger.js';
import { createLinkIcons } from './ui-components.js';
import { setupSettingsEvents } from './settings-events.js';
import { withElement } from './dom-manipulation.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/messages.js';
import { withScriptLogging } from './logging-utils.js';

/**
 * Renders settings fields based on the provided settings and configuration.
 * @param {string} context - The context or module name.
 * @param {Array} settings - Array of settings data.
 * @param {Object} config - Configuration object for rendering.
 * @returns {Promise<void>}
 */
export async function renderSettingsFields(context, settings, config) {
  log(context, `Rendering settings fields for type: ${config.type}`);
  await withErrorHandling(`${context}:renderSettingsFields`, async () => {
    await withElement(context, config.containerId, async container => {
      await withElement(context, config.fieldsId, async fieldsContainer => {
        await withElement(context, config.formId, async form => {
          container.innerHTML = '';
          fieldsContainer.innerHTML = '';

          // Ensure settings is an array
          const validSettings = Array.isArray(settings) ? settings : [];
          const linkIcons = createLinkIcons(context, validSettings, config.type, config.onReadmeClick, config.onIconClick);
          
          // Only append if linkIcons is an array
          if (Array.isArray(linkIcons)) {
            container.append(...linkIcons);
          } else {
            log(context, 'No link icons to append; settings may be empty or invalid');
          }

          if (validSettings.length > 0 && validSettings[0].fields) {
            fieldsContainer.innerHTML = validSettings[0].fields
              .map(field => `
                <div>
                  <label for="${field.name}">${field.label || field.name}</label>
                  <input type="${field.type || 'text'}" name="${field.name}" value="${field.value || ''}">
                </div>
              `)
              .join('');
            if (config.onIconClick) {
              config.onIconClick(validSettings[0], fieldsContainer, form);
            }
          } else {
            fieldsContainer.innerHTML = '<p>No settings available for this type.</p>';
            log(context, `No settings data available for type: ${config.type}`);
          }

          setupSettingsEvents(context, config.formId, config.endpoint || '/settings', config.type);
        });
      });
    });
  }, ERROR_MESSAGES.RENDER_FAILED('settings fields'));
}

/**
 * Initializes the settings-ui module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} SettingsUi instance with public methods.
 */
export function initializeSettingsUiModule(registry) {
  const context = 'settings-ui.js';
  log(context, 'Initializing settings-ui module for module registry');
  return {
    renderSettingsFields: (ctx, ...args) => renderSettingsFields(ctx, ...args),
  };
}

// Initialize module with lifecycle logging
const context = 'settings-ui.js';
withScriptLogging(context, () => {
  log(context, 'Module initialized');
});
utils/ui-components.js
// /static/js/utils/ui-components.js
// Purpose: Provides utilities for rendering reusable UI components.

import { log, error as logError } from '../core/logger.js';
import { withErrorHandling } from './error.js';
import { ERROR_MESSAGES } from '../config/constants.js';
import { withScriptLogging } from './logging-utils.js';

/**
 * Renders a data table into a DOM element.
 * @param {string} context - The context or module name.
 * @param {Object} config - Table configuration object.
 * @param {Array} config.data - The data to render.
 * @param {Array<string>} config.headers - The table headers.
 * @param {Function} config.rowMapper - Asynchronous function to map data items to an array of cell contents (strings or DOM elements).
 * @param {string} config.emptyMessage - Message to display if no data is available.
 * @returns {Promise<HTMLElement>} The rendered <tbody> element.
 */
export async function renderDataTable(context, { data, headers, rowMapper, emptyMessage }) {
    log(context, 'Rendering data table with data:', data);
    return await withErrorHandling(`${context}:renderDataTable`, async () => {
        const tbody = document.createElement('tbody');
        if (!Array.isArray(data) || data.length === 0) {
            log(context, 'No data provided or data is not an array');
            const tr = document.createElement('tr');
            const td = document.createElement('td');
            td.colSpan = headers.length;
            td.textContent = emptyMessage || 'No data available';
            tr.appendChild(td);
            tbody.appendChild(tr);
            return tbody;
        }
        for (const item of data) {
            try {
                const cells = await rowMapper(item);
                if (!Array.isArray(cells)) {
                    logError(context, `Row mapper did not return an array for item:`, item);
                    continue;
                }
                if (cells.length !== headers.length) {
                    logError(context, `Cell count mismatch: expected ${headers.length}, got ${cells.length} for item:`, item);
                    continue;
                }
                const tr = document.createElement('tr');
                cells.forEach(cell => {
                    const td = document.createElement('td');
                    if (typeof cell === 'string') {
                        td.textContent = cell;
                    } else if (cell instanceof HTMLElement) {
                        td.appendChild(cell);
                    } else {
                        td.textContent = String(cell);
                    }
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            } catch (err) {
                logError(context, `Error mapping row for item: ${JSON.stringify(item)}, error: ${err.message}`);
                continue;
            }
        }
        if (tbody.children.length === 0) {
            log(context, 'No valid rows rendered, showing empty message');
            const tr = document.createElement('tr');
            const td = document.createElement('td');
            td.colSpan = headers.length;
            td.textContent = emptyMessage || 'No data available';
            tr.appendChild(td);
            tbody.appendChild(tr);
        }
        log(context, 'Table body rendered:', tbody.outerHTML); // Debug log
        return tbody;
    }, ERROR_MESSAGES.RENDER_FAILED('data table data'));
}

/**
 * Renders a checkbox list into an HTML element.
 * @param {string} context - The context or module name.
 * @param {Object} config - Checkbox list configuration object.
 * @param {Array} config.items - Array of items to render as checkboxes.
 * @param {string} config.name - Name attribute for the checkboxes.
 * @param {Array} config.selected - Array of selected values.
 * @param {Object} config.dataAttributes - Data attributes to add to each checkbox.
 * @param {string} config.containerClass - CSS class for the container.
 * @returns {Promise<HTMLElement>} The container element with the checkbox list.
 */
export async function renderCheckboxList(context, { items, name, selected, dataAttributes, containerClass }) {
    log(context, `Rendering checkbox list for: ${name}`);
    return await withErrorHandling(`${context}:renderCheckboxList`, async () => {
        const container = document.createElement('div');
        container.className = containerClass || '';

        items.forEach(item => {
            const { value, label } = typeof item === 'string' ? { value: item, label: item } : item;
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.name = name;
            checkbox.value = value;
            checkbox.checked = selected.includes(value);

            if (dataAttributes) {
                Object.entries(dataAttributes).forEach(([key, val]) => {
                    checkbox.setAttribute(`data-${key}`, val);
                });
            }

            const labelElement = document.createElement('label');
            labelElement.style.marginRight = '10px';
            labelElement.appendChild(checkbox);
            labelElement.appendChild(document.createTextNode(` ${label}`));

            container.appendChild(labelElement);
        });

        return container;
    }, ERROR_MESSAGES.RENDER_FAILED('checkbox list data'));
}

/**
 * Renders a modal dialog.
 * @param {string} context - The context or module name.
 * @param {Object} config - Modal configuration object.
 * @param {string} config.id - The ID for the modal.
 * @param {string} config.title - The modal title.
 * @param {string|HTMLElement} config.content - The modal content (HTML string or HTMLElement).
 * @param {string} config.formId - The ID for the form inside the modal.
 * @param {Array} config.buttons - Array of button configurations.
 * @returns {Promise<HTMLElement>} The modal element.
 */
export async function renderModal(context, { id, title, content, formId, buttons }) {
    log(context, `Rendering modal: ${id}`);
    return await withErrorHandling(`${context}:renderModal`, async () => {
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.id = id;

        const modalContent = document.createElement('div');
        modalContent.className = 'modal-content';

        const modalHeader = document.createElement('div');
        modalHeader.className = 'modal-header';
        const modalTitle = document.createElement('h2');
        modalTitle.textContent = title;
        const closeButton = document.createElement('span');
        closeButton.className = 'close';
        closeButton.innerHTML = '×';
        closeButton.onclick = () => modal.remove();
        modalHeader.appendChild(modalTitle);
        modalHeader.appendChild(closeButton);

        const modalBody = document.createElement('div');
        modalBody.className = 'modal-body';
        const form = document.createElement('form');
        form.id = formId;
        if (typeof content === 'string') {
            form.innerHTML = content;
        } else if (content instanceof HTMLElement) {
            form.appendChild(content);
        } else {
            form.textContent = 'Invalid content provided';
        }
        modalBody.appendChild(form);

        const modalFooter = document.createElement('div');
        modalFooter.className = 'modal-footer';
        buttons.forEach(btn => {
            const button = document.createElement('button');
            button.type = btn.type || 'button';
            button.className = btn.className || '';
            button.textContent = btn.text;
            if (btn.onclick) button.onclick = btn.onclick;
            modalFooter.appendChild(button);
        });

        modalContent.appendChild(modalHeader);
        modalContent.appendChild(modalBody);
        modalContent.appendChild(modalFooter);
        modal.appendChild(modalContent);

        document.body.appendChild(modal);
        modal.style.display = 'block';

        return modal;
    }, ERROR_MESSAGES.RENDER_FAILED('modal'));
}

/**
 * Creates link icons for settings or navigation.
 * @param {string} context - The context or module name.
 * @param {Array} settings - Array of settings objects with key_type and doc_link.
 * @param {string} type - The type of settings (e.g., 'api', 'affiliate').
 * @param {Function} onReadmeClick - Callback for readme link clicks.
 * @param {Function} onIconClick - Callback for icon clicks.
 * @returns {HTMLElement[]} Array of icon elements.
 */
export function createLinkIcons(context, settings, type, onReadmeClick, onIconClick) {
    log(context, `Creating link icons for type: ${type}`);
    return withErrorHandling(`${context}:createLinkIcons`, () => {
        if (!Array.isArray(settings)) {
            logError(context, 'Settings must be an array');
            return [];
        }

        const icons = [];
        settings.forEach(setting => {
            if (!setting.key_type) return;

            const icon = document.createElement('i');
            icon.className = setting.icon || `fas fa-${type}`;
            icon.dataset.keyType = setting.key_type;
            icon.addEventListener('click', () => onIconClick?.(setting));
            icons.push(icon);

            const readmeLink = setting.doc_link?.find(link => link.title === 'readme');
            if (readmeLink) {
                const readmeIcon = document.createElement('i');
                readmeIcon.className = 'fas fa-book';
                readmeIcon.dataset.keyType = setting.key_type;
                readmeIcon.addEventListener('click', () => onReadmeClick?.(setting));
                icons.push(readmeIcon);
            }
        });

        return icons;
    }, ERROR_MESSAGES.RENDER_FAILED('link icons'));
}

/**
 * Initializes the ui-components module for use with the module registry.
 * @param {Object} registry - The module registry instance.
 * @returns {Object} UiComponents instance with public methods.
 */
export function initializeUiComponentsModule(registry) {
    const context = 'ui-components.js';
    log(context, 'Initializing ui-components module for module registry');
    return {
        renderDataTable: (ctx, ...args) => renderDataTable(ctx, ...args),
        renderCheckboxList: (ctx, ...args) => renderCheckboxList(ctx, ...args),
        renderModal: (ctx, ...args) => renderModal(ctx, ...args),
        createLinkIcons: (ctx, ...args) => createLinkIcons(ctx, ...args),
    };
}

// Initialize module with lifecycle logging
const context = 'ui-components.js';
withScriptLogging(context, () => {
    log(context, 'Module initialized');
});

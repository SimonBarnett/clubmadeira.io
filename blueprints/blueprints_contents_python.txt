+ [blueprints]
+----__init__.py
+----authentication_bp.py
+----content_bp.py
+----manager_bp.py
+----referral_bp.py
+----site_request_bp.py
+----user_settings_bp.py
+----utility_bp.py

authentication_bp.py
from flask import Blueprint, render_template, request, jsonify, current_app, session, redirect, url_for
from utils.auth import login_required, load_users_settings, save_users_settings, generate_token, decode_token, login_user, generate_code
from utils.config import load_config
import logging
import datetime
import json
import bcrypt
import jwt
import hashlib
import random
import string
import requests
import stripe
from blueprints.referral_bp import posthog_client

# Blueprint Setup
authentication_bp = Blueprint('authentication_bp', __name__)

# /signup POST - Handle User Signup
@authentication_bp.route('/signup', methods=['POST'])
def signup():
    try:
        request_data = {
            "method": request.method,
            "url": request.full_path,
            "headers": dict(request.headers),
            "ip": request.remote_addr,
            "body": request.get_json(silent=True) or "[NO BODY]"
        }
        log_data = request_data.copy()
        if "Authorization" in log_data["headers"]:
            log_data["headers"]["Authorization"] = "[REDACTED]"
        logging.debug(f"Request: {json.dumps(log_data)}")

        data = request_data["body"]
        if not data or 'signup_type' not in data:
            logging.warning("Signup attempt missing signup_type")
            return jsonify({"status": "error", "message": "Signup type is required"}), 400

        signup_type = data.get("signup_type").lower()
        valid_signup_types = ['community', 'seller', 'partner']
        if signup_type not in valid_signup_types:
            logging.warning(f"Invalid signup_type: {signup_type}")
            return jsonify({"status": "error", "message": "Invalid signup type"}), 400

        site_settings = load_config()
        stripe.api_key = site_settings.get('stripe', {}).get('API_KEY')

        # Determine business type based on role
        business_type = 'individual' if signup_type in ['community', 'partner'] else 'company'

        # Create Stripe account for the new user
        account = stripe.Account.create(
            type='express',
            business_type=business_type,
            capabilities={'transfers': {'requested': True}}
        )

        # Create Stripe account link with return URL including role and section
        return_url = f"https://clubmadeira.io/?section=completeSignup&role={signup_type}&account_id={account.id}"
        account_link = stripe.AccountLink.create(
            account=account.id,
            refresh_url='https://clubmadeira.io/?section=failSignup',
            return_url=return_url,
            type='account_onboarding'
        )

        logging.info(f"Stripe account created for {signup_type}, account_link: {account_link.url}")
        return jsonify({
            "status": "success",
            "signup_type": signup_type,
            "account_link": account_link.url
        }), 200

    except stripe.error.StripeError as e:
        logging.error(f"Stripe error during signup: {str(e)}")
        return jsonify({"status": "error", "message": f"Stripe error: {str(e)}"}), 400
    except Exception as e:
        logging.error(f"Signup error: {str(e)}", exc_info=True)
        return jsonify({"status": "error", "message": "Server error"}), 500

# /complete-signup POST - Complete Signup After Stripe
@authentication_bp.route('/complete-signup', methods=['POST'])
def complete_signup():
    """Handle password setup after Stripe onboarding to complete user account creation."""
    try:
        # Load the configuration
        config = load_config()
        
        # Check if Stripe API key exists in the config
        if "stripe" not in config or "API_KEY" not in config["stripe"]:
            logging.error("Stripe API key not found in config")
            return jsonify({"status": "error", "message": "Server configuration error"}), 500
        
        # Set the Stripe API key
        stripe.api_key = config["stripe"]["API_KEY"]

        # Attempt to parse JSON, fall back to form data if not JSON
        data = request.get_json(silent=True) or request.form.to_dict()
        logging.debug(f"Received data: {data}")

        # Check if data is empty or missing required fields
        if not data or 'password' not in data or 'stripe_account_id' not in data or 'role' not in data:
            logging.warning("Missing required fields in complete-signup request")
            return jsonify({"status": "error", "message": "Password, stripe_account_id, and role are required"}), 400

        password = data['password'].strip()
        stripe_account_id = data['stripe_account_id']
        role = data['role']

        if not password:
            return jsonify({"status": "error", "message": "Password cannot be empty"}), 400

        # Fetch Stripe account details
        try:
            stripe_account = stripe.Account.retrieve(stripe_account_id)
        except stripe.error.StripeError as e:
            logging.error(f"Stripe error: {str(e)}")
            return jsonify({"status": "error", "message": "Failed to retrieve Stripe account"}), 400

        # Generate a permanent user ID using generate_code from utils.auth
        user_id = generate_code()

        # Determine email: Use Stripe email if available, else form email, else default
        email_from_stripe = stripe_account.email
        email_from_form = data.get('email', '').strip()
        email = email_from_stripe if email_from_stripe is not None else (email_from_form if email_from_form else f"{user_id}@example.com")

        # Hash the password
        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')

        # Prepare user data
        user_data = {
            'email_address': email,
            'permissions': [role, 'validated'],
            'password': hashed_password,
            'stripe_account_id': stripe_account_id,
            'role': role
        }

        # Add role-specific data from Stripe onboarding or form
        if role == 'community':
            individual = stripe_account.individual if stripe_account.individual else {}
            phone_from_stripe = individual.get('phone') if stripe_account.individual else None
            phone_from_form = data.get('phone', '').strip()
            phone_number = phone_from_stripe if phone_from_stripe is not None else (phone_from_form if phone_from_form else None)
            user_data.update({
                'first_name': individual.get('first_name') if stripe_account.individual else None,
                'last_name': individual.get('last_name') if stripe_account.individual else None,
                'phone_number': phone_number,
                'dob': individual.get('dob') if stripe_account.individual else None,
                'address': individual.get('address') if stripe_account.individual else None,
                'ssn_last_4': individual.get('ssn_last_4') if stripe_account.individual else None,
            })
        elif role == 'seller':
            company = stripe_account.company if stripe_account.company else {}
            phone_from_stripe = company.get('phone') if stripe_account.company else None
            phone_from_form = data.get('phone', '').strip()
            phone_number = phone_from_stripe if phone_from_stripe is not None else (phone_from_form if phone_from_form else None)
            user_data.update({
                'company_name': company.get('name') if stripe_account.company else None,
                'phone_number': phone_number,
                'tax_id': company.get('tax_id') if stripe_account.company else None,
                'address': company.get('address') if stripe_account.company else None,
            })

        # Save the user to user_settings
        users_settings = load_users_settings()
        users_settings[user_id] = user_data
        save_users_settings(users_settings)
        logging.info(f"User {user_id} created successfully after Stripe onboarding")

        # Record signup event in PostHog
        signup_data = {
            "user_id": user_id,
            "role": role,
            "timestamp": datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")
        }
        if posthog_client:
            try:
                posthog_client.capture(
                    distinct_id=user_id,
                    event="signup",
                    properties=signup_data
                )
                logging.debug(f"PostHog signup event captured: distinct_id={user_id}, properties={json.dumps(signup_data)}")
            except Exception as e:
                logging.error(f"PostHog Issue - Failed to capture signup event: {str(e)}", exc_info=True)
        else:
            logging.warning("PostHog Issue - posthog_client is None, signup event not captured")

        # Generate a token using generate_token from utils.auth
        token = generate_token(user_id, user_data['permissions'])
        session['user'] = {
            'user_id': user_id,
            'permissions': user_data['permissions'],
            'token': token,
            'x-role': role
        }
        session.modified = True

        # Prepare response
        response = jsonify({
            "status": "success",
            "message": "Account created successfully",
            "token": token,
            "user_id": user_id,
            "redirect": "/"
        })
        response.set_cookie('authToken', token, secure=True, max_age=604800, path='/')
        return response, 200

    except Exception as e:
        logging.error(f"Complete signup error: {str(e)}", exc_info=True)
        return jsonify({"status": "error", "message": "Server error"}), 500
        
# /link-stripe POST - Link Stripe Account for Partner/Admin
@authentication_bp.route('/link-stripe', methods=['POST'])
@login_required(['partner', 'admin'])
def link_stripe():
    try:
        site_settings = load_config()
        stripe.api_key = site_settings.get('stripe', {}).get('API_KEY')
        user_id = request.user_id
        users_settings = load_users_settings()
        user = users_settings.get(user_id)
        if not user:
            logging.warning(f"User not found: {user_id}")
            return jsonify({"status": "error", "message": "User not found"}), 404

        if user.get('stripe_account_id'):
            logging.warning(f"User {user_id} already has Stripe account")
            return jsonify({"status": "error", "message": "Stripe account already linked"}), 400

        # Create Stripe account for linking
        account = stripe.Account.create(
            type='express',
            business_type='individual',
            capabilities={'transfers': {'requested': True}}
        )
        account_link = stripe.AccountLink.create(
            account=account.id,
            refresh_url='https://clubmadeira.io/refresh',
            return_url='https://clubmadeira.io/stripe-return',
            type='account_onboarding'
        )
        user['stripe_account_id'] = account.id
        save_users_settings(users_settings)
        logging.info(f"Stripe account linked for user {user_id}")
        return jsonify({"status": "success", "account_link": account_link.url, "redirect": "/"}), 200

    except stripe.error.StripeError as e:
        logging.error(f"Stripe error: {str(e)}")
        return jsonify({"status": "error", "message": f"Stripe error: {str(e)}"}), 400
    except Exception as e:
        logging.error(f"Link Stripe error: {str(e)}", exc_info=True)
        return jsonify({"status": "error", "message": "Server error"}), 500

# /reset-password POST - Initiate Password Reset
@authentication_bp.route('/reset-password', methods=['POST'])
def reset_password():
    try:
        site_settings = load_config()
        request_data = {
            "method": request.method,
            "url": request.full_path,
            "headers": dict(request.headers),
            "ip": request.remote_addr,
            "body": request.get_json(silent=True) or "[NO BODY]"
        }
        log_data = request_data.copy()
        if "Authorization" in log_data["headers"]:
            log_data["headers"]["Authorization"] = "[REDACTED]"
        logging.debug(f"Request: {json.dumps(log_data)}")

        data = request_data["body"]
        if not data or 'email' not in data:
            logging.warning("Reset password attempt missing email")
            return jsonify({"status": "error", "message": "Email is required"}), 400
        
        email = data.get("email").lower()
        users_settings = load_users_settings()
        matching_user_id = next((uid for uid, settings in users_settings.items() if settings.get("email_address", "").lower() == email), None)
        
        if not matching_user_id:
            logging.warning(f"Reset password failed - Email not found: {email}")
            return jsonify({"status": "error", "message": "Email not found"}), 404

        otp = ''.join(random.choices(string.digits, k=4))
        otp_hash = hashlib.sha256(otp.encode()).hexdigest()
        otp_token = jwt.encode({
            'email': email,
            'otp_hash': otp_hash,
            'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=15)
        }, site_settings.get('jwt', {}).get('SECRET_KEY'), algorithm='HS256')

        try:
            send_otp_via_sms(users_settings[matching_user_id]['phone_number'], otp)
        except Exception as e:
            logging.error(f"Failed to send OTP: {str(e)}")
            return jsonify({"status": "error", "message": f"Failed to send SMS: {str(e)}"}), 500

        logging.info(f"OTP generated and token created for user {matching_user_id}")
        return jsonify({"status": "success", "message": "OTP sent successfully", "otp_token": otp_token}), 200
    except Exception as e:
        logging.error(f"Reset password error: {str(e)}", exc_info=True)
        return jsonify({"status": "error", "message": "Server error"}), 500

def send_otp_via_sms(phone_number, otp):
    """
    Sends an OTP via SMS to the specified phone number using TextMagic's API.

    Args:
        phone_number (str): The recipient's phone number (without leading 0, e.g., '7989389179').
        otp (str): The one-time password to send.

    Raises:
        Exception: If TextMagic credentials are not configured or if the SMS fails to send.
    """
    try:
        site_settings = load_config()
        username = site_settings.get('textmagic', {}).get('USERNAME')
        api_key = site_settings.get('textmagic', {}).get('API_KEY')

        if not username or not api_key:
            logging.error("TextMagic credentials not configured")
            raise Exception("TextMagic credentials not configured")

        message = f"Your OTP for clubmadeira.io is {otp}"
        url = "https://rest.textmagic.com/api/v2/messages"
        payload = {"text": message, "phones": f"+44{phone_number}"}
        headers = {
            "X-TM-Username": username,
            "X-TM-Key": api_key,
            "Content-Type": "application/x-www-form-urlencoded"
        }

        logging.info(f"Sending OTP {otp} to +44{phone_number} via SMS")
        response = requests.post(url, data=payload, headers=headers)
        
        if response.status_code != 201:
            logging.error(f"Failed to send SMS to +44{phone_number}: {response.text}")
            raise Exception(f"Failed to send SMS: {response.text}")

        logging.info(f"SMS sent successfully to +44{phone_number}")
    except requests.exceptions.RequestException as e:
        logging.error(f"Error sending SMS to +44{phone_number}: {str(e)}")
        raise Exception(f"Error sending SMS: {str(e)}")
    except Exception as e:
        logging.error(f"Unexpected error sending SMS to +44{phone_number}: {str(e)}")
        raise

# /verify-reset-code POST - Verify OTP and Reset Password
@authentication_bp.route('/verify-reset-code', methods=['POST'])
def verify_reset_code():
    """
    Verify the OTP and reset the user's password.

    Expects JSON payload with email, otp, otp_token, and new_password.
    Updates the user's password in users_settings.json if OTP is valid.
    Returns a new authentication token on success.
    """
    try:
        site_settings = load_config()
        request_data = {
            "method": request.method,
            "url": request.full_path,
            "headers": dict(request.headers),
            "ip": request.remote_addr,
            "body": request.get_json(silent=True) or "[NO BODY]"
        }
        log_data = request_data.copy()
        if "Authorization" in log_data["headers"]:
            log_data["headers"]["Authorization"] = "[REDACTED]"
        if isinstance(log_data["body"], dict) and "new_password" in log_data["body"]:
            log_data["body"]["new_password"] = "[REDACTED]"
        logging.debug(f"Request: {json.dumps(log_data)}")

        data = request_data["body"]
        if not data or not all(k in data for k in ['email', 'otp', 'otp_token', 'new_password']):
            logging.warning(f"Verify reset code missing required fields: {json.dumps(data)}")
            return jsonify({"status": "error", "message": "Email, OTP, token, and new password are required"}), 400
        
        email = data.get("email").lower()
        otp = data.get("otp")
        otp_token = data.get("otp_token")
        new_password = data.get("new_password").strip()

        # Decode and validate the OTP token
        try:
            payload = jwt.decode(otp_token, site_settings.get('jwt', {}).get('SECRET_KEY'), algorithms=['HS256'])
            if payload['email'] != email:
                logging.warning(f"Email mismatch: provided {email}, stored {payload['email']}")
                return jsonify({"status": "error", "message": "Email mismatch"}), 400
            stored_otp_hash = payload['otp_hash']
        except jwt.ExpiredSignatureError:
            logging.warning("Token expired")
            return jsonify({"status": "error", "message": "Token expired"}), 400
        except jwt.InvalidTokenError:
            logging.warning("Invalid token")
            return jsonify({"status": "error", "message": "Invalid token"}), 400

        # Verify OTP with consistent encoding
        entered_otp_hash = hashlib.sha256(otp.encode('utf-8')).hexdigest()
        if entered_otp_hash != stored_otp_hash:
            logging.warning("Invalid OTP")
            return jsonify({"status": "error", "message": "Invalid OTP"}), 400

        # Load user settings and find the user
        users_settings = load_users_settings()
        matching_user_id = next((uid for uid, settings in users_settings.items() if settings.get("email_address", "").lower() == email), None)
        if not matching_user_id:
            logging.warning(f"User not found for email: {email}")
            return jsonify({"status": "error", "message": "User not found"}), 404

        user = users_settings[matching_user_id]
        
        # Hash the new password with consistent encoding
        hashed_password = bcrypt.hashpw(new_password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        user["password"] = hashed_password
        
        # Add 'verified' permission if not present
        if "verified" not in user.get("permissions", []):
            user["permissions"].append("verified")
        
        # Save the updated settings with error handling
        try:
            save_users_settings(users_settings)
            logging.info(f"Password reset successful for user {matching_user_id}")
        except Exception as save_error:
            logging.error(f"Failed to save updated password for user {matching_user_id}: {str(save_error)}")
            return jsonify({"status": "error", "message": "Failed to save new password. Please try again."}), 500

        # Generate a new token
        permissions = user['permissions']
        x_role = 'admin' if 'admin' in permissions else next((r for r in ['merchant', 'community', 'partner'] if r in permissions), 'user')
        token = generate_token(matching_user_id, permissions, x_role=x_role)
        session['user'] = {
            'user_id': matching_user_id,
            'permissions': permissions,
            'token': token,
            'x-role': x_role
        }
        session.modified = True
        
        # Prepare and return the response
        response = jsonify({
            "status": "success",
            "message": "Password reset successful",
            "token": token,
            "x-role": x_role,
            "user_id": matching_user_id,
            "redirect": "/"
        })
        response.set_cookie('authToken', token, secure=True, max_age=604800, path='/')
        return response, 200

    except Exception as e:
        logging.error(f"Verify reset code error: {str(e)}", exc_info=True)
        return jsonify({"status": "error", "message": "Server error"}), 500
    
# /update-password POST - Update Existing Password
@authentication_bp.route('/update-password', methods=['POST'])
@login_required(["self"], require_all=True)
def update_password():
    try:
        request_data = {
            "method": request.method,
            "url": request.full_path,
            "headers": dict(request.headers),
            "ip": request.remote_addr,
            "body": request.get_json(silent=True) or "[NO BODY]"
        }
        log_data = request_data.copy()
        if "Authorization" in log_data["headers"]:
            log_data["headers"]["Authorization"] = "[REDACTED]"
        if isinstance(log_data["body"], dict) and "new_password" in log_data["body"]:
            log_data["body"]["new_password"] = "[REDACTED]"
        logging.debug(f"Request: {json.dumps(log_data)}")

        data = request_data["body"]
        if not data or 'current_password' not in data or 'new_password' not in data:
            logging.warning("Update password attempt missing current_password or new_password")
            return jsonify({"status": "error", "message": "Current password and new password are required"}), 400

        current_password = data["current_password"].strip()
        new_password = data["new_password"].strip()

        users_settings = load_users_settings()
        user_id = request.user_id
        user = users_settings.get(user_id)
        if not user:
            logging.warning(f"User {user_id} not found")
            return jsonify({"status": "error", "message": "User not found"}), 404

        if not bcrypt.checkpw(current_password.encode('utf-8'), user["password"].encode('utf-8')):
            logging.warning(f"Current password incorrect for user {user_id}")
            return jsonify({"status": "error", "message": "Current password is incorrect"}), 403

        hashed_password = bcrypt.hashpw(new_password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        users_settings[user_id]["password"] = hashed_password
        save_users_settings(users_settings)
        logging.info(f"Password updated for user {user_id}")
        return jsonify({"status": "success", "message": "Password updated successfully", "redirect": "/"}), 200
    except Exception as e:
        logging.error(f"Update password error: {str(e)}", exc_info=True)
        return jsonify({"status": "error", "message": "Server error"}), 500

@authentication_bp.route('/debug-password/<user_id>', methods=['GET', 'POST'])
def debug_password(user_id):
    """
    Temporary route to debug password hash issues.
    - GET: Check if a provided password matches the stored hash.
    - POST: Update the password hash with a new password.
    """
    users_settings = load_users_settings()
    user = users_settings.get(user_id)
    if not user:
        return jsonify({"status": "error", "message": "User not found"}), 404

    if request.method == 'GET':
        password = request.args.get('password')
        if not password:
            return jsonify({"status": "error", "message": "Password parameter required"}), 400

        # Check if the password matches the stored hash
        if bcrypt.checkpw(password.encode('utf-8'), user['password'].encode('utf-8')):
            return jsonify({"status": "success", "message": "Password matches"})
        else:
            return jsonify({"status": "error", "message": "Password does not match"})

    elif request.method == 'POST':
        new_password = request.json.get('new_password')
        if not new_password:
            return jsonify({"status": "error", "message": "New password required"}), 400

        # Hash and update the password
        hashed_password = bcrypt.hashpw(new_password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        user['password'] = hashed_password
        try:
            save_users_settings(users_settings)
            return jsonify({"status": "success", "message": "Password updated"})
        except Exception as e:
            return jsonify({"status": "error", "message": f"Failed to save: {str(e)}"}), 500
content_bp.py
from flask import Blueprint, request, jsonify, session
import requests
import json
import logging
from utils.config import load_config  # Import from utils/config.py
from utils.users import load_users_settings, save_users_settings, get_user_settings  # Import from utils/users.py
from jsonschema import validate, ValidationError
from utils.products import search_all_discounted
from utils.auth import login_required

# region Blueprint Setup
# Welcome to content_bp, the blueprint that’s more organized than the Spanish Inquisition’s filing system.
# Arthur Dent would be proud—simple, logical, and occasionally bewildered by its own existence.
content_bp = Blueprint('content_bp', __name__)
# endregion

# Load configuration
config = load_config()

# xAI API configuration
XAI_API_URL = "https://api.x.ai/v1/chat/completions"
XAI_API_KEY = config["grok"]["API_KEY"]

# Load JSON schema for categories
with open("schemas/categories.json", "r") as f:
    CATEGORY_SCHEMA = json.load(f)

# Clean Grok's response to remove markdown formatting
def clean_response(response_text: str) -> str:
    """Remove backticks and code block markers from the response."""
    cleaned = response_text.strip()
    if cleaned.startswith("```json"):
        cleaned = cleaned[7:].strip()
    elif cleaned.startswith("```"):
        cleaned = cleaned[3:].strip()
    if cleaned.endswith("```"):
        cleaned = cleaned[:-3].strip()
    if cleaned.startswith('"') and cleaned.endswith('"'):
        cleaned = cleaned[1:-1].replace('\\"', '"')
    return cleaned

# Helper function to call xAI API
def call_xai_api(messages, deselected_categories):
    try:
        # No need to import app; current_app is available in request context
        headers = {
            'Authorization': f'Bearer {current_app.config["GROK_API_KEY"]}',
            'Content-Type': 'application/json'
        }
        payload = {
            'model': 'grok-2-1212',
            'messages': messages,
            'temperature': 0.7,
            'max_tokens': 1000
        }
        logging.debug(f"Sending request to xAI API: {json.dumps(payload, indent=2)}")
        response = requests.post('https://api.x.ai/v1/chat/completions', headers=headers, json=payload)
        response.raise_for_status()
        response_data = response.json()
        logging.debug(f"xAI API raw response: {json.dumps(response_data, indent=2)}")

        content = response_data['choices'][0]['message']['content']
        content = content.strip()
        if content.startswith('```json') and content.endswith('```'):
            content = content[7:-3].strip()
        elif content.startswith('```') and content.endswith('```'):
            content = content[3:-3].strip()

        parsed_content = json.loads(content)
        validate(instance=parsed_content, schema=CATEGORY_SCHEMA)
        logging.debug(f"Cleaned xAI API response: {json.dumps(parsed_content)}")
        return parsed_content
    except ValidationError as ve:
        logging.error(f"Failed to validate xAI API response: {str(ve)}")
        return None
    except Exception as e:
        logging.error(f"Failed to process xAI API response: {str(e)}")
        return None


# region /deals GET - The Quest for Bargain Treasures
@content_bp.route('/deals', methods=['GET'])
def get_all_discounted_products():
    """
    Retrieves all discounted products for a given category, like Zaphod Beeblebrox hunting for the best Pan Galactic Gargle Blaster deals.
    Purpose: To provide a list of products that are currently on discount, filtered by category—like the Holy Grail, but with price tags.
    Inputs: Query parameter:
        - category_id (str): The ID of the category to filter discounted products. Required, or it’s like asking for "four candles" and getting fork handles.
    Outputs:
        - Success: JSON {"status": "success", "count": <int>, "products": [<product_data>]}, status 200—your treasure map to savings!
        - Errors:
            - 400: {"status": "error", "message": "category_id required"}—you forgot the category, you naughty boy!
            - 500: {"status": "error", "message": "Server error: <reason>"}—the system’s gone to the People’s Front of Judea!
    """
    try:
        category_id = request.args.get('category_id')
        if not category_id:
            logging.warning("UX Issue - No category_id provided for discounted products")
            return jsonify({"status": "error", "message": "category_id required"}), 400
        
        products = search_all_discounted(category_id)
        if not products:
            logging.warning(f"UX Issue - No discounted products found for category_id: {category_id}")
        
        response_data = {"status": "success", "count": len(products), "products": products}
        logging.debug(f"Retrieved discounted products for category_id {category_id}: {json.dumps(response_data)}")
        return jsonify(response_data), 200
    except Exception as e:
        logging.error(f"UX Issue - Failed to retrieve discounted products: {str(e)}", exc_info=True)
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500
# endregion

# ASCII Art 1: The Holy Grail
r"""
       /\
      /  \
     /____\  "It's just a flesh wound! Keep searching for those discounts!"
    |      |
    |______|
"""

# region /categories GET/POST - Grok-Powered Discount Category Generator
@content_bp.route('/categories', methods=['GET', 'POST'])
@login_required(required_permissions=["self"], require_all=True)
def categories():
    error_message = None
    categories = None
    prompt = ""
    selected = []
    deselected = []
    cumulative_deselected = []

    try:
        user_id = request.user_id
        user_settings = get_user_settings(user_id)
        saved_data = user_settings.get("categories", {})

        if request.method == "POST":
            prompt = request.form.get("prompt", "").strip()
            selected = request.form.getlist("selected")
            deselected = json.loads(request.form.get("deselected", "[]"))
            previous_deselected = json.loads(request.form.get("previous_deselected", "[]"))

            if not prompt:
                error_message = "Prompt is required."
                logging.warning("UX Issue - No prompt provided for category generation")
            else:
                cumulative_deselected = list(set(deselected + previous_deselected))
                logging.debug(f"Cumulative deselections: {cumulative_deselected}")
                is_first_pass = not selected and not cumulative_deselected
                schema_instruction = (
                    f"Return the response as a JSON object conforming to this schema:\n{json.dumps(CATEGORY_SCHEMA, indent=2)}\n"
                    "The object should have 3-7 main categories, each with 3-7 subcategories. "
                    "Main categories and subcategories should contain only letters, numbers, spaces, and hyphens."
                )

                if is_first_pass:
                    messages = [
                        {
                            "role": "system",
                            "content": (
                                "You are an expert in e-commerce affiliate marketing with deep knowledge of club activities and interests. "
                                "Suggest 3-7 main discount categories (prefer 3-7) for a club’s discount page, each with 3-7 subcategories (prefer 3-7). "
                                "Categories MUST be directly tied to the club’s core activities, interests, or demographics as described in the prompt. "
                                "Focus on the most likely interests of the club members (e.g., for a scout group, prioritize categories like Camping Equipment, Outdoor Gear, Team Sports, and Scouting Skills over unrelated ones like Craft Supplies or Home Decor). "
                                "Do NOT include categories that are not directly related to the club’s activities, even if common in e-commerce. "
                                "Categories should be optimized for deals from Amazon UK, eBay UK, Awin, and CJ affiliate programs. "
                                f"Never include any categories or subcategories listed in the following deselected list: {cumulative_deselected}. "
                                f"{schema_instruction}"
                            )
                        },
                        {"role": "user", "content": prompt}
                    ]
                else:
                    messages = [
                        {
                            "role": "system",
                            "content": (
                                "Refine the previous category suggestions based on user feedback. Suggest 3-7 main categories "
                                "(prefer 3-7) with 3-7 subcategories each (prefer 3-7), optimized for Amazon UK, eBay UK, Awin, "
                                "and CJ affiliate deals. Categories MUST be directly tied to the club’s core activities, interests, or demographics "
                                "as described in the original prompt. Focus on the most likely interests of the club members "
                                "(e.g., for a scout group, prioritize categories like Camping Equipment, Outdoor Gear, Team Sports, and Scouting Skills). "
                                "Do NOT include categories that are not directly related to the club’s activities. "
                                "Maintain selected categories and subcategories where possible, and generate new categories to replace "
                                f"those in the deselected list. Never include any categories or subcategories listed in the following "
                                f"deselected list: {cumulative_deselected}. "
                                f"{schema_instruction}"
                            )
                        },
                        {
                            "role": "user",
                            "content": (
                                f"Original prompt: '{prompt}'. "
                                f"Selected: {selected}. Deselected: {cumulative_deselected}. "
                                f"Suggest refined categories."
                            )
                        }
                    ]

                logging.debug(f"Sending prompt to Grok: {json.dumps(messages, indent=2)}")
                categories = call_xai_api(messages, cumulative_deselected)
                if not categories:
                    error_message = "Failed to generate categories. Please try again."
                    logging.warning("UX Issue - No categories returned from Grok API")
                else:
                    selected = selected
                    logging.debug(f"Generated/refined categories for prompt '{prompt}': {json.dumps(categories)}")
        else:
            if saved_data:
                prompt = saved_data.get("prompt", "")
                selected = saved_data.get("selected", [])
                cumulative_deselected = saved_data.get("cumulative_deselected", [])
                categories = saved_data.get("categories", None)
                logging.debug(f"Loaded saved categories for user {user_id}: {json.dumps(categories)}")

        return jsonify({
            "status": "success" if not error_message else "error",
            "error_message": error_message,
            "categories": categories,
            "prompt": prompt,
            "selected": selected,
            "deselected": deselected,
            "previous_deselected": cumulative_deselected
        })
    except Exception as e:
        logging.error(f"Failed to process categories for user {user_id}: {str(e)}", exc_info=True)
        return jsonify({
            "status": "error",
            "error_message": f"An unexpected error occurred: {str(e)}",
            "categories": categories,
            "prompt": prompt,
            "selected": selected,
            "deselected": deselected,
            "previous_deselected": cumulative_deselected or []
        }), 500

# endregion

# region /categories/save POST - Save Categories
@content_bp.route('/api/categories/save', methods=['POST'])
@login_required(required_permissions=["self"], require_all=True)
def save_categories():
    try:
        user_id = request.user_id
        prompt = request.form.get("prompt", "").strip()
        selected = request.form.getlist("selected")
        deselected = json.loads(request.form.get("deselected", "[]"))
        previous_deselected = json.loads(request.form.get("previous_deselected", "[]"))
        categories = json.loads(request.form.get("categories", "{}"))

        user_settings = get_user_settings(user_id) or {}
        user_settings["categories"] = {
            "prompt": prompt,
            "selected": selected,
            "deselected": deselected,
            "cumulative_deselected": previous_deselected,
            "categories": categories
        }
        save_user_settings(user_id, user_settings)
        return jsonify({
            "status": "success",
            "error_message": null,
            "message": "Categories saved successfully."
        })
    except Exception as e:
        logging.error(f"Failed to save categories for user {user_id}: {str(e)}")
        return jsonify({
            "status": "error",
            "error_message": f"Failed to save categories: {str(e)}"
        }), 500


# endregion

# region /categories/reset POST - Reset Categories
@content_bp.route('/api/categories/reset', methods=['POST'])
@login_required(required_permissions=["self"], require_all=True)
def reset_categories():
    try:
        user_id = request.user_id
        user_settings = get_user_settings(user_id) or {}
        user_settings["categories"] = {}
        save_user_settings(user_id, user_settings)
        return jsonify({
            "status": "success",
            "error_message": null,
            "categories": {},
            "prompt": "",
            "selected": [],
            "deselected": [],
            "previous_deselected": [],
            "message": "Categories reset successfully."
        })
    except Exception as e:
        logging.error(f"Failed to reset categories for user {user_id}: {str(e)}")
        return jsonify({
            "status": "error",
            "error_message": f"Failed to reset categories: {str(e)}",
            "categories": {},
            "prompt": "",
            "selected": [],
            "deselected": [],
            "previous_deselected": []
        }), 500
# endregion

# ASCII Art 2: Zaphod Beeblebrox
r"""
       ______
      /|_||_\`.__
     (   _    _ _\
     =|  _    _  |  "Two heads are better than one—especially for finding bargains!"
      | (_)  (_) |
       \._|\'|\'_./
          |__|__| 
"""
manager_bp.py
from flask import Blueprint, request, jsonify
from utils.auth import login_required
from utils.users import load_users_settings, save_users_settings
from utils.config import load_config, save_config
import logging
import json
import requests

# Behold manager_bp, the blueprint that governs with the authority of Zaphod Beeblebrox’s dual-headed presidency!
# This is the control room—admin-only, like the bridge of the Heart of Gold, but with less improbability.
manager_bp = Blueprint('manager_bp', __name__)

# region Permission Management
@manager_bp.route('/permission', methods=['PATCH'])
@login_required(required_permissions=['admin'])
def patch_permission():
    """
    Add a permission for a user if it doesn't already exist.
    Payload: {"USERid": "string", "permission": "string"}
    """
    data = request.get_json()
    if not data or 'USERid' not in data or 'permission' not in data:
        return jsonify({"status": "error", "message": "USERid and permission are required"}), 400
    
    user_id = data['USERid']
    new_permission = data['permission']
    
    users_data = load_users_settings()
    user = users_data.get(user_id)
    
    if not user:
        return jsonify({"status": "error", "message": "User not found"}), 404
    
    if 'permissions' not in user:
        user['permissions'] = []
    
    if new_permission in user['permissions']:
        return jsonify({"status": "error", "message": f"Permission {new_permission} already exists for user {user_id}"}), 400
    
    user['permissions'].append(new_permission)
    save_users_settings(users_data)
    return jsonify({"status": "success", "message": f"Permission {new_permission} added for user {user_id}"}), 200

@manager_bp.route('/permission', methods=['DELETE'])
@login_required(required_permissions=['admin'])
def delete_permission():
    """
    Remove a specific permission from a user.
    Payload: {"USERid": "string", "permission": "string"}
    """
    data = request.get_json()
    if not data or 'USERid' not in data or 'permission' not in data:
        return jsonify({"status": "error", "message": "USERid and permission are required"}), 400
    
    user_id = data['USERid']
    permission_to_remove = data['permission']
    
    users_data = load_users_settings()
    user = users_data.get(user_id)
    
    if not user:
        return jsonify({"status": "error", "message": "User not found"}), 404
    
    if 'permissions' not in user or permission_to_remove not in user['permissions']:
        return jsonify({"status": "error", "message": f"Permission {permission_to_remove} not found for user {user_id}"}), 404
    
    user['permissions'].remove(permission_to_remove)
    save_users_settings(users_data)
    return jsonify({"status": "success", "message": f"Permission {permission_to_remove} removed from user {user_id}"}), 200
# endregion

# region Users by Role
@manager_bp.route('/users/<role>', methods=['GET'])
@login_required(required_permissions=['admin'])
def get_users_by_role(role):
    """
    Retrieves a list of users who have the specified role in their permissions.
    Purpose: Allows admins to view users based on their roles.
    Permissions: Restricted to "admin".
    Inputs: 
        - role (string): The role to filter users by (e.g., 'admin', 'partner').
    Outputs:
        - Success: JSON {"status": "success", "role": "<role>", "users": [<list_of_users>]}, status 200
        - Info: JSON {"status": "info", "message": "No users found with role '<role>'"}, status 200 if no users are found
        - Errors:
            - 500: {"status": "error", "message": "Server error: <reason>"}
    """
    try:
        users_data = load_users_settings()
        users_with_role = []
        for user_id, user in users_data.items():
            if 'permissions' in user and role in user['permissions']:
                user_copy = user.copy()
                user_copy['USERid'] = user_id
                users_with_role.append(user_copy)
        
        if not users_with_role:
            logging.info(f"No users found with role '{role}'")
            return jsonify({"status": "info", "message": f"No users found with role '{role}'"}), 200
        
        logging.debug(f"Retrieved users with role '{role}': {len(users_with_role)} users found")
        return jsonify({"status": "success", "role": role, "users": users_with_role}), 200
    except Exception as e:
        logging.error(f"Failed to retrieve users with role '{role}': {str(e)}", exc_info=True)
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500
# endregion

# region Settings Management
@manager_bp.route('/settings/settings_key', methods=['GET'])
@login_required(["admin"], require_all=True)
def get_settings_key_settings():
    """
    Retrieves all settings of type 'settings_key' from the configuration.
    Purpose: Provides admins with a list of settings_key settings for management.
    Permissions: Restricted to "admin"—only the chosen can access this!
    Inputs: None
    Outputs:
        - Success: JSON {"status": "success", "setting_type": "settings_key", "settings": [<list_of_settings>]}, status 200
        - Errors:
            - 404: {"status": "error", "message": "Setting type settings_key not found"} if no settings are found
            - 500: {"status": "error", "message": "Server error: <reason>"}
    """
    try:
        config = load_config()
        settings = []
        for key, value in config.items():
            if value.get('setting_type') == 'settings_key':
                fields = {k: v for k, v in value.items() if k not in ['_comment', 'setting_type', 'icon', 'doc_link', '_description']}
                setting = {
                    'key_type': key,
                    'fields': fields,
                    'icon': value.get('icon', 'icon-favicon'),
                    'doc_link': value.get('doc_link', ''),
                    'comment': value.get('_comment', ''),
                    'description': value.get('_description', '')
                }
                settings.append(setting)
        
        if not settings:
            logging.warning("No settings found for type 'settings_key'")
            return jsonify({"status": "error", "message": "Setting type settings_key not found"}), 404
        
        logging.debug(f"Retrieved settings_key settings: {json.dumps(settings)}")
        return jsonify({"status": "success", "setting_type": "settings_key", "settings": settings}), 200
    except Exception as e:
        logging.error(f"Failed to retrieve settings_key settings: {str(e)}", exc_info=True)
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

@manager_bp.route('/settings/settings_key/<key_type>', methods=['PATCH'])
@login_required(["admin"], require_all=True)
def patch_settings_key(key_type):
    """
    Updates specific fields of an existing settings_key entry.
    Purpose: Allows admins to modify parts of a settings_key setting.
    Permissions: Restricted to "admin".
    Inputs: JSON payload with fields to update.
    Outputs:
        - Success: JSON {"status": "success", "message": "Setting <key_type> updated"}, status 200
        - Errors:
            - 400: {"status": "error", "message": "No data provided"}
            - 404: {"status": "error", "message": "Setting not found"}
            - 400: {"status": "error", "message": "Invalid field: <field>"}
            - 500: {"status": "error", "message": "Server error: <reason>"}
    """
    try:
        data = request.get_json()
        if not data:
            return jsonify({"status": "error", "message": "No data provided"}), 400

        config = load_config()
        if key_type not in config or config[key_type].get('setting_type') != 'settings_key':
            return jsonify({"status": "error", "message": "Setting not found"}), 404
        
        valid_fields = {k for k in config[key_type].keys() if k not in ['_comment', 'setting_type', 'icon', 'doc_link', '_description']}
        for field, value in data.items():
            if field in valid_fields:
                config[key_type][field] = value
            else:
                return jsonify({"status": "error", "message": f"Invalid field: {field}"}), 400

        save_config(config)
        logging.info(f"Updated settings_key: {key_type}")
        return jsonify({"status": "success", "message": f"Setting {key_type} updated"}), 200
    except Exception as e:
        logging.error(f"Failed to update settings_key: {str(e)}")
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

@manager_bp.route('/settings/settings_key/<key_type>', methods=['PUT'])
@login_required(["admin"], require_all=True)
def put_settings_key(key_type):
    """
    Replaces an existing settings_key entry or creates it if it doesn’t exist.
    Purpose: Allows admins to fully replace a settings_key setting.
    Permissions: Restricted to "admin".
    Inputs: JSON payload with full setting data (must include "setting_type": "settings_key").
    Outputs:
        - Success: JSON {"status": "success", "message": "Setting <key_type> replaced"}, status 200
        - Errors:
            - 400: {"status": "error", "message": "No data provided"}
            - 400: {"status": "error", "message": "Invalid setting_type for this endpoint."}
            - 500: {"status": "error", "message": "Server error: <reason>"}
    """
    try:
        data = request.get_json()
        if not data:
            return jsonify({"status": "error", "message": "No data provided"}), 400

        if data.get('setting_type') != 'settings_key':
            return jsonify({"status": "error", "message": "Invalid setting_type for this endpoint."}), 400
        
        config = load_config()
        valid_fields = {k for k in config[key_type].keys() if k not in ['_comment', 'setting_type', 'icon', 'doc_link', '_description']} if key_type in config else set()
        if valid_fields:
            temp_data = {k: v for k, v in data.items() if k in valid_fields}
            temp_data['setting_type'] = 'settings_key'
            temp_data['_comment'] = config[key_type].get('_comment', '')
            temp_data['icon'] = config[key_type].get('icon', 'icon-favicon')
            temp_data['doc_link'] = config[key_type].get('doc_link', '')
            temp_data['_description'] = config[key_type].get('_description', '')
            config[key_type] = temp_data
        else:
            config[key_type] = data
        save_config(config)
        logging.info(f"Replaced settings_key: {key_type}")
        return jsonify({"status": "success", "message": f"Setting {key_type} replaced"}), 200
    except Exception as e:
        logging.error(f"Failed to replace settings_key: {str(e)}")
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

@manager_bp.route('/settings/affiliate_key', methods=['GET'])
@login_required(["admin"], require_all=True)
def get_affiliate_key_settings():
    """
    Retrieves all settings of type 'affiliate_key' from the configuration.
    Purpose: Provides admins with a list of affiliate_key settings for management.
    Permissions: Restricted to "admin"—only the chosen can access this!
    Inputs: None
    Outputs:
        - Success: JSON {"status": "success", "setting_type": "affiliate_key", "settings": [<list_of_settings>]}, status 200
        - Errors:
            - 404: {"status": "error", "message": "Setting type affiliate_key not found"} if no settings are found
            - 500: {"status": "error", "message": "Server error: <reason>"}
    """
    try:
        config = load_config()
        settings = []
        for key, value in config.items():
            if value.get('setting_type') == 'affiliate_key':
                fields = {k: v for k, v in value.items() if k not in ['_comment', 'setting_type', 'icon', 'doc_link', '_description']}
                setting = {
                    'key_type': key,
                    'fields': fields,
                    'icon': value.get('icon', 'icon-favicon'),
                    'doc_link': value.get('doc_link', ''),
                    'comment': value.get('_comment', ''),
                    'description': value.get('_description', '')
                }
                settings.append(setting)
        
        if not settings:
            logging.warning("No settings found for type 'affiliate_key'")
            return jsonify({"status": "error", "message": "Setting type affiliate_key not found"}), 404
        
        logging.debug(f"Retrieved affiliate_key settings: {json.dumps(settings)}")
        return jsonify({"status": "success", "setting_type": "affiliate_key", "settings": settings}), 200
    except Exception as e:
        logging.error(f"Failed to retrieve affiliate_key settings: {str(e)}", exc_info=True)
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

@manager_bp.route('/settings/affiliate_key/<key_type>', methods=['PATCH'])
@login_required(["admin"], require_all=True)
def patch_affiliate_key(key_type):
    """
    Updates specific fields of an existing affiliate_key entry.
    Purpose: Allows admins to modify parts of an affiliate_key setting.
    Permissions: Restricted to "admin".
    Inputs: JSON payload with fields to update.
    Outputs:
        - Success: JSON {"status": "success", "message": "Setting <key_type> updated"}, status 200
        - Errors:
            - 400: {"status": "error", "message": "No data provided"}
            - 404: {"status": "error", "message": "Setting not found"}
            - 400: {"status": "error", "message": "Invalid field: <field>"}
            - 500: {"status": "error", "message": "Server error: <reason>"}
    """
    try:
        data = request.get_json()
        if not data:
            return jsonify({"status": "error", "message": "No data provided"}), 400

        config = load_config()
        if key_type not in config or config[key_type].get('setting_type') != 'affiliate_key':
            return jsonify({"status": "error", "message": "Setting not found"}), 404
        
        valid_fields = {k for k in config[key_type].keys() if k not in ['_comment', 'setting_type', 'icon', 'doc_link', '_description']}
        for field, value in data.items():
            if field in valid_fields:
                config[key_type][field] = value
            else:
                return jsonify({"status": "error", "message": f"Invalid field: {field}"}), 400

        save_config(config)
        logging.info(f"Updated affiliate_key: {key_type}")
        return jsonify({"status": "success", "message": f"Setting {key_type} updated"}), 200
    except Exception as e:
        logging.error(f"Failed to update affiliate_key: {str(e)}")
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

@manager_bp.route('/settings/affiliate_key/<key_type>', methods=['PUT'])
@login_required(["admin"], require_all=True)
def put_affiliate_key(key_type):
    """
    Replaces an existing affiliate_key entry or creates it if it doesn’t exist.
    Purpose: Allows admins to fully replace an affiliate_key setting.
    Permissions: Restricted to "admin".
    Inputs: JSON payload with full setting data (must include "setting_type": "affiliate_key").
    Outputs:
        - Success: JSON {"status": "success", "message": "Setting <key_type> replaced"}, status 200
        - Errors:
            - 400: {"status": "error", "message": "No data provided"}
            - 400: {"status": "error", "message": "Invalid setting_type for this endpoint."}
            - 500: {"status": "error", "message": "Server error: <reason>"}
    """
    try:
        data = request.get_json()
        if not data:
            return jsonify({"status": "error", "message": "No data provided"}), 400

        if data.get('setting_type') != 'affiliate_key':
            return jsonify({"status": "error", "message": "Invalid setting_type for this endpoint."}), 400
        
        config = load_config()
        valid_fields = {k for k in config[key_type].keys() if k not in ['_comment', 'setting_type', 'icon', 'doc_link', '_description']} if key_type in config else set()
        if valid_fields:
            temp_data = {k: v for k, v in data.items() if k in valid_fields}
            temp_data['setting_type'] = 'affiliate_key'
            temp_data['_comment'] = config[key_type].get('_comment', '')
            temp_data['icon'] = config[key_type].get('icon', 'icon-favicon')
            temp_data['doc_link'] = config[key_type].get('doc_link', '')
            temp_data['_description'] = config[key_type].get('_description', '')
            config[key_type] = temp_data
        else:
            config[key_type] = data
        save_config(config)
        logging.info(f"Replaced affiliate_key: {key_type}")
        return jsonify({"status": "success", "message": f"Setting {key_type} replaced"}), 200
    except Exception as e:
        logging.error(f"Failed to replace affiliate_key: {str(e)}")
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500
# endregion

# region PostHog Event Endpoints
@manager_bp.route('/posthog/login', methods=['GET'])
@login_required(["admin"], require_all=True)
def get_all_login_events():
    """
    Retrieves all PostHog login events, like Marvin logging every galactic entry!
    Purpose: Allows admins to fetch all login events for security monitoring.
    Permissions: Restricted to "admin"—only the chosen can access the logs!
    Inputs: None
    Outputs:
        - Success: JSON {"status": "success", "event_type": "login", "events": [<event_data>]}, status 200
        - Info: JSON {"status": "info", "message": "No login events found"}, status 200 if no events
        - Errors:
            - 500: {"status": "error", "message": "Server error: <reason>"}
    """
    try:
        user_id = request.user_id
        config = load_config()
        posthog_config = config.get("posthog", {})
        api_key = posthog_config.get("PROJECT_READ_KEY")
        host = posthog_config.get("HOST", "https://eu.i.posthog.com")
        project_id = posthog_config.get("PROJECT_ID")
        
        logging.debug(f"PostHog config loaded: PROJECT_READ_KEY={'[REDACTED]' if api_key else None}, HOST={host}, PROJECT_ID={project_id}")
        
        if not api_key or not project_id:
            logging.error("PostHog Issue - Missing PROJECT_READ_KEY or PROJECT_ID in config")
            return jsonify({"status": "error", "message": "PostHog configuration missing PROJECT_READ_KEY or PROJECT_ID"}), 500
        
        # Query PostHog API for login events
        response = requests.get(
            f"{host}/api/projects/{project_id}/events",
            headers={"Authorization": f"Bearer {api_key}"},
            params={"event": "login"}
        )
        
        if response.status_code != 200:
            logging.error(f"PostHog Issue - Failed to fetch login events: {response.text}")
            return jsonify({"status": "error", "message": f"Failed to fetch login events: {response.text}"}), 500
        
        events_data = response.json().get("results", [])
        events = [
            {
                "distinct_id": event.get("distinct_id"),
                "properties": event.get("properties", {}),
                "timestamp": event.get("timestamp")
            }
            for event in events_data
        ]
        
        if not events:
            logging.info("No login events found")
            return jsonify({"status": "info", "message": "No login events found"}), 200
        
        logging.debug(f"Admin {user_id} retrieved {len(events)} login events")
        return jsonify({"status": "success", "event_type": "login", "events": events}), 200
    except Exception as e:
        logging.error(f"UX Issue - Failed to retrieve login events for admin {user_id}: {str(e)}", exc_info=True)
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

@manager_bp.route('/posthog/signup', methods=['GET'])
@login_required(["admin"], require_all=True)
def get_all_signup_events():
    """
    Retrieves all PostHog signup events, like Arthur Dent signing up for galactic adventures!
    Purpose: Allows admins to fetch all signup events for user onboarding analysis.
    Permissions: Restricted to "admin"—only the elite can see new recruits!
    Inputs: None
    Outputs:
        - Success: JSON {"status": "success", "event_type": "signup", "events": [<event_data>]}, status 200
        - Info: JSON {"status": "info", "message": "No signup events found"}, status 200 if no events
        - Errors:
            - 500: {"status": "error", "message": "Server error: <reason>"}
    """
    try:
        user_id = request.user_id
        config = load_config()
        posthog_config = config.get("posthog", {})
        api_key = posthog_config.get("PROJECT_READ_KEY")
        host = posthog_config.get("HOST", "https://eu.i.posthog.com")
        project_id = posthog_config.get("PROJECT_ID")
        
        logging.debug(f"PostHog config loaded: PROJECT_READ_KEY={'[REDACTED]' if api_key else None}, HOST={host}, PROJECT_ID={project_id}")
        
        if not api_key or not project_id:
            logging.error("PostHog Issue - Missing PROJECT_READ_KEY or PROJECT_ID in config")
            return jsonify({"status": "error", "message": "PostHog configuration missing PROJECT_READ_KEY or PROJECT_ID"}), 500
        
        # Query PostHog API for signup events
        response = requests.get(
            f"{host}/api/projects/{project_id}/events",
            headers={"Authorization": f"Bearer {api_key}"},
            params={"event": "signup"}
        )
        
        if response.status_code != 200:
            logging.error(f"PostHog Issue - Failed to fetch signup events: {response.text}")
            return jsonify({"status": "error", "message": f"Failed to fetch signup events: {response.text}"}), 500
        
        events_data = response.json().get("results", [])
        events = [
            {
                "distinct_id": event.get("distinct_id"),
                "properties": event.get("properties", {}),
                "timestamp": event.get("timestamp")
            }
            for event in events_data
        ]
        
        if not events:
            logging.info("No signup events found")
            return jsonify({"status": "info", "message": "No signup events found"}), 200
        
        logging.debug(f"Admin {user_id} retrieved {len(events)} signup events")
        return jsonify({"status": "success", "event_type": "signup", "events": events}), 200
    except Exception as e:
        logging.error(f"UX Issue - Failed to retrieve signup events for admin {user_id}: {str(e)}", exc_info=True)
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

@manager_bp.route('/posthog/click', methods=['GET'])
@login_required(["admin"], require_all=True)
def get_all_click_events():
    """
    Retrieves all PostHog click events, like Zaphod clicking his way to a Pan-Galactic Gargle Blaster!
    Purpose: Allows admins to fetch all click events for referral tracking.
    Permissions: Restricted to "admin"—only the chosen can track clicks!
    Inputs: None
    Outputs:
        - Success: JSON {"status": "success", "event_type": "click", "events": [<event_data>]}, status 200
        - Info: JSON {"status": "info", "message": "No click events found"}, status 200 if no events
        - Errors:
            - 500: {"status": "error", "message": "Server error: <reason>"}
    """
    try:
        user_id = request.user_id
        config = load_config()
        posthog_config = config.get("posthog", {})
        api_key = posthog_config.get("PROJECT_READ_KEY")
        host = posthog_config.get("HOST", "https://eu.i.posthog.com")
        project_id = posthog_config.get("PROJECT_ID")
        
        logging.debug(f"PostHog config loaded: PROJECT_READ_KEY={'[REDACTED]' if api_key else None}, HOST={host}, PROJECT_ID={project_id}")
        
        if not api_key or not project_id:
            logging.error("PostHog Issue - Missing PROJECT_READ_KEY or PROJECT_ID in config")
            return jsonify({"status": "error", "message": "PostHog configuration missing PROJECT_READ_KEY or PROJECT_ID"}), 500
        
        # Query PostHog API for click events
        response = requests.get(
            f"{host}/api/projects/{project_id}/events",
            headers={"Authorization": f"Bearer {api_key}"},
            params={"event": "click"}
        )
        
        if response.status_code != 200:
            logging.error(f"PostHog Issue - Failed to fetch click events: {response.text}")
            return jsonify({"status": "error", "message": f"Failed to fetch click events: {response.text}"}), 500
        
        events_data = response.json().get("results", [])
        events = [
            {
                "distinct_id": event.get("distinct_id"),
                "properties": event.get("properties", {}),
                "timestamp": event.get("timestamp")
            }
            for event in events_data
        ]
        
        if not events:
            logging.info("No click events found")
            return jsonify({"status": "info", "message": "No click events found"}), 200
        
        logging.debug(f"Admin {user_id} retrieved {len(events)} click events")
        return jsonify({"status": "success", "event_type": "click", "events": events}), 200
    except Exception as e:
        logging.error(f"UX Issue - Failed to retrieve click events for admin {user_id}: {str(e)}", exc_info=True)
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

@manager_bp.route('/posthog/order', methods=['GET'])
@login_required(["admin"], require_all=True)
def get_all_order_events():
    """
    Retrieves all PostHog order events, like Trillian sealing deals across the galaxy!
    Purpose: Allows admins to fetch all order events for sales analysis.
    Permissions: Restricted to "admin"—only the elite can see the ledger!
    Inputs: None
    Outputs:
        - Success: JSON {"status": "success", "event_type": "order", "events": [<event_data>]}, status 200
        - Info: JSON {"status": "info", "message": "No order events found"}, status 200 if no events
        - Errors:
            - 500: {"status": "error", "message": "Server error: <reason>"}
    """
    try:
        user_id = request.user_id
        config = load_config()
        posthog_config = config.get("posthog", {})
        api_key = posthog_config.get("PROJECT_READ_KEY")
        host = posthog_config.get("HOST", "https://eu.i.posthog.com")
        project_id = posthog_config.get("PROJECT_ID")
        
        logging.debug(f"PostHog config loaded: PROJECT_READ_KEY={'[REDACTED]' if api_key else None}, HOST={host}, PROJECT_ID={project_id}")
        
        if not api_key or not project_id:
            logging.error("PostHog Issue - Missing PROJECT_READ_KEY or PROJECT_ID in config")
            return jsonify({"status": "error", "message": "PostHog configuration missing PROJECT_READ_KEY or PROJECT_ID"}), 500
        
        # Query PostHog API for order events
        response = requests.get(
            f"{host}/api/projects/{project_id}/events",
            headers={"Authorization": f"Bearer {api_key}"},
            params={"event": "order"}
        )
        
        if response.status_code != 200:
            logging.error(f"PostHog Issue - Failed to fetch order events: {response.text}")
            return jsonify({"status": "error", "message": f"Failed to fetch order events: {response.text}"}), 500
        
        events_data = response.json().get("results", [])
        events = [
            {
                "distinct_id": event.get("distinct_id"),
                "properties": event.get("properties", {}),
                "timestamp": event.get("timestamp")
            }
            for event in events_data
        ]
        
        if not events:
            logging.info("No order events found")
            return jsonify({"status": "info", "message": "No order events found"}), 200
        
        logging.debug(f"Admin {user_id} retrieved {len(events)} order events")
        return jsonify({"status": "success", "event_type": "order", "events": events}), 200
    except Exception as e:
        logging.error(f"UX Issue - Failed to retrieve order events for admin {user_id}: {str(e)}", exc_info=True)
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500
# endregion

# ASCII Art 1: The Two Ronnies’ Fork Handles
"""
       ______
      /|_||_\`.__
     (   _    _ _\
     =|  _    _  |  "Four candles? No, fork handles—admin privileges required!"
      | (_)  (_) |
       \._|\'|\'_./
          |__|__| 
"""
referral_bp.py
from flask import Blueprint, request, jsonify
from utils.auth import login_required
from utils.users import load_users_settings, save_users_settings
import logging
import json
import os
import posthog
from datetime import datetime

# region Blueprint Setup
# referral_bp: The galactic hub for tracking referrals, clicks, orders, logins, and signups!
referral_bp = Blueprint('referral_bp', __name__)
# endregion

# region Config Handling
CONFIG_FILE = "config.json"

def load_config():
    """Load configuration from config.json."""
    try:
        if os.path.exists(CONFIG_FILE):
            with open(CONFIG_FILE, 'r') as f:
                config = json.load(f)
                log_config = config.copy()
                if "jwt" in log_config and "SECRET_KEY" in log_config["jwt"]:
                    log_config["jwt"]["SECRET_KEY"] = "[REDACTED]"
                if "posthog" in log_config and "api_key" in log_config["posthog"]:
                    log_config["posthog"]["api_key"] = "[REDACTED]"
                logging.debug(f"Loaded config: {json.dumps(log_config)}")
                return config
        else:
            logging.warning("UX Issue - Config file not found, using defaults")
            default_config = {"log_level": "DEBUG", "jwt": {"SECRET_KEY": "your-secret-key"}, "posthog": {}}
            return default_config
    except json.JSONDecodeError as e:
        logging.error(f"Security Issue - Invalid config file format: {str(e)}", exc_info=True)
        return {"log_level": "DEBUG", "jwt": {"SECRET_KEY": "your-secret-key"}, "posthog": {}}
    except Exception as e:
        logging.error(f"UX Issue - Failed to load config: {str(e)}", exc_info=True)
        return {"log_level": "DEBUG", "jwt": {"SECRET_KEY": "your-secret-key"}, "posthog": {}}

def save_config(config):
    """Save configuration to config.json."""
    try:
        with open(CONFIG_FILE, 'w') as f:
            json.dump(config, f, indent=4)
        log_config = config.copy()
        if "jwt" in log_config and "SECRET_KEY" in log_config["jwt"]:
            log_config["jwt"]["SECRET_KEY"] = "[REDACTED]"
        if "posthog" in log_config and "api_key" in log_config["posthog"]:
            log_config["posthog"]["api_key"] = "[REDACTED]"
        logging.debug(f"Saved config: {json.dumps(log_config)}")
    except Exception as e:
        logging.error(f"UX Issue - Failed to save config: {str(e)}", exc_info=True)
        raise
# endregion

# region /referral POST - Recording Galactic Referrals
@referral_bp.route('/referral', methods=['POST'])
def handle_referral():
    """
    Records referral data (visits or orders), like the Spanish Inquisition—nobody expects it!
    Inputs: JSON payload with:
        - timestamp (str): When the referral happened.
        - referer (str, optional): The ID of the referer, defaults to "none".
        - page (str, optional): The page visited, required for visit referrals.
        - orderId (str, optional): The order ID, required for order referrals.
        - buyer (str, optional): The buyer’s name or ID for orders.
        - total (float, optional): The order total for orders.
    Outputs:
        - Success: JSON {"status": "success", "message": "Referral recorded", "referer": "<referer>"}, status 200
        - Errors: JSON with error message, status 400 or 500
    """
    try:
        data = request.get_json()
        if not data or 'timestamp' not in data:
            logging.warning(f"UX Issue - Invalid referral data: {json.dumps(data)}")
            if posthog_client:
                posthog_client.capture(
                    distinct_id=data.get("referer", "unknown"),
                    event="referral_error",
                    properties={"error": "Invalid data: timestamp required", "data": data}
                )
            return jsonify({"status": "error", "message": "Invalid data: timestamp required"}), 400
        
        users_settings = load_users_settings()
        referer = data.get("referer", "none")
        if referer not in users_settings:
            logging.debug(f"New referer {referer} initialized with empty referral data")
            users_settings[referer] = {"referrals": {"visits": [], "orders": []}}
        
        event_properties = {"timestamp": data["timestamp"]}
        event_name = None
        
        if "page" in data:
            users_settings[referer]["referrals"]["visits"].append({
                "page": data["page"],
                "timestamp": data["timestamp"]
            })
            event_name = "referral_visit"
            event_properties["page"] = data["page"]
        elif "orderId" in data:
            users_settings[referer]["referrals"]["orders"].append({
                "orderId": data["orderId"],
                "buyer": data.get("buyer", "unknown"),
                "total": data.get("total", 0.0),
                "timestamp": data["timestamp"]
            })
            event_name = "referral_order"
            event_properties.update({
                "orderId": data["orderId"],
                "buyer": data.get("buyer", "unknown"),
                "total": data.get("total", 0.0)
            })
        else:
            logging.warning(f"UX Issue - Referral data missing page or orderId: {json.dumps(data)}")
            if posthog_client:
                posthog_client.capture(
                    distinct_id=referer,
                    event="referral_error",
                    properties={"error": "Invalid referral data: page or orderId required", "data": data}
                )
            return jsonify({"status": "error", "message": "Invalid referral data: page or orderId required"}), 400
        
        save_users_settings(users_settings)
        logging.info(f"Referral recorded for referer {referer}: {json.dumps(data)}")
        
        if posthog_client:
            posthog_client.capture(
                distinct_id=referer,
                event=event_name,
                properties=event_properties
            )
        
        return jsonify({"status": "success", "message": "Referral recorded", "referer": referer}), 200
    except Exception as e:
        logging.error(f"UX Issue - Failed to handle referral: {str(e)}", exc_info=True)
        if posthog_client:
            posthog_client.capture(
                distinct_id=data.get("referer", "unknown") if data else "unknown",
                event="referral_error",
                properties={"error": f"Server error: {str(e)}"}
            )
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500
# endregion

# region /click POST - Recording Click Events
@referral_bp.route('/click', methods=['POST'])
def handle_click():
    try:
        data = request.get_json()
        if not data or not all(key in data for key in ["source_user_id", "destination_user_id", "timestamp"]):
            logging.warning(f"UX Issue - Invalid click data: {json.dumps(data)}")
            if posthog_client:
                posthog_client.capture(
                    distinct_id=data.get("source_user_id", "unknown"),
                    event="click_error",
                    properties={"error": "Invalid data: source_user_id, destination_user_id, timestamp required", "data": data}
                )
            return jsonify({"status": "error", "message": "Invalid data: source_user_id, destination_user_id, timestamp required"}), 400
        
        if posthog_client:
            try:
                posthog_client.capture(
                    distinct_id=data["source_user_id"],
                    event="click",
                    properties={
                        "source_user_id": data["source_user_id"],
                        "destination_user_id": data["destination_user_id"],
                        "timestamp": data["timestamp"]
                    }
                )
                logging.info(f"Click event captured for {data['source_user_id']} to {data['destination_user_id']}")
            except Exception as e:
                logging.error(f"Failed to capture click event: {str(e)}")
        else:
            logging.warning("posthog_client is None, event not captured")
        
        logging.info(f"Click recorded from {data['source_user_id']} to {data['destination_user_id']}")
        return jsonify({"status": "success", "message": "Click recorded"}), 200
    except Exception as e:
        logging.error(f"UX Issue - Failed to handle click: {str(e)}", exc_info=True)
        if posthog_client:
            posthog_client.capture(
                distinct_id=data.get("source_user_id", "unknown") if data else "unknown",
                event="click_error",
                properties={"error": f"Server error: {str(e)}"}
            )
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500
    
# endregion

# region /order POST - Recording Order Events
@referral_bp.route('/order', methods=['POST'])
def handle_order():
    """
    Records an order event with source, destination user IDs, and sale value, like Trillian sealing a deal in the galaxy!
    Inputs: JSON payload with:
        - source_user_id (str): The ID of the user initiating the order.
        - destination_user_id (str): The ID of the user being referred to.
        - sale_value (float): The value of the sale.
        - timestamp (str): When the order happened, e.g., "2023-10-26T12:34:56Z".
    Outputs:
        - Success: JSON {"status": "success", "message": "Order recorded"}, status 200
        - Errors: JSON with error message, status 400 or 500
    """
    try:
        data = request.get_json()
        if not data or not all(key in data for key in ["source_user_id", "destination_user_id", "sale_value", "timestamp"]):
            logging.warning(f"UX Issue - Invalid order data: {json.dumps(data)}")
            if posthog_client:
                posthog_client.capture(
                    distinct_id=data.get("source_user_id", "unknown"),
                    event="order_error",
                    properties={"error": "Invalid data: source_user_id, destination_user_id, sale_value, timestamp required", "data": data}
                )
            return jsonify({"status": "error", "message": "Invalid data: source_user_id, destination_user_id, sale_value, timestamp required"}), 400
        
        if posthog_client:
            posthog_client.capture(
                distinct_id=data["source_user_id"],
                event="order",
                properties={
                    "source_user_id": data["source_user_id"],
                    "destination_user_id": data["destination_user_id"],
                    "sale_value": data["sale_value"],
                    "timestamp": data["timestamp"]
                }
            )
        
        logging.info(f"Order recorded from {data['source_user_id']} to {data['destination_user_id']} for {data['sale_value']}")
        return jsonify({"status": "success", "message": "Order recorded"}), 200
    except Exception as e:
        logging.error(f"UX Issue - Failed to handle order: {str(e)}", exc_info=True)
        if posthog_client:
            posthog_client.capture(
                distinct_id=data.get("source_user_id", "unknown") if data else "unknown",
                event="order_error",
                properties={"error": f"Server error: {str(e)}"}
            )
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500
# endregion

# ASCII Art 1: The Dead Parrot
"""
       ______
      /|_||_\`.__
     (   _    _ _\
     =|  _    _  |  "This referral is no more! It has ceased to be!"
      | (_)  (_) |
       \._|\'|\'_./
          |__|__| 
"""

# ASCII Art 2: The Towel
"""
       ______
      /|_||_\`.__
     (   _    _ _\
     =|  _    _  |  "Don’t forget your towel—essential for referral success!"
      | (_)  (_) |
       \._|\'|\'_./
          |__|__| 
"""
site_request_bp.py
from flask import Blueprint, request, jsonify
from utils.auth import login_required
from utils.data import load_site_request, save_site_request
from utils.users import load_users_settings
import logging
import os
import datetime
import json
import re

# region Blueprint Setup
# Welcome to site_request_bp, the blueprint that handles site requests like Zaphod Beeblebrox handles improbability—fast and with flair!
# This module is the galactic hub for listing and saving site requests. Prepare for some cosmic organization!
site_request_bp = Blueprint('site_request_bp', __name__)
# endregion

# region /siterequests GET - Listing Galactic Site Requests
@site_request_bp.route('/siterequests', methods=['GET'])
@login_required(["admin", "wixpro"], require_all=False)
def list_site_requests():
    """
    Lists all site requests, like the Spanish Inquisition—nobody expects it, but it’s here for admins and wixpro users!
    Purpose: To provide a list of site requests for admins or wixpro users, helping them manage the galaxy’s site needs.
    Permissions: Restricted to "admin" or "wixpro"—you’re either the chosen one or a very naughty boy!
    Inputs: None—just be logged in with the right permissions, or it’s “Nobody expects the Spanish Inquisition!”
    Outputs:
        - Success: JSON {"status": "success", "siterequests": [<siterequest_data>]}, status 200—your map to the site requests!
        - Errors:
            - 500: {"status": "error", "message": "Server error: <reason>"}—the Parrot’s ceased to be!
    """
    try:
        # Check permissions—like the Knights Who Say Ni demanding a shrubbery!
        if "admin" not in request.permissions and "wixpro" not in request.permissions:
            logging.warning(f"Security Issue - Unauthorized site request list attempt by {request.user_id}")
            return jsonify({"status": "error", "message": "Unauthorized"}), 403
        
        # Load the site request directory—like Arthur Dent flipping through the Guide.
        siterequest_dir = 'siterequest'
        if not os.path.exists(siterequest_dir):
            logging.warning("UX Issue - No site requests directory found")
            return jsonify({"status": "success", "siterequests": []}), 200

        # Load user settings—like the Guide, but with less towel advice.
        users_settings = load_users_settings()
        siterequests = []

        # Process each site request file—like the Holy Grail, but with JSON.
        for filename in os.listdir(siterequest_dir):
            if filename.endswith('.json'):
                user_id = filename.replace('.json', '')
                site_request = load_site_request(user_id)
                if site_request:
                    contact_name = users_settings.get(user_id, {}).get('contact_name', '')
                    email = users_settings.get(user_id, {}).get('email_address', '')
                    request_type = site_request.get('type', '')
                    store_name = site_request.get('communityName')  # Adjusted to match POST logic
                    community_name = site_request.get('communityName')
                    organisation = store_name if store_name else community_name if community_name else ''
                    received_at = site_request.get('submitted_at', '')

                    # Assemble the site request data—fit for the Life of Brian’s marketplace.
                    siterequests.append({
                        'user_id': user_id,
                        'type': request_type,
                        'received_at': received_at,
                        'contact_name': contact_name,
                        'email': email,
                        'organisation': organisation
                    })

        if not siterequests:
            logging.warning("UX Issue - No site requests found in directory")
        logging.debug(f"Listed site requests: {json.dumps(siterequests)}")
        return jsonify({"status": "success", "siterequests": siterequests}), 200
    except Exception as e:
        # Marvin’s take: “I tried to list site requests, and now I’m even more depressed.”
        logging.error(f"UX Issue - Failed to list site requests: {str(e)}", exc_info=True)
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500
# endregion

# ASCII Art 1: The Dead Parrot
"""
       ______
      /|_||_\`.__
     (   _    _ _\
     =|  _    _  |  "This site request is no more! It has ceased to be!"
      | (_)  (_) |
       \._|\'|\'_./
          |__|__| 
"""

# region /siterequests POST - Saving New Galactic Site Requests
@site_request_bp.route('/siterequests', methods=['POST'])
@login_required(["self"], require_all=True)
def save_site_request_endpoint():
    """
    Saves a new site request, faster than Zaphod’s spaceship escaping a Vogon poetry reading.
    Purpose: Allows users to submit new site requests, restricted to themselves—like the People’s Front of Judea’s secret meetings.
    Permissions: Restricted to "self"—only you can submit your own request, or it’s “Nobody expects the Spanish Inquisition!”
    Inputs: JSON payload with:
        - userId (str, optional): Must match the authenticated user.
        - type (str, optional): Request type, defaults to "community".
        - communityName (str): Name of the community or store.
        - aboutCommunity (str): Description of the community or store.
        - communityLogos (list): Logos for the community or store.
        - colorPrefs (str): Color preferences.
        - stylingDetails (str): Styling details.
        - preferredDomain (str): Preferred domain, e.g., "mycommunity.org".
        - emails (list): List of emails.
        - pages (list): List of pages.
        - widgets (list): List of widgets.
    Outputs:
        - Success: JSON {"status": "success", "message": "Site request saved successfully"}, status 200—request logged!
        - Errors:
            - 400: {"status": "error", "message": "No data provided"}—no data, no fork handles!
            - 400: {"status": "error", "message": "User ID in body does not match authenticated user"}—mismatch!
            - 403: {"status": "error", "message": "Unauthorized: Must be admin or match user_id"}—unauthorized!
            - 400: {"status": "error", "message": "Community name or store name is required"}—missing name!
            - 400: {"status": "error", "message": "Invalid domain name"}—bad domain!
            - 500: {"status": "error", "message": "Server error: <reason>"}—the Parrot’s pining again!
    """
    try:
        # Arthur Dent checks the JSON—where’s that data?
        data = request.get_json()
        if not data:
            logging.warning("UX Issue - Site request save attempt with no data")
            return jsonify({"status": "error", "message": "No data provided"}), 400

        # Check user_id—like the Knights Who Say Ni demanding a shrubbery!
        user_id = request.user_id
        body_user_id = data.get("userId")
        if body_user_id and body_user_id != user_id:
            logging.warning(f"Security Issue - User ID mismatch: URL={user_id}, Body={body_user_id}")
            return jsonify({"status": "error", "message": "User ID in body does not match authenticated user"}), 400

        # Permission check—only self or admin can submit, or it’s “Nobody expects the Spanish Inquisition!”
        if "admin" not in request.permissions and request.user_id != user_id:
            logging.warning(f"Security Issue - Unauthorized site request save by {request.user_id} for {user_id}")
            return jsonify({"status": "error", "message": "Unauthorized: Must be admin or match user_id"}), 403

        # Assemble the site request—like the Holy Grail, but with JSON.
        request_type = data.get("type", "community")
        site_request = {
            "user_id": user_id,
            "type": request_type,
            "communityName": data.get("communityName") or data.get("storeName") or "",
            "aboutCommunity": data.get("aboutCommunity") or data.get("aboutStore") or "",
            "communityLogos": data.get("communityLogos") or data.get("storeLogos") or [],
            "colorPrefs": data.get("colorPrefs", ""),
            "stylingDetails": data.get("stylingDetails", ""),
            "preferredDomain": data.get("preferredDomain", "mycommunity.org"),
            "emails": data.get("emails", []),
            "pages": data.get("pages", []),
            "widgets": data.get("widgets", []),
            "submitted_at": datetime.datetime.utcnow().isoformat()
        }

        # Check for community/store name—or it’s like asking for four candles and getting fork handles!
        if not site_request["communityName"]:
            logging.warning(f"UX Issue - Site request missing community/store name for user {user_id}")
            return jsonify({"status": "error", "message": "Community name or store name is required"}), 400

        # Validate domain—like checking if a parrot is still alive.
        domain_regex = r'^[a-zA-Z0-9-]+\.[a-zA-Z]{2,}$'
        if not re.match(domain_regex, site_request["preferredDomain"]):
            logging.warning(f"UX Issue - Invalid domain name for user {user_id}: {site_request['preferredDomain']}")
            return jsonify({"status": "error", "message": "Invalid domain name"}), 400

        # Process page images—like the Holy Hand Grenade, but less explosive.
        for page in site_request["pages"]:
            if "images" in page and page["images"]:
                page["images"] = [img if isinstance(img, str) else "placeholder" for img in page["images"]]

        # Save the site request—stronger than a Wookiee’s grip!
        save_site_request(user_id, site_request)
        logging.info(f"Site request saved successfully for user {user_id}: {json.dumps(site_request)}")
        return jsonify({"status": "success", "message": "Site request saved successfully"}), 200
    except Exception as e:
        # Marvin’s take: “I tried to save the site request, and now I’m even more depressed.”
        logging.error(f"UX Issue - Failed to save site request: {str(e)}", exc_info=True)
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500
# endregion

# ASCII Art 2: The Towel (Hitchhiker’s Guide)
"""
       ______
      /|_||_\`.__
     (   _    _ _\
     =|  _    _  |  "Don’t forget your towel—essential for site requests!"
      | (_)  (_) |
       \._|\'|\'_./
          |__|__| 
"""
user_settings_bp.py
from flask import Blueprint, request, jsonify
from utils.auth import login_required
from utils.users import load_users_settings, save_users_settings
from utils.config import load_config
from utils import wix
import logging
import json
from blueprints.referral_bp import posthog_client

user_settings_bp = Blueprint('user_settings_bp', __name__)

# region <settings/user> GET, PUT, PATCH
@user_settings_bp.route('/settings/user', methods=['GET', 'PUT', 'PATCH'])
@login_required(["self"], require_all=True)
def manage_user_settings():
    """
    Manage the authenticated user's top-level settings based on the HTTP method.
    
    - GET: Retrieve the user's top-level settings as a flat object of fields and values.
    - PUT: Replace the entire top-level settings with the provided fields and values.
    - PATCH: Update specific fields in the user's top-level settings.
    """
    try:
        user_id = request.user_id
        users_settings = load_users_settings()
        
        if user_id not in users_settings:
            return jsonify({"status": "error", "message": "User not found"}), 404
        
        # Ensure expected fields exist with default values
        expected_fields = ["contact_name", "website_url", "email_address", "phone_number"]
        for field in expected_fields:
            if field not in users_settings[user_id]:
                users_settings[user_id][field] = ""
        
        if request.method == 'GET':
            # Return a flat object of field-value pairs
            top_level_settings = {k: v for k, v in users_settings[user_id].items()}
            return jsonify({"status": "success", "settings": top_level_settings}), 200
        
        elif request.method == 'PUT':
            data = request.get_json()
            if not data:
                return jsonify({"status": "error", "message": "No data provided"}), 400
            
            # Allow any fields provided by the client
            users_settings[user_id] = data
            save_users_settings(users_settings)
            logging.info(f"Top-level settings replaced for user {user_id}")
            return jsonify({"status": "success", "message": "Settings replaced"}), 200
        
        elif request.method == 'PATCH':
            data = request.get_json()
            if not data:
                return jsonify({"status": "error", "message": "No data provided"}), 400
            
            for field, value in data.items():
                users_settings[user_id][field] = value
            
            save_users_settings(users_settings)
            logging.info(f"Top-level settings updated for user {user_id}")
            return jsonify({"status": "success", "message": "Settings updated"}), 200
    
    except Exception as e:
        logging.error(f"Error managing user settings for user {request.user_id}: {str(e)}")
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500
# endregion <settings/user> GET, PUT, PATCH

# region settings/api - Manage client_api and api_key settings
@user_settings_bp.route('/settings/client_api', methods=['GET'])
@login_required(["allauth"], require_all=False)
def get_client_api_settings():
    """
    Retrieve all client_api settings from the configuration.
    """
    try:
        config = load_config()
        settings = [
            {
                "key_type": key,
                "fields": {k: v for k, v in value.items() if k not in ["setting_type", "icon", "doc_link", "_comment","_description"]},                
                "icon": value.get("icon", "icon-favicon"),
                "doc_link": value.get("doc_link", ""),
                "comment": value.get("_comment", ""),
                "description": value.get("_description", "")
            }
            for key, value in config.items()
            if value.get("setting_type") == "client_api"
        ]
        return jsonify({"status": "success", "settings": settings}), 200
    except Exception as e:
        logging.error(f"Error retrieving client_api settings: {str(e)}")
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

@user_settings_bp.route('/settings/client_api/<key>', methods=['PUT', 'POST'])
@login_required(["self"], require_all=True)
def put_client_api_setting(key):
    """
    Replace the client_api setting for the specified key for the authenticated user.
    """
    try:
        user_id = request.user_id
        data = request.get_json()
        if not data:
            return jsonify({"status": "error", "message": "No data provided"}), 400

        config = load_config()
        if key not in config or config[key].get("setting_type") != "client_api":
            return jsonify({"status": "error", "message": "Invalid key"}), 400

        users_settings = load_users_settings()
        if user_id not in users_settings:
            return jsonify({"status": "error", "message": "User not found"}), 404

        if "settings" not in users_settings[user_id]:
            users_settings[user_id]["settings"] = {}
        if "client_api" not in users_settings[user_id]["settings"]:
            users_settings[user_id]["settings"]["client_api"] = {}
        users_settings[user_id]["settings"]["client_api"][key] = data
        save_users_settings(users_settings)
        return jsonify({"status": "success", "message": f"Setting {key} replaced"}), 200
    except Exception as e:
        logging.error(f"Error replacing client_api setting for user {request.user_id}: {str(e)}")
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

@user_settings_bp.route('/settings/client_api/<key>', methods=['PATCH'])
@login_required(["self"], require_all=True)
def patch_client_api_setting(key):
    """
    Update specific fields of the client_api setting for the specified key for the authenticated user.
    """
    try:
        user_id = request.user_id
        data = request.get_json()
        if not data:
            return jsonify({"status": "error", "message": "No data provided"}), 400

        config = load_config()
        if key not in config or config[key].get("setting_type") != "client_api":
            return jsonify({"status": "error", "message": "Invalid key"}), 400

        users_settings = load_users_settings()
        if user_id not in users_settings or "settings" not in users_settings[user_id] or "client_api" not in users_settings[user_id]["settings"] or key not in users_settings[user_id]["settings"]["client_api"]:
            return jsonify({"status": "error", "message": "Setting not found"}), 404

        for field, value in data.items():
            if field in users_settings[user_id]["settings"]["client_api"][key]:
                users_settings[user_id]["settings"]["client_api"][key][field] = value
            else:
                return jsonify({"status": "error", "message": f"Invalid field: {field}"}), 400

        save_users_settings(users_settings)
        return jsonify({"status": "success", "message": f"Setting {key} updated"}), 200
    except Exception as e:
        logging.error(f"Error updating client_api setting for user {request.user_id}: {str(e)}")
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

@user_settings_bp.route('/settings/api_key', methods=['GET'])
@login_required(["allauth"], require_all=False)
def get_api_key_settings():
    """
    Retrieve all api_key settings for the authenticated user, merging configuration defaults with saved user settings.
    """
    try:
        user_id = request.user_id
        config = load_config()
        users_settings = load_users_settings()
        
        if user_id not in users_settings:
            return jsonify({"status": "error", "message": "User not found"}), 404
        
        # Get user's saved api_key settings, defaulting to an empty dict if not present
        user_api_keys = users_settings[user_id].get("settings", {}).get("api_key", {})
        
        settings = []
        for key, value in config.items():
            if value.get("setting_type") == "api_key":
                # Extract default fields, excluding metadata
                default_fields = {k: v for k, v in value.items() if k not in ["setting_type", "icon", "doc_link", "_comment", "_description"]}
                # Get user's saved fields for this key, defaulting to an empty dict
                user_fields = user_api_keys.get(key, {})
                # Merge defaults with user settings, prioritizing user data
                merged_fields = {field: user_fields.get(field, default_fields.get(field, "")) for field in default_fields}
                setting = {
                    "key_type": key,
                    "fields": merged_fields,
                    "icon": value.get("icon", "icon-favicon"),
                    "doc_link": value.get("doc_link", ""),
                    "comment": value.get("_comment", ""),
                    "description": value.get("_desctiption", "")
                }
                settings.append(setting)
        
        return jsonify({"status": "success", "settings": settings}), 200
    except Exception as e:
        logging.error(f"Error retrieving api_key settings for user {request.user_id}: {str(e)}")
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

@user_settings_bp.route('/settings/api_key/<key>', methods=['PUT', 'POST'])
@login_required(["self"], require_all=True)
def put_api_key_setting(key):
    """
    Replace the api_key setting for the specified key for the authenticated user.
    """
    try:
        user_id = request.user_id
        data = request.get_json()
        if not data:
            return jsonify({"status": "error", "message": "No data provided"}), 400

        config = load_config()
        if key not in config or config[key].get("setting_type") != "api_key":
            return jsonify({"status": "error", "message": "Invalid key"}), 400

        users_settings = load_users_settings()
        if user_id not in users_settings:
            return jsonify({"status": "error", "message": "User not found"}), 404

        if "settings" not in users_settings[user_id]:
            users_settings[user_id]["settings"] = {}
        if "api_key" not in users_settings[user_id]["settings"]:
            users_settings[user_id]["settings"]["api_key"] = {}
        users_settings[user_id]["settings"]["api_key"][key] = data
        save_users_settings(users_settings)
        return jsonify({"status": "success", "message": f"Setting {key} replaced"}), 200
    except Exception as e:
        logging.error(f"Error replacing api_key setting for user {request.user_id}: {str(e)}")
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

@user_settings_bp.route('/settings/api_key/<key>', methods=['PATCH'])
@login_required(["self"], require_all=True)
def patch_api_key_setting(key):
    """
    Update specific fields of the api_key setting for the specified key for the authenticated user.
    Only fields defined in the configuration are updated; others are ignored.
    """
    try:
        user_id = request.user_id
        data = request.get_json()
        if not data:
            return jsonify({"status": "error", "message": "No data provided"}), 400

        # Load the configuration to determine allowed fields
        config = load_config()
        if key not in config or config[key].get("setting_type") != "api_key":
            return jsonify({"status": "error", "message": "Invalid key"}), 400

        # Extract allowed fields from the configuration, excluding metadata
        allowed_fields = [field for field in config[key] if not field.startswith("_")]

        # Load user settings
        users_settings = load_users_settings()
        if user_id not in users_settings:
            return jsonify({"status": "error", "message": "User not found"}), 404

        # Ensure nested structure exists
        if "settings" not in users_settings[user_id]:
            users_settings[user_id]["settings"] = {}
        if "api_key" not in users_settings[user_id]["settings"]:
            users_settings[user_id]["settings"]["api_key"] = {}
        if key not in users_settings[user_id]["settings"]["api_key"]:
            users_settings[user_id]["settings"]["api_key"][key] = {}

        # Update only fields that are in the allowed_fields list
        for field, value in data.items():
            if field in allowed_fields:
                users_settings[user_id]["settings"]["api_key"][key][field] = value
            else:
                logging.info(f"Ignored invalid field: {field} for key: {key}")

        # Save the updated settings
        save_users_settings(users_settings)
        return jsonify({"status": "success", "message": f"Setting {key} updated"}), 200
    except Exception as e:
        logging.error(f"Error updating api_key setting for user {request.user_id}: {str(e)}")
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

# endregion settings/api

@user_settings_bp.route('/settings/products', methods=['GET'])
@login_required(["self"], require_all=True)
def get_user_products():
    """Retrieve the list of products for the current user."""
    try:
        user_id = request.user_id  # Get the user ID from the token
        products = wix.fetch_user_products(user_id)
        return jsonify({"status": "success", "count": len(products), "products": products}), 200
    except Exception as e:
        logging.error(f"Error fetching products for user {request.user_id}: {str(e)}")
        return jsonify({"status": "error", "message": "Failed to fetch products"}), 500
    
# region /sales GET - Self-Auth Endpoint for Sales Data
@user_settings_bp.route('/sales', methods=['GET'])
@login_required(["self"], require_all=False)
def get_sales():
    """
    Queries PostHog for click and order events where the user is source or destination, like Zaphod checking his galactic sales!
    Permissions: Restricted to merchant or community roles.
    Outputs:
        - Success: JSON {"status": "success", "clicks": [<click_data>], "orders": [<order_data>]}, status 200
        - Errors: JSON with error message, status 500
    """
    try:
        user_id = request.user_id
        clicks = []
        orders = []
        
        if posthog_client:
            # Query clicks where user is source or destination
            click_query = {
                "event": "click",
                "properties": [
                    {"key": "source_user_id", "value": user_id, "operator": "exact"},
                    {"key": "destination_user_id", "value": user_id, "operator": "exact"}
                ],
                "operator": "OR"
            }
            click_results = posthog_client.query_events(click_query)  # Assumes query_events method; adjust based on SDK
            clicks = [{"event": r["event"], "properties": r["properties"]} for r in click_results.get("results", [])]
            
            # Query orders where user is source or destination
            order_query = {
                "event": "order",
                "properties": [
                    {"key": "source_user_id", "value": user_id, "operator": "exact"},
                    {"key": "destination_user_id", "value": user_id, "operator": "exact"}
                ],
                "operator": "OR"
            }
            order_results = posthog_client.query_events(order_query)
            orders = [{"event": r["event"], "properties": r["properties"]} for r in order_results.get("results", [])]
        
        logging.debug(f"Retrieved sales data for user {user_id}: {len(clicks)} clicks, {len(orders)} orders")
        if posthog_client:
            posthog_client.capture(
                distinct_id=user_id,
                event="view_sales",
                properties={"clicks_count": len(clicks), "orders_count": len(orders)}
            )
        
        return jsonify({"status": "success", "clicks": clicks, "orders": orders}), 200
    except Exception as e:
        logging.error(f"UX Issue - Failed to retrieve sales for user {user_id}: {str(e)}", exc_info=True)
        if posthog_client:
            posthog_client.capture(
                distinct_id=user_id,
                event="view_sales_error",
                properties={"error": f"Server error: {str(e)}"}
            )
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500
# endregion

# region /referrals GET - Self-Auth Endpoint for Referrals Data
@user_settings_bp.route('/referrals', methods=['GET'])
@login_required(["self"], require_all=False)
def get_referrals():
    """
    Queries PostHog for click and order events where the user is source, like Trillian tracking her referral network!
    Permissions: Restricted to merchant or community roles.
    Outputs:
        - Success: JSON {"status": "success", "clicks": [<click_data>], "orders": [<order_data>]}, status 200
        - Errors: JSON with error message, status 500
    """
    try:
        user_id = request.user_id
        clicks = []
        orders = []
        
        if posthog_client:
            # Query clicks where user is source (referrer-focused)
            click_query = {
                "event": "click",
                "properties": [
                    {"key": "source_user_id", "value": user_id, "operator": "exact"}
                ]
            }
            click_results = posthog_client.query_events(click_query)
            clicks = [{"event": r["event"], "properties": r["properties"]} for r in click_results.get("results", [])]
            
            # Query orders where user is source (referrer-focused)
            order_query = {
                "event": "order",
                "properties": [
                    {"key": "source_user_id", "value": user_id, "operator": "exact"}
                ]
            }
            order_results = posthog_client.query_events(order_query)
            orders = [{"event": r["event"], "properties": r["properties"]} for r in order_results.get("results", [])]
        
        logging.debug(f"Retrieved referrals data for user {user_id}: {len(clicks)} clicks, {len(orders)} orders")
        if posthog_client:
            posthog_client.capture(
                distinct_id=user_id,
                event="view_referrals",
                properties={"clicks_count": len(clicks), "orders_count": len(orders)}
            )
        
        return jsonify({"status": "success", "clicks": clicks, "orders": orders}), 200
    except Exception as e:
        logging.error(f"UX Issue - Failed to retrieve referrals for user {user_id}: {str(e)}", exc_info=True)
        if posthog_client:
            posthog_client.capture(
                distinct_id=user_id,
                event="view_referrals_error",
                properties={"error": f"Server error: {str(e)}"}
            )
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500
# endregion

# region /last-login GET - Self-Auth Endpoint for Last Login
@user_settings_bp.route('/last-login', methods=['GET'])
@login_required(["self"], require_all=False)
def get_last_login():
    """
    Queries PostHog for the most recent login event, like Marvin reminding you where you parked your spaceship!
    Permissions: Restricted to merchant or community roles.
    Outputs:
        - Success: JSON {"status": "success", "message": "You last logged in from <ip> on <date>"}, status 200
        - Errors: JSON with error message, status 500
    """
    try:
        user_id = request.user_id
        last_login = None
        
        if posthog_client:
            login_query = {
                "event": "login",
                "properties": [
                    {"key": "user_id", "value": user_id, "operator": "exact"}
                ],
                "order_by": ["-timestamp"]  # Latest first
            }
            login_results = posthog_client.query_events(login_query)
            if login_results.get("results", []):
                last_login = login_results["results"][0]["properties"]
        
        if last_login:
            message = f"You last logged in from {last_login['ip_address']} on {last_login['timestamp']}"
        else:
            message = "No login history found"
        
        logging.debug(f"Retrieved last login for user {user_id}: {message}")
        if posthog_client:
            posthog_client.capture(
                distinct_id=user_id,
                event="view_last_login",
                properties={"has_login": bool(last_login)}
            )
        
        return jsonify({"status": "success", "message": message}), 200
    except Exception as e:
        logging.error(f"UX Issue - Failed to retrieve last login for user {user_id}: {str(e)}", exc_info=True)
        if posthog_client:
            posthog_client.capture(
                distinct_id=user_id,
                event="view_last_login_error",
                properties={"error": f"Server error: {str(e)}"}
            )
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500
# endregion

utility_bp.py
from flask import Blueprint, request, jsonify, current_app, make_response
from utils.auth import login_required, load_users_settings
from utils.helpers import get_system_stats, ping_service, log_activity
import logging
import requests
import os
import markdown
import whois
import json

utility_bp = Blueprint('utility_bp', __name__)

@utility_bp.route('/system/stats', methods=['GET'])
@login_required(["admin"], require_all=True)
def system_stats():
    try:
        # Log request like madeira.py
        request_data = {
            "method": request.method,
            "url": request.full_path,
            "headers": dict(request.headers),
            "ip": request.remote_addr,
            "body": "[NO BODY]"
        }
        log_data = request_data.copy()
        if "Authorization" in log_data["headers"]:
            log_data["headers"]["Authorization"] = "[REDACTED]"
        logging.debug(f"Request: {json.dumps(log_data)}")

        if "admin" not in request.permissions:
            logging.warning(f"Security Issue - Unauthorized system stats access attempt by {request.user_id}")
            return jsonify({"status": "error", "message": "Unauthorized"}), 403

        stats = get_system_stats()
        logging.info(f"System stats retrieved by admin {request.user_id}")
        response_data = {"status": "success", "stats": stats}
        logging.debug(f"Response: {json.dumps(response_data)}")
        return jsonify(response_data), 200
    except Exception as e:
        logging.error(f"UX Issue - Failed to retrieve system stats: {str(e)}", exc_info=True)
        response_data = {"status": "error", "message": "Server error"}
        logging.debug(f"Response: {json.dumps(response_data)}")
        return jsonify(response_data), 500

@utility_bp.route('/ping', methods=['GET'])
@login_required(["admin", "wixpro"], require_all=False)
def ping():
    try:
        request_data = {
            "method": request.method,
            "url": request.full_path,
            "headers": dict(request.headers),
            "ip": request.remote_addr,
            "body": "[NO BODY]"
        }
        log_data = request_data.copy()
        if "Authorization" in log_data["headers"]:
            log_data["headers"]["Authorization"] = "[REDACTED]"
        logging.debug(f"Request: {json.dumps(log_data)}")

        if "admin" not in request.permissions and "wixpro" not in request.permissions:
            logging.warning(f"Security Issue - Unauthorized ping attempt by {request.user_id}")
            return jsonify({"status": "error", "message": "Unauthorized"}), 403

        ping_result = ping_service()
        if ping_result:
            logging.info(f"Ping successful by {request.user_id}")
            response_data = {"status": "success", "message": "Pong!"}
        else:
            logging.error(f"UX Issue - Ping failed by {request.user_id}")
            response_data = {"status": "error", "message": "Service error"}
        logging.debug(f"Response: {json.dumps(response_data)}")
        return jsonify(response_data), 200 if ping_result else 500
    except Exception as e:
        logging.error(f"UX Issue - Failed to ping service: {str(e)}", exc_info=True)
        response_data = {"status": "error", "message": "Service error"}
        logging.debug(f"Response: {json.dumps(response_data)}")
        return jsonify(response_data), 500

@utility_bp.route('/activity/log', methods=['POST'])
@login_required(["admin"], require_all=True)
def log_user_activity():
    try:
        request_data = {
            "method": request.method,
            "url": request.full_path,
            "headers": dict(request.headers),
            "ip": request.remote_addr,
            "body": request.get_json(silent=True) or "[NO BODY]"
        }
        log_data = request_data.copy()
        if "Authorization" in log_data["headers"]:
            log_data["headers"]["Authorization"] = "[REDACTED]"
        logging.debug(f"Request: {json.dumps(log_data)}")

        if "admin" not in request.permissions:
            logging.warning(f"Security Issue - Unauthorized activity log attempt by {request.user_id}")
            return jsonify({"status": "error", "message": "Unauthorized"}), 403

        data = request.get_json()
        if not data or "user_id" not in data or "action" not in data:
            logging.warning(f"UX Issue - Invalid activity log data from {request.user_id}: {json.dumps(data)}")
            return jsonify({"status": "error", "message": "Invalid data"}), 400

        user_id = data["user_id"]
        action = data["action"]
        details = data.get("details", {})
        log_activity(user_id, action, details)
        logging.info(f"Activity logged by admin {request.user_id} for user {user_id}: {action}")
        response_data = {"status": "success", "message": "Activity logged"}
        logging.debug(f"Response: {json.dumps(response_data)}")
        return jsonify(response_data), 201
    except Exception as e:
        logging.error(f"UX Issue - Failed to log activity: {str(e)}", exc_info=True)
        response_data = {"status": "error", "message": "Server error"}
        logging.debug(f"Response: {json.dumps(response_data)}")
        return jsonify(response_data), 500

@utility_bp.route('/send-sms', methods=['POST'])
def send_sms():
    """
    Sends an SMS to a user's phone number looked up by email, publicly accessible for OTP requests.
    Purpose: Centralized SMS sending for public OTP workflows, using email to identify the recipient.
    Inputs: JSON payload:
        - email (str): User's email to look up phone number.
        - message (str): Text message to send.
    Outputs:
        - Success: JSON {"status": "success", "message": "SMS sent"}, status 200
        - Errors:
            - 400: {"status": "error", "message": "email and message are required"}
            - 404: {"status": "error", "message": "User not found"}
            - 400: {"status": "error", "message": "No valid phone number associated with this email"}
            - 500: {"status": "error", "message": "Failed to send SMS: <reason>"}
    """
    try:
        # Log request like madeira.py
        request_data = {
            "method": request.method,
            "url": request.full_path,
            "headers": dict(request.headers),
            "ip": request.remote_addr,
            "body": request.get_json(silent=True) or "[NO BODY]"
        }
        log_data = request_data.copy()
        if "Authorization" in log_data["headers"]:
            log_data["headers"]["Authorization"] = "[REDACTED]"
        logging.debug(f"Request: {json.dumps(log_data)}")

        data = request.get_json()
        if not data or "email" not in data or "message" not in data:
            logging.warning(f"UX Issue - SMS attempt missing email or message: {json.dumps(data)}")
            response_data = {"status": "error", "message": "email and message are required"}
            logging.debug(f"Response: {json.dumps(response_data)}")
            return jsonify(response_data), 400

        email = data["email"].strip().lower()
        message = data["message"].strip()

        # Look up user by email
        users_settings = load_users_settings()
        user_entry = next(((uid, u) for uid, u in users_settings.items() if u.get("email_address", "").lower() == email), None)
        if not user_entry:
            logging.warning(f"UX Issue - SMS failed - Email not found: {email}")
            response_data = {"status": "error", "message": "User not found"}
            logging.debug(f"Response: {json.dumps(response_data)}")
            return jsonify(response_data), 404

        user_id, user = user_entry
        phone_number = user.get("phone_number", "").strip()
        if not phone_number:
            logging.warning(f"UX Issue - SMS failed for {email} - No valid phone number, User ID: {user_id}")
            response_data = {"status": "error", "message": "No valid phone number associated with this email"}
            logging.debug(f"Response: {json.dumps(response_data)}")
            return jsonify(response_data), 400

        logging.debug(f"User found - ID: {user_id}, Phone: {phone_number}")

        # Load TextMagic config
        username = current_app.config.get("TEXTMAGIC_USERNAME")
        api_key = current_app.config.get("TEXTMAGIC_API_KEY")
        if not username or not api_key:
            logging.error("Security Issue - TextMagic credentials not configured")
            response_data = {"status": "error", "message": "Failed to send SMS: TextMagic credentials not configured"}
            logging.debug(f"Response: {json.dumps(response_data)}")
            return jsonify(response_data), 500

        # Send SMS
        url = "https://rest.textmagic.com/api/v2/messages"
        payload = {"text": message, "phones": phone_number}
        headers = {
            "X-TM-Username": username,
            "X-TM-Key": api_key,
            "Content-Type": "application/x-www-form-urlencoded"
        }
        response = requests.post(url, data=payload, headers=headers)

        if response.status_code != 201:
            logging.error(f"UX Issue - Failed to send SMS for {email}, User ID: {user_id}, Response: {response.text}")
            response_data = {"status": "error", "message": f"Failed to send SMS: {response.text}"}
            logging.debug(f"Response: {json.dumps(response_data)}")
            return jsonify(response_data), 500

        logging.info(f"SMS sent successfully for email {email}, User ID: {user_id} to {phone_number}")
        response_data = {"status": "success", "message": "SMS sent"}
        logging.debug(f"Response: {json.dumps(response_data)}")
        return jsonify(response_data), 200
    except Exception as e:
        logging.error(f"UX Issue - SMS sending error for email {email if 'email' in locals() else 'unknown'}: {str(e)}", exc_info=True)
        response_data = {"status": "error", "message": f"Failed to send SMS: {str(e)}"}
        logging.debug(f"Response: {json.dumps(response_data)}")
        return jsonify(response_data), 500

@utility_bp.route('/render-md/<path:full_path>', methods=['GET'])
@login_required(["allauth"], require_all=False)
def render_md(full_path):
    try:
        request_data = {
            "method": request.method,
            "url": request.full_path,
            "headers": dict(request.headers),
            "ip": request.remote_addr,
            "body": "[NO BODY]"
        }
        log_data = request_data.copy()
        if "Authorization" in log_data["headers"]:
            log_data["headers"]["Authorization"] = "[REDACTED]"
        logging.debug(f"Request: {json.dumps(log_data)}")

        segments = full_path.rstrip('/').split('/')
        if not segments or segments == ['']:
            logging.warning(f"UX Issue - Invalid path provided: {full_path}")
            raise ValueError("Invalid path provided")
        if segments[0] == 'static':
            if len(segments) < 2:
                logging.warning(f"UX Issue - No file path provided after 'static': {full_path}")
                raise ValueError("No file path provided after 'static'")
            file_path = '/'.join(segments[1:])
            if not file_path.endswith('.md'):
                logging.warning(f"UX Issue - Only .md files supported: {file_path}")
                raise ValueError("Only .md files are supported")
            static_file = os.path.join(current_app.static_folder, file_path)
            if not os.path.isfile(static_file):
                logging.warning(f"UX Issue - File not found in static folder: {static_file}")
                raise FileNotFoundError("File not found in static folder")
            with open(static_file, 'r', encoding='utf-8') as f:
                md_content = f.read()
        else:
            if len(segments) < 4:
                logging.warning(f"UX Issue - Invalid GitHub path: {full_path}")
                raise ValueError("Invalid GitHub path: Must provide owner/repo/branch/path")
            owner, repo, branch = segments[:3]
            path_segments = segments[3:]
            path = '/'.join(path_segments)
            if not path.endswith('.md'):
                logging.warning(f"UX Issue - Only .md files supported: {path}")
                raise ValueError("Only .md files are supported")
            url = f"https://raw.githubusercontent.com/{owner}/{repo}/{branch}/{path}"
            response = requests.get(url)
            if response.status_code != 200:
                logging.warning(f"UX Issue - File not found on GitHub: {response.status_code}")
                raise FileNotFoundError(f"File not found on GitHub: {response.status_code}")
            md_content = response.text

        html_content = markdown.markdown(md_content, extensions=['tables'])
        status_code = 200
        logging.info(f"Markdown rendered successfully for path {full_path}")
    except ValueError as e:
        status_code = 404
        error_message = str(e)
    except FileNotFoundError as e:
        status_code = 404
        error_message = str(e)
    except requests.RequestException as e:
        status_code = 500
        error_message = "Failed to fetch from GitHub"
        logging.error(f"UX Issue - Failed to fetch Markdown from GitHub: {str(e)}", exc_info=True)
    except Exception as e:
        status_code = 500
        error_message = "An unexpected error occurred"
        logging.error(f"UX Issue - Unexpected error rendering Markdown: {str(e)}", exc_info=True)

    template_path = os.path.join(current_app.static_folder, 'error', f'{status_code}.md')
    if not os.path.exists(template_path):
        logging.error(f"UX Issue - Template for status {status_code} not found")
        response_data = {"status": "error", "message": f"Template for status {status_code} not found"}
        logging.debug(f"Response: {json.dumps(response_data)}")
        return jsonify(response_data), 500

    with open(template_path, 'r', encoding='utf-8') as f:
        template = f.read()

    final_html = template.replace('{content}' if status_code == 200 else '{error_message}', html_content if status_code == 200 else error_message)
    response = make_response(final_html, status_code)
    response.headers['Content-Type'] = 'text/html'
    logging.debug(f"Response: HTML content, Status: {status_code}")
    return response

@utility_bp.route('/check-domain', methods=['GET'])
@login_required(["allauth"], require_all=False)
def check_domain():
    try:
        request_data = {
            "method": request.method,
            "url": request.full_path,
            "headers": dict(request.headers),
            "ip": request.remote_addr,
            "body": "[NO BODY]"
        }
        log_data = request_data.copy()
        if "Authorization" in log_data["headers"]:
            log_data["headers"]["Authorization"] = "[REDACTED]"
        logging.debug(f"Request: {json.dumps(log_data)}")

        domain = request.args.get('domain')
        if not domain:
            logging.warning(f"UX Issue - Domain check missing domain parameter")
            response_data = {"error": "Please provide a domain name"}
            logging.debug(f"Response: {json.dumps(response_data)}")
            return jsonify(response_data), 400

        if not all(c.isalnum() or c in '-.' for c in domain) or '.' not in domain or len(domain.split('.')[-1]) < 2:
            logging.warning(f"UX Issue - Invalid domain name: {domain}")
            response_data = {"error": "Invalid domain name (e.g., mystore.uk)"}
            logging.debug(f"Response: {json.dumps(response_data)}")
            return jsonify(response_data), 400

        w = whois.whois(domain)
        is_available = w.creation_date is None
        logging.info(f"Domain check successful for {domain}: {'available' if is_available else 'taken'}")
        response_data = {"domain": domain, "available": is_available}
        logging.debug(f"Response: {json.dumps(response_data)}")
        return jsonify(response_data), 200
    except Exception as e:
        logging.error(f"UX Issue - Failed to check domain availability: {str(e)}", exc_info=True)
        response_data = {"error": f"Failed to check domain availability: {str(e)}"}
        logging.debug(f"Response: {json.dumps(response_data)}")
        return jsonify(response_data), 500
__init__.py


+ [utils]
+----__init__.py
+----auth.py
+----categories.py
+----config.py
+----data.py
+----helpers.py
+----products.py
+----users.py
+----utils_contents_text.txt

auth.py
from functools import wraps
from flask import request, jsonify, current_app, url_for
import jwt
import datetime
import bcrypt
import string
import random
import logging
from utils.users import load_users_settings, save_users_settings

def login_required(required_permissions, require_all=True):
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            token = request.headers.get("Authorization", "").replace("Bearer ", "")
            if not token:
                logging.warning("Security Issue - No token provided in Authorization header")
                return jsonify({"status": "error", "message": "Token required"}), 401
            try:
                payload = jwt.decode(token, current_app.config['JWT_SECRET_KEY'], algorithms=["HS256"])
                if datetime.datetime.utcnow().timestamp() > payload["exp"]:
                    logging.warning(f"Security Issue - Token expired for user: {payload.get('userId')}")
                    return jsonify({"status": "error", "message": "Token expired"}), 401
                request.user_id = payload["userId"]
                request.permissions = payload.get("permissions", [])
                effective_perms = []
                for perm in required_permissions:
                    if perm == "allauth":
                        effective_perms.extend(["admin", "merchant", "community", "wixpro"])
                    elif perm == "self":
                        user_id = next((v for v in kwargs.values() if isinstance(v, str)), None)
                        if user_id and request.user_id != user_id:
                            effective_perms.append(None)
                        else:
                            effective_perms.append("self")
                    else:
                        effective_perms.append(perm)
                if require_all:
                    if not all(p in request.permissions for p in effective_perms if p and p != "self"):
                        logging.warning(f"Security Issue - Insufficient permissions for user {request.user_id}: required={effective_perms}, has={request.permissions}")
                        return jsonify({"status": "error", "message": f"Insufficient permissions: {effective_perms}"}), 403
                else:
                    if not any(p in request.permissions for p in effective_perms if p and p != "self"):
                        logging.warning(f"Security Issue - Insufficient permissions for user {request.user_id}: required={effective_perms}, has={request.permissions}")
                        return jsonify({"status": "error", "message": f"Insufficient permissions: {effective_perms}"}), 403
                return f(*args, **kwargs)
            except jwt.InvalidTokenError:
                logging.error("Security Issue - Invalid token provided", exc_info=True)
                return jsonify({"status": "error", "message": "Invalid token"}), 401
            except Exception as e:
                logging.error(f"UX Issue - Token processing error: {str(e)}", exc_info=True)
                return jsonify({"status": "error", "message": f"Token error: {str(e)}"}), 500
        return decorated_function
    return decorator

def login_user():
    try:
        data = request.get_json()
        if not data or 'email' not in data or 'password' not in data:
            logging.warning("UX Issue - Login attempt with missing email or password")
            return jsonify({"status": "error", "message": "Email and password required"}), 400
        email = data["email"].strip().lower()
        users_settings = load_users_settings()

        user_id = None
        user = None
        for uid, settings in users_settings.items():
            if settings.get("email_address", "").lower() == email:
                try:
                    if bcrypt.checkpw(data["password"].encode('utf-8'), settings["password"].encode('utf-8')):
                        user_id = uid
                        user = settings
                        break
                except Exception as e:
                    logging.error(f"Security Issue - Password verification failed for email {email}: {str(e)}", exc_info=True)
                    return jsonify({"status": "error", "message": "Invalid password format in user data"}), 500

        if not user_id:
            logging.warning(f"Security Issue - Login failed, no user found for email: {email}")
            return jsonify({"status": "error", "message": "Invalid credentials"}), 401

        permissions = user.get("permissions", [])
        token = jwt.encode(
            {"userId": user_id, "permissions": permissions, "exp": datetime.datetime.utcnow() + datetime.timedelta(hours=1)},
            current_app.config['JWT_SECRET_KEY'],
            algorithm="HS256"
        )
        
        redirect_url = None
        if "admin" in permissions:
            redirect_url = url_for('role_pages.admin')
        elif "merchant" in permissions:
            redirect_url = url_for('role_pages.merchant')
        elif "community" in permissions:
            redirect_url = url_for('role_pages.community')
        elif "wixpro" in permissions:
            redirect_url = url_for('role_pages.wixpro')
        else:
            redirect_url = url_for('home')

        response_data = {
            "status": "success",
            "token": "[REDACTED]",  # Redact JWT in logs
            "userId": user_id,
            "contact_name": user.get("contact_name", "User"),
            "redirect_url": redirect_url
        }
        logging.debug(f"Login response for user {user_id}: {json.dumps(response_data)}")
        return jsonify({"status": "success", "token": token, "userId": user_id, "contact_name": user.get("contact_name", "User"), "redirect_url": redirect_url}), 200
    except Exception as e:
        logging.error(f"UX Issue - Login processing error: {str(e)}", exc_info=True)
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

def signup_user():
    data = request.get_json()
    required_fields = ['signup_type', 'contact_name', 'signup_email', 'signup_password']
    if not all(k in data for k in required_fields):
        logging.warning(f"UX Issue - Signup failed, missing fields: {required_fields}")
        return jsonify({"status": "error", "message": "Signup type, contact name, email, and password are required"}), 400

    signup_type = data['signup_type']
    signup_phone = data.get('signup_phone')
    if signup_type in ['community', 'seller'] and (signup_phone is None or signup_phone == ''):
        logging.warning(f"UX Issue - Signup failed for {signup_type}, phone required")
        return jsonify({"status": "error", "message": "Phone number is required for Community Group and Merchant signups"}), 400

    if signup_phone:
        import re
        if not re.match(r'^\d{10}$', signup_phone):
            logging.warning(f"UX Issue - Signup failed, invalid phone format: {signup_phone}")
            return jsonify({"status": "error", "message": "Phone number must be a 10-digit number with no spaces or special characters"}), 400

    users_settings = load_users_settings()
    if any(u['email_address'] == data['signup_email'] for u in users_settings.values()):
        logging.warning(f"UX Issue - Signup failed, email exists: {data['signup_email']}")
        return jsonify({"status": "error", "message": "Email exists"}), 400

    USERid = generate_code()
    hashed_password = bcrypt.hashpw(data['signup_password'].encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
    users_settings[USERid] = {
        "email_address": data['signup_email'],
        "password": hashed_password,
        "contact_name": data['contact_name'],
        "phone_number": signup_phone,
        "permissions": [data['signup_type']]
    }
    save_users_settings(users_settings)
    logging.debug(f"User signed up - User ID: {USERid}, Type: {signup_type}")
    return jsonify({"status": "success", "message": "Signup successful"}), 201

def generate_token(user_id, permissions):
    payload = {
        "userId": user_id,
        "permissions": permissions,
        "exp": datetime.datetime.utcnow() + datetime.timedelta(hours=24)
    }
    token = jwt.encode(payload, current_app.config['JWT_SECRET_KEY'], algorithm="HS256")
    logging.debug(f"Generated token for user {user_id}: [REDACTED]")
    return token

def generate_code():
    charset = string.digits + string.ascii_uppercase
    code = ''.join(random.choice(charset) for _ in range(7))
    total = sum(charset.index(c) for c in code)
    checksum = charset[total % 36]
    return code + checksum
categories.py
import logging
from utils.config import load_config

# Placeholder AmazonApi class (assuming it’s defined elsewhere or stubbed)
class AmazonApi:
    def __init__(self, access_key, secret_key, associate_tag, country):
        self.access_key = access_key
        self.secret_key = secret_key
        self.associate_tag = associate_tag
        self.country = country
    
    def get_browse_nodes(self, browse_node_ids, resources):
        logging.debug(f"Amazon API call to get browse nodes: {browse_node_ids}")
        return []  # Stub for demo

def get_all_categories(parent_id=None):
    config = load_config()
    if parent_id and all(config.get("amazon_uk", {}).values()):
        try:
            amazon = AmazonApi(
                config["amazon_uk"]["ACCESS_KEY"],
                config["amazon_uk"]["SECRET_KEY"],
                config["amazon_uk"]["ASSOCIATE_TAG"],
                config["amazon_uk"]["COUNTRY"]
            )
            browse_nodes = amazon.get_browse_nodes(browse_node_ids=[parent_id], resources=["BrowseNodes.Children"])
            if not browse_nodes:
                logging.warning(f"UX Issue - No categories returned from Amazon for parent_id: {parent_id}")
            categories = [{"id": node.browse_node_id, "name": node.display_name} for node in browse_nodes]
            return categories
        except Exception as e:
            logging.error(f"Security Issue - Failed to fetch Amazon categories for parent_id {parent_id}: {str(e)}", exc_info=True)
            return []  # Return empty list to maintain UX
    else:
        if parent_id:
            logging.warning(f"UX Issue - Amazon config incomplete for parent_id: {parent_id}")
        categories = [{"id": cat["id"], "name": cat["name"]} for cat in PSEUDO_CATEGORIES]
        return categories

def filter_categories_with_products(category_ids, min_discount_percent):
    logging.debug(f"Filtering categories: {category_ids} with min_discount_percent: {min_discount_percent}")
    try:
        # Placeholder logic (original was a stub)
        if not category_ids:
            logging.warning("UX Issue - No category IDs provided for filtering")
            return []
        filtered = [{"id": cat_id, "name": cat_id} for cat_id in category_ids]  # Stub implementation
        if not filtered:
            logging.warning(f"UX Issue - No categories filtered with min_discount: {min_discount_percent}")
        return filtered
    except Exception as e:
        logging.error(f"UX Issue - Error filtering categories: {str(e)}", exc_info=True)
        return []  # Return empty list to preserve UX
config.py
import json
import os
import logging

CONFIG_FILE = "config.json"

def load_config():
    try:
        if os.path.exists(CONFIG_FILE):
            with open(CONFIG_FILE, 'r') as f:
                config = json.load(f)
                # Redact sensitive data in logs
                log_config = config.copy()
                if "jwt" in log_config and "SECRET_KEY" in log_config["jwt"]:
                    log_config["jwt"]["SECRET_KEY"] = "[REDACTED]"
                logging.debug(f"Loaded config: {json.dumps(log_config)}")
                return config
        else:
            logging.warning("UX Issue - Config file not found, using defaults")
            default_config = {"log_level": "DEBUG", "jwt": {"SECRET_KEY": "your-secret-key"}}
            return default_config
    except json.JSONDecodeError as e:
        logging.error(f"Security Issue - Invalid config file format: {str(e)}", exc_info=True)
        return {"log_level": "DEBUG", "jwt": {"SECRET_KEY": "your-secret-key"}}
    except Exception as e:
        logging.error(f"UX Issue - Failed to load config: {str(e)}", exc_info=True)
        return {"log_level": "DEBUG", "jwt": {"SECRET_KEY": "your-secret-key"}}

def save_config(config):
    try:
        with open(CONFIG_FILE, 'w') as f:
            json.dump(config, f, indent=4)
        # Redact sensitive data in logs
        log_config = config.copy()
        if "jwt" in log_config and "SECRET_KEY" in log_config["jwt"]:
            log_config["jwt"]["SECRET_KEY"] = "[REDACTED]"
        logging.debug(f"Saved config: {json.dumps(log_config)}")
    except Exception as e:
        logging.error(f"UX Issue - Failed to save config: {str(e)}", exc_info=True)
        raise  # Re-raise to alert calling code
data.py
import os
import json
import logging

SITE_REQUEST_DIR = "siterequest"

def load_site_request(user_id):
    file_path = os.path.join(SITE_REQUEST_DIR, user_id)
    try:
        if os.path.exists(file_path):
            with open(file_path, 'r') as f:
                data = json.load(f)
                logging.debug(f"Loaded site request for user {user_id}: {json.dumps(data)}")
                return data
        else:
            logging.warning(f"UX Issue - No site request found for user {user_id}")
            return {}
    except json.JSONDecodeError as e:
        logging.error(f"Security Issue - Invalid site request file format for user {user_id}: {str(e)}", exc_info=True)
        return {}
    except Exception as e:
        logging.error(f"UX Issue - Failed to load site request for user {user_id}: {str(e)}", exc_info=True)
        return {}

def save_site_request(user_id, site_request_data):
    try:
        if not os.path.exists(SITE_REQUEST_DIR):
            os.makedirs(SITE_REQUEST_DIR)
            logging.debug(f"Created site request directory: {SITE_REQUEST_DIR}")
        file_path = os.path.join(SITE_REQUEST_DIR, user_id)
        with open(file_path, 'w') as f:
            json.dump(site_request_data, f, indent=4)
        logging.debug(f"Saved site request for user {user_id}: {json.dumps(site_request_data)}")
    except Exception as e:
        logging.error(f"UX Issue - Failed to save site request for user {user_id}: {str(e)}", exc_info=True)
        raise  # Re-raise to alert calling code
helpers.py
# utils/helpers.py

def get_system_stats():
    """
    Stub for retrieving system statistics.
    Returns a dictionary with placeholder values for CPU, memory, and disk usage.
    """
    return {
        "cpu_usage": 0.0,
        "memory_usage": 0.0,
        "disk_usage": 0.0
    }

def ping_service():
    """
    Stub for checking if a service is reachable.
    Always returns True to simulate a successful ping.
    """
    return True

def log_activity(user_id, action, details=None):
    """
    Stub for logging user activity.
    Prints a message with the user ID, action, and optional details.
    """
    print(f"Logging activity for user {user_id}: {action} - Details: {details}")
products.py
import logging
from utils.config import load_config

# Placeholder AmazonApi class (assuming it’s defined elsewhere or stubbed)
class AmazonApi:
    def __init__(self, access_key, secret_key, associate_tag, country):
        self.access_key = access_key
        self.secret_key = secret_key
        self.associate_tag = associate_tag
        self.country = country
    
    def search_items(self, BrowseNodeId, ItemCount):
        logging.debug(f"Amazon API call to search items - BrowseNodeId: {BrowseNodeId}, ItemCount: {ItemCount}")
        return []  # Stub for demo

def search_all_discounted(category_id):
    config = load_config()
    try:
        if all(config.get("amazon_uk", {}).values()):
            amazon = AmazonApi(
                config["amazon_uk"]["ACCESS_KEY"],
                config["amazon_uk"]["SECRET_KEY"],
                config["amazon_uk"]["ASSOCIATE_TAG"],
                config["amazon_uk"]["COUNTRY"]
            )
            search_result = amazon.search_items(BrowseNodeId=category_id, ItemCount=10)
            if not search_result:
                logging.warning(f"UX Issue - No discounted products found for category_id: {category_id}")
            items = [{"id": item.asin, "title": item.item_info.title.display_value} for item in search_result]
            return items
        else:
            logging.warning(f"UX Issue - Amazon config incomplete for category_id: {category_id}")
            return []
    except Exception as e:
        logging.error(f"Security Issue - Failed to search discounted products for category_id {category_id}: {str(e)}", exc_info=True)
        return []  # Return empty list to maintain UX
users.py
import os
import json
import string
import random
import logging

USERS_SETTINGS_FILE = "users_settings.json"

def load_users_settings():
    try:
        if os.path.exists(USERS_SETTINGS_FILE):
            with open(USERS_SETTINGS_FILE, 'r') as f:
                users_settings = json.load(f)
                # Ensure all user records have a phone_number field
                for user_id, settings in users_settings.items():
                    if 'phone_number' not in settings:
                        settings['phone_number'] = None
                # Redact sensitive data in logs
                log_settings = {uid: {k: "[REDACTED]" if k in ["password"] else v for k, v in s.items()} for uid, s in users_settings.items()}
                logging.debug(f"Loaded users settings: {json.dumps(log_settings)}")
                return users_settings
        else:
            logging.warning("UX Issue - Users settings file not found, returning empty dict")
            return {}
    except json.JSONDecodeError as e:
        logging.error(f"Security Issue - Invalid users settings file format: {str(e)}", exc_info=True)
        return {}
    except Exception as e:
        logging.error(f"UX Issue - Failed to load users settings: {str(e)}", exc_info=True)
        return {}

def save_users_settings(users_settings):
    try:
        with open(USERS_SETTINGS_FILE, 'w') as f:
            json.dump(users_settings, f, indent=4)
        # Redact sensitive data in logs
        log_settings = {uid: {k: "[REDACTED]" if k in ["password"] else v for k, v in s.items()} for uid, s in users_settings.items()}
        logging.debug(f"Saved users settings: {json.dumps(log_settings)}")
    except Exception as e:
        logging.error(f"UX Issue - Failed to save users settings: {str(e)}", exc_info=True)
        raise  # Re-raise to alert calling code

def get_user_settings(user_id):
    try:
        user_settings = load_users_settings().get(user_id, {})
        if not user_settings:
            logging.warning(f"UX Issue - No settings found for user {user_id}")
        # Ensure phone_number is included
        if 'phone_number' not in user_settings:
            user_settings['phone_number'] = None
        # Redact sensitive data in logs
        log_settings = {k: "[REDACTED]" if k in ["password"] else v for k, v in user_settings.items()}
        logging.debug(f"Retrieved settings for user {user_id}: {json.dumps(log_settings)}")
        return user_settings
    except Exception as e:
        logging.error(f"UX Issue - Failed to get settings for user {user_id}: {str(e)}", exc_info=True)
        return {}

def generate_code():
    try:
        charset = string.digits + string.ascii_uppercase
        code = ''.join(random.choice(charset) for _ in range(7))
        total = sum(charset.index(c) for c in code)
        checksum = charset[total % 36]
        result = code + checksum
        logging.debug(f"Generated code for user: {result}")
        return result
    except Exception as e:
        logging.error(f"UX Issue - Failed to generate code: {str(e)}", exc_info=True)
        return ""  # Return empty string as fallback
utils_contents_text.txt
+ [utils]
+----auth.py
+----categories.py
+----config.py
+----data.py
+----products.py
+----users.py
+----utils_contents_text.txt

auth.py

from functools import wraps
from flask import request, jsonify, current_app, url_for
import jwt
import datetime
import bcrypt
import string
import random
import logging
from utils.users import load_users_settings, save_users_settings

def login_required(required_permissions, require_all=True):
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            token = request.headers.get("Authorization", "").replace("Bearer ", "")
            if not token:
                logging.warning("Security Issue - No token provided in Authorization header")
                return jsonify({"status": "error", "message": "Token required"}), 401
            try:
                payload = jwt.decode(token, current_app.config['JWT_SECRET_KEY'], algorithms=["HS256"])
                if datetime.datetime.utcnow().timestamp() > payload["exp"]:
                    logging.warning(f"Security Issue - Token expired for user: {payload.get('userId')}")
                    return jsonify({"status": "error", "message": "Token expired"}), 401
                request.user_id = payload["userId"]
                request.permissions = payload.get("permissions", [])
                effective_perms = []
                for perm in required_permissions:
                    if perm == "allauth":
                        effective_perms.extend(["admin", "merchant", "community", "wixpro"])
                    elif perm == "self":
                        user_id = next((v for v in kwargs.values() if isinstance(v, str)), None)
                        if user_id and request.user_id != user_id:
                            effective_perms.append(None)
                        else:
                            effective_perms.append("self")
                    else:
                        effective_perms.append(perm)
                if require_all:
                    if not all(p in request.permissions for p in effective_perms if p and p != "self"):
                        logging.warning(f"Security Issue - Insufficient permissions for user {request.user_id}: required={effective_perms}, has={request.permissions}")
                        return jsonify({"status": "error", "message": f"Insufficient permissions: {effective_perms}"}), 403
                else:
                    if not any(p in request.permissions for p in effective_perms if p and p != "self"):
                        logging.warning(f"Security Issue - Insufficient permissions for user {request.user_id}: required={effective_perms}, has={request.permissions}")
                        return jsonify({"status": "error", "message": f"Insufficient permissions: {effective_perms}"}), 403
                return f(*args, **kwargs)
            except jwt.InvalidTokenError:
                logging.error("Security Issue - Invalid token provided", exc_info=True)
                return jsonify({"status": "error", "message": "Invalid token"}), 401
            except Exception as e:
                logging.error(f"UX Issue - Token processing error: {str(e)}", exc_info=True)
                return jsonify({"status": "error", "message": f"Token error: {str(e)}"}), 500
        return decorated_function
    return decorator

def login_user():
    try:
        data = request.get_json()
        if not data or 'email' not in data or 'password' not in data:
            logging.warning("UX Issue - Login attempt with missing email or password")
            return jsonify({"status": "error", "message": "Email and password required"}), 400
        email = data["email"].strip().lower()
        users_settings = load_users_settings()

        user_id = None
        user = None
        for uid, settings in users_settings.items():
            if settings.get("email_address", "").lower() == email:
                try:
                    if bcrypt.checkpw(data["password"].encode('utf-8'), settings["password"].encode('utf-8')):
                        user_id = uid
                        user = settings
                        break
                except Exception as e:
                    logging.error(f"Security Issue - Password verification failed for email {email}: {str(e)}", exc_info=True)
                    return jsonify({"status": "error", "message": "Invalid password format in user data"}), 500

        if not user_id:
            logging.warning(f"Security Issue - Login failed, no user found for email: {email}")
            return jsonify({"status": "error", "message": "Invalid credentials"}), 401

        permissions = user.get("permissions", [])
        token = jwt.encode(
            {"userId": user_id, "permissions": permissions, "exp": datetime.datetime.utcnow() + datetime.timedelta(hours=1)},
            current_app.config['JWT_SECRET_KEY'],
            algorithm="HS256"
        )
        
        redirect_url = None
        if "admin" in permissions:
            redirect_url = url_for('role_pages.admin')
        elif "merchant" in permissions:
            redirect_url = url_for('role_pages.merchant')
        elif "community" in permissions:
            redirect_url = url_for('role_pages.community')
        elif "wixpro" in permissions:
            redirect_url = url_for('role_pages.wixpro')
        else:
            redirect_url = url_for('home')

        response_data = {
            "status": "success",
            "token": "[REDACTED]",  # Redact JWT in logs
            "userId": user_id,
            "contact_name": user.get("contact_name", "User"),
            "redirect_url": redirect_url
        }
        logging.debug(f"Login response for user {user_id}: {json.dumps(response_data)}")
        return jsonify({"status": "success", "token": token, "userId": user_id, "contact_name": user.get("contact_name", "User"), "redirect_url": redirect_url}), 200
    except Exception as e:
        logging.error(f"UX Issue - Login processing error: {str(e)}", exc_info=True)
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

def signup_user():
    data = request.get_json()
    required_fields = ['signup_type', 'contact_name', 'signup_email', 'signup_password']
    if not all(k in data for k in required_fields):
        logging.warning(f"UX Issue - Signup failed, missing fields: {required_fields}")
        return jsonify({"status": "error", "message": "Signup type, contact name, email, and password are required"}), 400

    signup_type = data['signup_type']
    signup_phone = data.get('signup_phone')
    if signup_type in ['community', 'seller'] and (signup_phone is None or signup_phone == ''):
        logging.warning(f"UX Issue - Signup failed for {signup_type}, phone required")
        return jsonify({"status": "error", "message": "Phone number is required for Community Group and Merchant signups"}), 400

    if signup_phone:
        import re
        if not re.match(r'^\d{10}$', signup_phone):
            logging.warning(f"UX Issue - Signup failed, invalid phone format: {signup_phone}")
            return jsonify({"status": "error", "message": "Phone number must be a 10-digit number with no spaces or special characters"}), 400

    users_settings = load_users_settings()
    if any(u['email_address'] == data['signup_email'] for u in users_settings.values()):
        logging.warning(f"UX Issue - Signup failed, email exists: {data['signup_email']}")
        return jsonify({"status": "error", "message": "Email exists"}), 400

    USERid = generate_code()
    hashed_password = bcrypt.hashpw(data['signup_password'].encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
    users_settings[USERid] = {
        "email_address": data['signup_email'],
        "password": hashed_password,
        "contact_name": data['contact_name'],
        "phone_number": signup_phone,
        "permissions": [data['signup_type']]
    }
    save_users_settings(users_settings)
    logging.debug(f"User signed up - User ID: {USERid}, Type: {signup_type}")
    return jsonify({"status": "success", "message": "Signup successful"}), 201

def generate_token(user_id, permissions):
    payload = {
        "userId": user_id,
        "permissions": permissions,
        "exp": datetime.datetime.utcnow() + datetime.timedelta(hours=24)
    }
    token = jwt.encode(payload, current_app.config['JWT_SECRET_KEY'], algorithm="HS256")
    logging.debug(f"Generated token for user {user_id}: [REDACTED]")
    return token

def generate_code():
    charset = string.digits + string.ascii_uppercase
    code = ''.join(random.choice(charset) for _ in range(7))
    total = sum(charset.index(c) for c in code)
    checksum = charset[total % 36]
    return code + checksum

categories.py

import logging
from utils.config import load_config

# Placeholder AmazonApi class (assuming it’s defined elsewhere or stubbed)
class AmazonApi:
    def __init__(self, access_key, secret_key, associate_tag, country):
        self.access_key = access_key
        self.secret_key = secret_key
        self.associate_tag = associate_tag
        self.country = country
    
    def get_browse_nodes(self, browse_node_ids, resources):
        logging.debug(f"Amazon API call to get browse nodes: {browse_node_ids}")
        return []  # Stub for demo

PSEUDO_CATEGORIES = [{"id": "1", "name": "Default Category"}]  # Placeholder

def get_all_categories(parent_id=None):
    config = load_config()
    if parent_id and all(config.get("amazon_uk", {}).values()):
        try:
            amazon = AmazonApi(
                config["amazon_uk"]["ACCESS_KEY"],
                config["amazon_uk"]["SECRET_KEY"],
                config["amazon_uk"]["ASSOCIATE_TAG"],
                config["amazon_uk"]["COUNTRY"]
            )
            browse_nodes = amazon.get_browse_nodes(browse_node_ids=[parent_id], resources=["BrowseNodes.Children"])
            if not browse_nodes:
                logging.warning(f"UX Issue - No categories returned from Amazon for parent_id: {parent_id}")
            categories = [{"id": node.browse_node_id, "name": node.display_name} for node in browse_nodes]
            return categories
        except Exception as e:
            logging.error(f"Security Issue - Failed to fetch Amazon categories for parent_id {parent_id}: {str(e)}", exc_info=True)
            return []  # Return empty list to maintain UX
    else:
        if parent_id:
            logging.warning(f"UX Issue - Amazon config incomplete for parent_id: {parent_id}")
        categories = [{"id": cat["id"], "name": cat["name"]} for cat in PSEUDO_CATEGORIES]
        return categories

def filter_categories_with_products(category_ids, min_discount_percent):
    logging.debug(f"Filtering categories: {category_ids} with min_discount_percent: {min_discount_percent}")
    try:
        # Placeholder logic (original was a stub)
        if not category_ids:
            logging.warning("UX Issue - No category IDs provided for filtering")
            return []
        filtered = [{"id": cat_id, "name": cat_id} for cat_id in category_ids]  # Stub implementation
        if not filtered:
            logging.warning(f"UX Issue - No categories filtered with min_discount: {min_discount_percent}")
        return filtered
    except Exception as e:
        logging.error(f"UX Issue - Error filtering categories: {str(e)}", exc_info=True)
        return []  # Return empty list to preserve UX

config.py

import json
import os
import logging

CONFIG_FILE = "config.json"

def load_config():
    try:
        if os.path.exists(CONFIG_FILE):
            with open(CONFIG_FILE, 'r') as f:
                config = json.load(f)
                # Redact sensitive data in logs
                log_config = config.copy()
                if "jwt" in log_config and "SECRET_KEY" in log_config["jwt"]:
                    log_config["jwt"]["SECRET_KEY"] = "[REDACTED]"
                logging.debug(f"Loaded config: {json.dumps(log_config)}")
                return config
        else:
            logging.warning("UX Issue - Config file not found, using defaults")
            default_config = {"log_level": "DEBUG", "jwt": {"SECRET_KEY": "your-secret-key"}}
            return default_config
    except json.JSONDecodeError as e:
        logging.error(f"Security Issue - Invalid config file format: {str(e)}", exc_info=True)
        return {"log_level": "DEBUG", "jwt": {"SECRET_KEY": "your-secret-key"}}
    except Exception as e:
        logging.error(f"UX Issue - Failed to load config: {str(e)}", exc_info=True)
        return {"log_level": "DEBUG", "jwt": {"SECRET_KEY": "your-secret-key"}}

def save_config(config):
    try:
        with open(CONFIG_FILE, 'w') as f:
            json.dump(config, f, indent=4)
        # Redact sensitive data in logs
        log_config = config.copy()
        if "jwt" in log_config and "SECRET_KEY" in log_config["jwt"]:
            log_config["jwt"]["SECRET_KEY"] = "[REDACTED]"
        logging.debug(f"Saved config: {json.dumps(log_config)}")
    except Exception as e:
        logging.error(f"UX Issue - Failed to save config: {str(e)}", exc_info=True)
        raise  # Re-raise to alert calling code

data.py

import os
import json
import logging

SITE_REQUEST_DIR = "siterequest"

def load_site_request(user_id):
    file_path = os.path.join(SITE_REQUEST_DIR, user_id)
    try:
        if os.path.exists(file_path):
            with open(file_path, 'r') as f:
                data = json.load(f)
                logging.debug(f"Loaded site request for user {user_id}: {json.dumps(data)}")
                return data
        else:
            logging.warning(f"UX Issue - No site request found for user {user_id}")
            return {}
    except json.JSONDecodeError as e:
        logging.error(f"Security Issue - Invalid site request file format for user {user_id}: {str(e)}", exc_info=True)
        return {}
    except Exception as e:
        logging.error(f"UX Issue - Failed to load site request for user {user_id}: {str(e)}", exc_info=True)
        return {}

def save_site_request(user_id, site_request_data):
    try:
        if not os.path.exists(SITE_REQUEST_DIR):
            os.makedirs(SITE_REQUEST_DIR)
            logging.debug(f"Created site request directory: {SITE_REQUEST_DIR}")
        file_path = os.path.join(SITE_REQUEST_DIR, user_id)
        with open(file_path, 'w') as f:
            json.dump(site_request_data, f, indent=4)
        logging.debug(f"Saved site request for user {user_id}: {json.dumps(site_request_data)}")
    except Exception as e:
        logging.error(f"UX Issue - Failed to save site request for user {user_id}: {str(e)}", exc_info=True)
        raise  # Re-raise to alert calling code

products.py

import logging
from utils.config import load_config

# Placeholder AmazonApi class (assuming it’s defined elsewhere or stubbed)
class AmazonApi:
    def __init__(self, access_key, secret_key, associate_tag, country):
        self.access_key = access_key
        self.secret_key = secret_key
        self.associate_tag = associate_tag
        self.country = country
    
    def search_items(self, BrowseNodeId, ItemCount):
        logging.debug(f"Amazon API call to search items - BrowseNodeId: {BrowseNodeId}, ItemCount: {ItemCount}")
        return []  # Stub for demo

def search_all_discounted(category_id):
    config = load_config()
    try:
        if all(config.get("amazon_uk", {}).values()):
            amazon = AmazonApi(
                config["amazon_uk"]["ACCESS_KEY"],
                config["amazon_uk"]["SECRET_KEY"],
                config["amazon_uk"]["ASSOCIATE_TAG"],
                config["amazon_uk"]["COUNTRY"]
            )
            search_result = amazon.search_items(BrowseNodeId=category_id, ItemCount=10)
            if not search_result:
                logging.warning(f"UX Issue - No discounted products found for category_id: {category_id}")
            items = [{"id": item.asin, "title": item.item_info.title.display_value} for item in search_result]
            return items
        else:
            logging.warning(f"UX Issue - Amazon config incomplete for category_id: {category_id}")
            return []
    except Exception as e:
        logging.error(f"Security Issue - Failed to search discounted products for category_id {category_id}: {str(e)}", exc_info=True)
        return []  # Return empty list to maintain UX

users.py

import os
import json
import string
import random
import logging

USERS_SETTINGS_FILE = "users_settings.json"

def load_users_settings():
    try:
        if os.path.exists(USERS_SETTINGS_FILE):
            with open(USERS_SETTINGS_FILE, 'r') as f:
                users_settings = json.load(f)
                # Ensure all user records have a phone_number field
                for user_id, settings in users_settings.items():
                    if 'phone_number' not in settings:
                        settings['phone_number'] = None
                # Redact sensitive data in logs
                log_settings = {uid: {k: "[REDACTED]" if k in ["password"] else v for k, v in s.items()} for uid, s in users_settings.items()}
                logging.debug(f"Loaded users settings: {json.dumps(log_settings)}")
                return users_settings
        else:
            logging.warning("UX Issue - Users settings file not found, returning empty dict")
            return {}
    except json.JSONDecodeError as e:
        logging.error(f"Security Issue - Invalid users settings file format: {str(e)}", exc_info=True)
        return {}
    except Exception as e:
        logging.error(f"UX Issue - Failed to load users settings: {str(e)}", exc_info=True)
        return {}

def save_users_settings(users_settings):
    try:
        with open(USERS_SETTINGS_FILE, 'w') as f:
            json.dump(users_settings, f, indent=4)
        # Redact sensitive data in logs
        log_settings = {uid: {k: "[REDACTED]" if k in ["password"] else v for k, v in s.items()} for uid, s in users_settings.items()}
        logging.debug(f"Saved users settings: {json.dumps(log_settings)}")
    except Exception as e:
        logging.error(f"UX Issue - Failed to save users settings: {str(e)}", exc_info=True)
        raise  # Re-raise to alert calling code

def get_user_settings(user_id):
    try:
        user_settings = load_users_settings().get(user_id, {})
        if not user_settings:
            logging.warning(f"UX Issue - No settings found for user {user_id}")
        # Ensure phone_number is included
        if 'phone_number' not in user_settings:
            user_settings['phone_number'] = None
        # Redact sensitive data in logs
        log_settings = {k: "[REDACTED]" if k in ["password"] else v for k, v in user_settings.items()}
        logging.debug(f"Retrieved settings for user {user_id}: {json.dumps(log_settings)}")
        return user_settings
    except Exception as e:
        logging.error(f"UX Issue - Failed to get settings for user {user_id}: {str(e)}", exc_info=True)
        return {}

def generate_code():
    try:
        charset = string.digits + string.ascii_uppercase
        code = ''.join(random.choice(charset) for _ in range(7))
        total = sum(charset.index(c) for c in code)
        checksum = charset[total % 36]
        result = code + checksum
        logging.debug(f"Generated code for user: {result}")
        return result
    except Exception as e:
        logging.error(f"UX Issue - Failed to generate code: {str(e)}", exc_info=True)
        return ""  # Return empty string as fallback

utils_contents_text.txt

+ [utils]
+----auth.py
+----categories.py
+----config.py
+----data.py
+----products.py
+----users.py
+----utils_contents_text.txt

auth.py

from functools import wraps
from flask import request, jsonify, current_app, url_for
import jwt
import datetime
import bcrypt
import string
import random
import logging
from utils.users import load_users_settings, save_users_settings

def login_required(required_permissions, require_all=True):
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            token = request.headers.get("Authorization", "").replace("Bearer ", "")
            if not token:
                logging.warning("Security Issue - No token provided in Authorization header")
                return jsonify({"status": "error", "message": "Token required"}), 401
            try:
                payload = jwt.decode(token, current_app.config['JWT_SECRET_KEY'], algorithms=["HS256"])
                if datetime.datetime.utcnow().timestamp() > payload["exp"]:
                    logging.warning(f"Security Issue - Token expired for user: {payload.get('userId')}")
                    return jsonify({"status": "error", "message": "Token expired"}), 401
                request.user_id = payload["userId"]
                request.permissions = payload.get("permissions", [])
                effective_perms = []
                for perm in required_permissions:
                    if perm == "allauth":
                        effective_perms.extend(["admin", "merchant", "community", "wixpro"])
                    elif perm == "self":
                        user_id = next((v for v in kwargs.values() if isinstance(v, str)), None)
                        if user_id and request.user_id != user_id:
                            effective_perms.append(None)
                        else:
                            effective_perms.append("self")
                    else:
                        effective_perms.append(perm)
                if require_all:
                    if not all(p in request.permissions for p in effective_perms if p and p != "self"):
                        logging.warning(f"Security Issue - Insufficient permissions for user {request.user_id}: required={effective_perms}, has={request.permissions}")
                        return jsonify({"status": "error", "message": f"Insufficient permissions: {effective_perms}"}), 403
                else:
                    if not any(p in request.permissions for p in effective_perms if p and p != "self"):
                        logging.warning(f"Security Issue - Insufficient permissions for user {request.user_id}: required={effective_perms}, has={request.permissions}")
                        return jsonify({"status": "error", "message": f"Insufficient permissions: {effective_perms}"}), 403
                return f(*args, **kwargs)
            except jwt.InvalidTokenError:
                logging.error("Security Issue - Invalid token provided", exc_info=True)
                return jsonify({"status": "error", "message": "Invalid token"}), 401
            except Exception as e:
                logging.error(f"UX Issue - Token processing error: {str(e)}", exc_info=True)
                return jsonify({"status": "error", "message": f"Token error: {str(e)}"}), 500
        return decorated_function
    return decorator

def login_user():
    try:
        data = request.get_json()
        if not data or 'email' not in data or 'password' not in data:
            logging.warning("UX Issue - Login attempt with missing email or password")
            return jsonify({"status": "error", "message": "Email and password required"}), 400
        email = data["email"].strip().lower()
        users_settings = load_users_settings()

        user_id = None
        user = None
        for uid, settings in users_settings.items():
            if settings.get("email_address", "").lower() == email:
                try:
                    if bcrypt.checkpw(data["password"].encode('utf-8'), settings["password"].encode('utf-8')):
                        user_id = uid
                        user = settings
                        break
                except Exception as e:
                    logging.error(f"Security Issue - Password verification failed for email {email}: {str(e)}", exc_info=True)
                    return jsonify({"status": "error", "message": "Invalid password format in user data"}), 500

        if not user_id:
            logging.warning(f"Security Issue - Login failed, no user found for email: {email}")
            return jsonify({"status": "error", "message": "Invalid credentials"}), 401

        permissions = user.get("permissions", [])
        token = jwt.encode(
            {"userId": user_id, "permissions": permissions, "exp": datetime.datetime.utcnow() + datetime.timedelta(hours=1)},
            current_app.config['JWT_SECRET_KEY'],
            algorithm="HS256"
        )
        
        redirect_url = None
        if "admin" in permissions:
            redirect_url = url_for('role_pages.admin')
        elif "merchant" in permissions:
            redirect_url = url_for('role_pages.merchant')
        elif "community" in permissions:
            redirect_url = url_for('role_pages.community')
        elif "wixpro" in permissions:
            redirect_url = url_for('role_pages.wixpro')
        else:
            redirect_url = url_for('home')

        response_data = {
            "status": "success",
            "token": "[REDACTED]",  # Redact JWT in logs
            "userId": user_id,
            "contact_name": user.get("contact_name", "User"),
            "redirect_url": redirect_url
        }
        logging.debug(f"Login response for user {user_id}: {json.dumps(response_data)}")
        return jsonify({"status": "success", "token": token, "userId": user_id, "contact_name": user.get("contact_name", "User"), "redirect_url": redirect_url}), 200
    except Exception as e:
        logging.error(f"UX Issue - Login processing error: {str(e)}", exc_info=True)
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

def signup_user():
    data = request.get_json()
    required_fields = ['signup_type', 'contact_name', 'signup_email', 'signup_password']
    if not all(k in data for k in required_fields):
        logging.warning(f"UX Issue - Signup failed, missing fields: {required_fields}")
        return jsonify({"status": "error", "message": "Signup type, contact name, email, and password are required"}), 400

    signup_type = data['signup_type']
    signup_phone = data.get('signup_phone')
    if signup_type in ['community', 'seller'] and (signup_phone is None or signup_phone == ''):
        logging.warning(f"UX Issue - Signup failed for {signup_type}, phone required")
        return jsonify({"status": "error", "message": "Phone number is required for Community Group and Merchant signups"}), 400

    if signup_phone:
        import re
        if not re.match(r'^\d{10}$', signup_phone):
            logging.warning(f"UX Issue - Signup failed, invalid phone format: {signup_phone}")
            return jsonify({"status": "error", "message": "Phone number must be a 10-digit number with no spaces or special characters"}), 400

    users_settings = load_users_settings()
    if any(u['email_address'] == data['signup_email'] for u in users_settings.values()):
        logging.warning(f"UX Issue - Signup failed, email exists: {data['signup_email']}")
        return jsonify({"status": "error", "message": "Email exists"}), 400

    USERid = generate_code()
    hashed_password = bcrypt.hashpw(data['signup_password'].encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
    users_settings[USERid] = {
        "email_address": data['signup_email'],
        "password": hashed_password,
        "contact_name": data['contact_name'],
        "phone_number": signup_phone,
        "permissions": [data['signup_type']]
    }
    save_users_settings(users_settings)
    logging.debug(f"User signed up - User ID: {USERid}, Type: {signup_type}")
    return jsonify({"status": "success", "message": "Signup successful"}), 201

def generate_token(user_id, permissions):
    payload = {
        "userId": user_id,
        "permissions": permissions,
        "exp": datetime.datetime.utcnow() + datetime.timedelta(hours=24)
    }
    token = jwt.encode(payload, current_app.config['JWT_SECRET_KEY'], algorithm="HS256")
    logging.debug(f"Generated token for user {user_id}: [REDACTED]")
    return token

def generate_code():
    charset = string.digits + string.ascii_uppercase
    code = ''.join(random.choice(charset) for _ in range(7))
    total = sum(charset.index(c) for c in code)
    checksum = charset[total % 36]
    return code + checksum

categories.py

import logging
from utils.config import load_config

# Placeholder AmazonApi class (assuming it’s defined elsewhere or stubbed)
class AmazonApi:
    def __init__(self, access_key, secret_key, associate_tag, country):
        self.access_key = access_key
        self.secret_key = secret_key
        self.associate_tag = associate_tag
        self.country = country
    
    def get_browse_nodes(self, browse_node_ids, resources):
        logging.debug(f"Amazon API call to get browse nodes: {browse_node_ids}")
        return []  # Stub for demo

PSEUDO_CATEGORIES = [{"id": "1", "name": "Default Category"}]  # Placeholder

def get_all_categories(parent_id=None):
    config = load_config()
    if parent_id and all(config.get("amazon_uk", {}).values()):
        try:
            amazon = AmazonApi(
                config["amazon_uk"]["ACCESS_KEY"],
                config["amazon_uk"]["SECRET_KEY"],
                config["amazon_uk"]["ASSOCIATE_TAG"],
                config["amazon_uk"]["COUNTRY"]
            )
            browse_nodes = amazon.get_browse_nodes(browse_node_ids=[parent_id], resources=["BrowseNodes.Children"])
            if not browse_nodes:
                logging.warning(f"UX Issue - No categories returned from Amazon for parent_id: {parent_id}")
            categories = [{"id": node.browse_node_id, "name": node.display_name} for node in browse_nodes]
            return categories
        except Exception as e:
            logging.error(f"Security Issue - Failed to fetch Amazon categories for parent_id {parent_id}: {str(e)}", exc_info=True)
            return []  # Return empty list to maintain UX
    else:
        if parent_id:
            logging.warning(f"UX Issue - Amazon config incomplete for parent_id: {parent_id}")
        categories = [{"id": cat["id"], "name": cat["name"]} for cat in PSEUDO_CATEGORIES]
        return categories

def filter_categories_with_products(category_ids, min_discount_percent):
    logging.debug(f"Filtering categories: {category_ids} with min_discount_percent: {min_discount_percent}")
    try:
        # Placeholder logic (original was a stub)
        if not category_ids:
            logging.warning("UX Issue - No category IDs provided for filtering")
            return []
        filtered = [{"id": cat_id, "name": cat_id} for cat_id in category_ids]  # Stub implementation
        if not filtered:
            logging.warning(f"UX Issue - No categories filtered with min_discount: {min_discount_percent}")
        return filtered
    except Exception as e:
        logging.error(f"UX Issue - Error filtering categories: {str(e)}", exc_info=True)
        return []  # Return empty list to preserve UX

config.py

import json
import os
import logging

CONFIG_FILE = "config.json"

def load_config():
    try:
        if os.path.exists(CONFIG_FILE):
            with open(CONFIG_FILE, 'r') as f:
                config = json.load(f)
                # Redact sensitive data in logs
                log_config = config.copy()
                if "jwt" in log_config and "SECRET_KEY" in log_config["jwt"]:
                    log_config["jwt"]["SECRET_KEY"] = "[REDACTED]"
                logging.debug(f"Loaded config: {json.dumps(log_config)}")
                return config
        else:
            logging.warning("UX Issue - Config file not found, using defaults")
            default_config = {"log_level": "DEBUG", "jwt": {"SECRET_KEY": "your-secret-key"}}
            return default_config
    except json.JSONDecodeError as e:
        logging.error(f"Security Issue - Invalid config file format: {str(e)}", exc_info=True)
        return {"log_level": "DEBUG", "jwt": {"SECRET_KEY": "your-secret-key"}}
    except Exception as e:
        logging.error(f"UX Issue - Failed to load config: {str(e)}", exc_info=True)
        return {"log_level": "DEBUG", "jwt": {"SECRET_KEY": "your-secret-key"}}

def save_config(config):
    try:
        with open(CONFIG_FILE, 'w') as f:
            json.dump(config, f, indent=4)
        # Redact sensitive data in logs
        log_config = config.copy()
        if "jwt" in log_config and "SECRET_KEY" in log_config["jwt"]:
            log_config["jwt"]["SECRET_KEY"] = "[REDACTED]"
        logging.debug(f"Saved config: {json.dumps(log_config)}")
    except Exception as e:
        logging.error(f"UX Issue - Failed to save config: {str(e)}", exc_info=True)
        raise  # Re-raise to alert calling code

data.py

import os
import json
import logging

SITE_REQUEST_DIR = "siterequest"

def load_site_request(user_id):
    file_path = os.path.join(SITE_REQUEST_DIR, user_id)
    try:
        if os.path.exists(file_path):
            with open(file_path, 'r') as f:
                data = json.load(f)
                logging.debug(f"Loaded site request for user {user_id}: {json.dumps(data)}")
                return data
        else:
            logging.warning(f"UX Issue - No site request found for user {user_id}")
            return {}
    except json.JSONDecodeError as e:
        logging.error(f"Security Issue - Invalid site request file format for user {user_id}: {str(e)}", exc_info=True)
        return {}
    except Exception as e:
        logging.error(f"UX Issue - Failed to load site request for user {user_id}: {str(e)}", exc_info=True)
        return {}

def save_site_request(user_id, site_request_data):
    try:
        if not os.path.exists(SITE_REQUEST_DIR):
            os.makedirs(SITE_REQUEST_DIR)
            logging.debug(f"Created site request directory: {SITE_REQUEST_DIR}")
        file_path = os.path.join(SITE_REQUEST_DIR, user_id)
        with open(file_path, 'w') as f:
            json.dump(site_request_data, f, indent=4)
        logging.debug(f"Saved site request for user {user_id}: {json.dumps(site_request_data)}")
    except Exception as e:
        logging.error(f"UX Issue - Failed to save site request for user {user_id}: {str(e)}", exc_info=True)
        raise  # Re-raise to alert calling code

products.py

import logging
from utils.config import load_config

# Placeholder AmazonApi class (assuming it’s defined elsewhere or stubbed)
class AmazonApi:
    def __init__(self, access_key, secret_key, associate_tag, country):
        self.access_key = access_key
        self.secret_key = secret_key
        self.associate_tag = associate_tag
        self.country = country
    
    def search_items(self, BrowseNodeId, ItemCount):
        logging.debug(f"Amazon API call to search items - BrowseNodeId: {BrowseNodeId}, ItemCount: {ItemCount}")
        return []  # Stub for demo

def search_all_discounted(category_id):
    config = load_config()
    try:
        if all(config.get("amazon_uk", {}).values()):
            amazon = AmazonApi(
                config["amazon_uk"]["ACCESS_KEY"],
                config["amazon_uk"]["SECRET_KEY"],
                config["amazon_uk"]["ASSOCIATE_TAG"],
                config["amazon_uk"]["COUNTRY"]
            )
            search_result = amazon.search_items(BrowseNodeId=category_id, ItemCount=10)
            if not search_result:
                logging.warning(f"UX Issue - No discounted products found for category_id: {category_id}")
            items = [{"id": item.asin, "title": item.item_info.title.display_value} for item in search_result]
            return items
        else:
            logging.warning(f"UX Issue - Amazon config incomplete for category_id: {category_id}")
            return []
    except Exception as e:
        logging.error(f"Security Issue - Failed to search discounted products for category_id {category_id}: {str(e)}", exc_info=True)
        return []  # Return empty list to maintain UX

users.py

import os
import json
import string
import random
import logging

USERS_SETTINGS_FILE = "users_settings.json"

def load_users_settings():
    try:
        if os.path.exists(USERS_SETTINGS_FILE):
            with open(USERS_SETTINGS_FILE, 'r') as f:
                users_settings = json.load(f)
                # Ensure all user records have a phone_number field
                for user_id, settings in users_settings.items():
                    if 'phone_number' not in settings:
                        settings['phone_number'] = None
                # Redact sensitive data in logs
                log_settings = {uid: {k: "[REDACTED]" if k in ["password"] else v for k, v in s.items()} for uid, s in users_settings.items()}
                logging.debug(f"Loaded users settings: {json.dumps(log_settings)}")
                return users_settings
        else:
            logging.warning("UX Issue - Users settings file not found, returning empty dict")
            return {}
    except json.JSONDecodeError as e:
        logging.error(f"Security Issue - Invalid users settings file format: {str(e)}", exc_info=True)
        return {}
    except Exception as e:
        logging.error(f"UX Issue - Failed to load users settings: {str(e)}", exc_info=True)
        return {}

def save_users_settings(users_settings):
    try:
        with open(USERS_SETTINGS_FILE, 'w') as f:
            json.dump(users_settings, f, indent=4)
        # Redact sensitive data in logs
        log_settings = {uid: {k: "[REDACTED]" if k in ["password"] else v for k, v in s.items()} for uid, s in users_settings.items()}
        logging.debug(f"Saved users settings: {json.dumps(log_settings)}")
    except Exception as e:
        logging.error(f"UX Issue - Failed to save users settings: {str(e)}", exc_info=True)
        raise  # Re-raise to alert calling code

def get_user_settings(user_id):
    try:
        user_settings = load_users_settings().get(user_id, {})
        if not user_settings:
            logging.warning(f"UX Issue - No settings found for user {user_id}")
        # Ensure phone_number is included
        if 'phone_number' not in user_settings:
            user_settings['phone_number'] = None
        # Redact sensitive data in logs
        log_settings = {k: "[REDACTED]" if k in ["password"] else v for k, v in user_settings.items()}
        logging.debug(f"Retrieved settings for user {user_id}: {json.dumps(log_settings)}")
        return user_settings
    except Exception as e:
        logging.error(f"UX Issue - Failed to get settings for user {user_id}: {str(e)}", exc_info=True)
        return {}

def generate_code():
    try:
        charset = string.digits + string.ascii_uppercase
        code = ''.join(random.choice(charset) for _ in range(7))
        total = sum(charset.index(c) for c in code)
        checksum = charset[total % 36]
        result = code + checksum
        logging.debug(f"Generated code for user: {result}")
        return result
    except Exception as e:
        logging.error(f"UX Issue - Failed to generate code: {str(e)}", exc_info=True)
        return ""  # Return empty string as fallback

utils_contents_text.txt

+ [utils]
+----auth.py
+----categories.py
+----config.py
+----data.py
+----products.py
+----users.py
+----utils_contents_text.txt

auth.py

from functools import wraps
from flask import request, jsonify, current_app, url_for
import jwt
import datetime
import bcrypt
import string
import random
import logging
from utils.users import load_users_settings, save_users_settings

def login_required(required_permissions, require_all=True):
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            token = request.headers.get("Authorization", "").replace("Bearer ", "")
            if not token:
                logging.warning("Security Issue - No token provided in Authorization header")
                return jsonify({"status": "error", "message": "Token required"}), 401
            try:
                payload = jwt.decode(token, current_app.config['JWT_SECRET_KEY'], algorithms=["HS256"])
                if datetime.datetime.utcnow().timestamp() > payload["exp"]:
                    logging.warning(f"Security Issue - Token expired for user: {payload.get('userId')}")
                    return jsonify({"status": "error", "message": "Token expired"}), 401
                request.user_id = payload["userId"]
                request.permissions = payload.get("permissions", [])
                effective_perms = []
                for perm in required_permissions:
                    if perm == "allauth":
                        effective_perms.extend(["admin", "merchant", "community", "wixpro"])
                    elif perm == "self":
                        user_id = next((v for v in kwargs.values() if isinstance(v, str)), None)
                        if user_id and request.user_id != user_id:
                            effective_perms.append(None)
                        else:
                            effective_perms.append("self")
                    else:
                        effective_perms.append(perm)
                if require_all:
                    if not all(p in request.permissions for p in effective_perms if p and p != "self"):
                        logging.warning(f"Security Issue - Insufficient permissions for user {request.user_id}: required={effective_perms}, has={request.permissions}")
                        return jsonify({"status": "error", "message": f"Insufficient permissions: {effective_perms}"}), 403
                else:
                    if not any(p in request.permissions for p in effective_perms if p and p != "self"):
                        logging.warning(f"Security Issue - Insufficient permissions for user {request.user_id}: required={effective_perms}, has={request.permissions}")
                        return jsonify({"status": "error", "message": f"Insufficient permissions: {effective_perms}"}), 403
                return f(*args, **kwargs)
            except jwt.InvalidTokenError:
                logging.error("Security Issue - Invalid token provided", exc_info=True)
                return jsonify({"status": "error", "message": "Invalid token"}), 401
            except Exception as e:
                logging.error(f"UX Issue - Token processing error: {str(e)}", exc_info=True)
                return jsonify({"status": "error", "message": f"Token error: {str(e)}"}), 500
        return decorated_function
    return decorator

def login_user():
    try:
        data = request.get_json()
        if not data or 'email' not in data or 'password' not in data:
            logging.warning("UX Issue - Login attempt with missing email or password")
            return jsonify({"status": "error", "message": "Email and password required"}), 400
        email = data["email"].strip().lower()
        users_settings = load_users_settings()

        user_id = None
        user = None
        for uid, settings in users_settings.items():
            if settings.get("email_address", "").lower() == email:
                try:
                    if bcrypt.checkpw(data["password"].encode('utf-8'), settings["password"].encode('utf-8')):
                        user_id = uid
                        user = settings
                        break
                except Exception as e:
                    logging.error(f"Security Issue - Password verification failed for email {email}: {str(e)}", exc_info=True)
                    return jsonify({"status": "error", "message": "Invalid password format in user data"}), 500

        if not user_id:
            logging.warning(f"Security Issue - Login failed, no user found for email: {email}")
            return jsonify({"status": "error", "message": "Invalid credentials"}), 401

        permissions = user.get("permissions", [])
        token = jwt.encode(
            {"userId": user_id, "permissions": permissions, "exp": datetime.datetime.utcnow() + datetime.timedelta(hours=1)},
            current_app.config['JWT_SECRET_KEY'],
            algorithm="HS256"
        )
        
        redirect_url = None
        if "admin" in permissions:
            redirect_url = url_for('role_pages.admin')
        elif "merchant" in permissions:
            redirect_url = url_for('role_pages.merchant')
        elif "community" in permissions:
            redirect_url = url_for('role_pages.community')
        elif "wixpro" in permissions:
            redirect_url = url_for('role_pages.wixpro')
        else:
            redirect_url = url_for('home')

        response_data = {
            "status": "success",
            "token": "[REDACTED]",  # Redact JWT in logs
            "userId": user_id,
            "contact_name": user.get("contact_name", "User"),
            "redirect_url": redirect_url
        }
        logging.debug(f"Login response for user {user_id}: {json.dumps(response_data)}")
        return jsonify({"status": "success", "token": token, "userId": user_id, "contact_name": user.get("contact_name", "User"), "redirect_url": redirect_url}), 200
    except Exception as e:
        logging.error(f"UX Issue - Login processing error: {str(e)}", exc_info=True)
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

def signup_user():
    data = request.get_json()
    required_fields = ['signup_type', 'contact_name', 'signup_email', 'signup_password']
    if not all(k in data for k in required_fields):
        logging.warning(f"UX Issue - Signup failed, missing fields: {required_fields}")
        return jsonify({"status": "error", "message": "Signup type, contact name, email, and password are required"}), 400

    signup_type = data['signup_type']
    signup_phone = data.get('signup_phone')
    if signup_type in ['community', 'seller'] and (signup_phone is None or signup_phone == ''):
        logging.warning(f"UX Issue - Signup failed for {signup_type}, phone required")
        return jsonify({"status": "error", "message": "Phone number is required for Community Group and Merchant signups"}), 400

    if signup_phone:
        import re
        if not re.match(r'^\d{10}$', signup_phone):
            logging.warning(f"UX Issue - Signup failed, invalid phone format: {signup_phone}")
            return jsonify({"status": "error", "message": "Phone number must be a 10-digit number with no spaces or special characters"}), 400

    users_settings = load_users_settings()
    if any(u['email_address'] == data['signup_email'] for u in users_settings.values()):
        logging.warning(f"UX Issue - Signup failed, email exists: {data['signup_email']}")
        return jsonify({"status": "error", "message": "Email exists"}), 400

    USERid = generate_code()
    hashed_password = bcrypt.hashpw(data['signup_password'].encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
    users_settings[USERid] = {
        "email_address": data['signup_email'],
        "password": hashed_password,
        "contact_name": data['contact_name'],
        "phone_number": signup_phone,
        "permissions": [data['signup_type']]
    }
    save_users_settings(users_settings)
    logging.debug(f"User signed up - User ID: {USERid}, Type: {signup_type}")
    return jsonify({"status": "success", "message": "Signup successful"}), 201

def generate_token(user_id, permissions):
    payload = {
        "userId": user_id,
        "permissions": permissions,
        "exp": datetime.datetime.utcnow() + datetime.timedelta(hours=24)
    }
    token = jwt.encode(payload, current_app.config['JWT_SECRET_KEY'], algorithm="HS256")
    logging.debug(f"Generated token for user {user_id}: [REDACTED]")
    return token

def generate_code():
    charset = string.digits + string.ascii_uppercase
    code = ''.join(random.choice(charset) for _ in range(7))
    total = sum(charset.index(c) for c in code)
    checksum = charset[total % 36]
    return code + checksum

categories.py

import logging
from utils.config import load_config

# Placeholder AmazonApi class (assuming it’s defined elsewhere or stubbed)
class AmazonApi:
    def __init__(self, access_key, secret_key, associate_tag, country):
        self.access_key = access_key
        self.secret_key = secret_key
        self.associate_tag = associate_tag
        self.country = country
    
    def get_browse_nodes(self, browse_node_ids, resources):
        logging.debug(f"Amazon API call to get browse nodes: {browse_node_ids}")
        return []  # Stub for demo

PSEUDO_CATEGORIES = [{"id": "1", "name": "Default Category"}]  # Placeholder

def get_all_categories(parent_id=None):
    config = load_config()
    if parent_id and all(config.get("amazon_uk", {}).values()):
        try:
            amazon = AmazonApi(
                config["amazon_uk"]["ACCESS_KEY"],
                config["amazon_uk"]["SECRET_KEY"],
                config["amazon_uk"]["ASSOCIATE_TAG"],
                config["amazon_uk"]["COUNTRY"]
            )
            browse_nodes = amazon.get_browse_nodes(browse_node_ids=[parent_id], resources=["BrowseNodes.Children"])
            if not browse_nodes:
                logging.warning(f"UX Issue - No categories returned from Amazon for parent_id: {parent_id}")
            categories = [{"id": node.browse_node_id, "name": node.display_name} for node in browse_nodes]
            return categories
        except Exception as e:
            logging.error(f"Security Issue - Failed to fetch Amazon categories for parent_id {parent_id}: {str(e)}", exc_info=True)
            return []  # Return empty list to maintain UX
    else:
        if parent_id:
            logging.warning(f"UX Issue - Amazon config incomplete for parent_id: {parent_id}")
        categories = [{"id": cat["id"], "name": cat["name"]} for cat in PSEUDO_CATEGORIES]
        return categories

def filter_categories_with_products(category_ids, min_discount_percent):
    logging.debug(f"Filtering categories: {category_ids} with min_discount_percent: {min_discount_percent}")
    try:
        # Placeholder logic (original was a stub)
        if not category_ids:
            logging.warning("UX Issue - No category IDs provided for filtering")
            return []
        filtered = [{"id": cat_id, "name": cat_id} for cat_id in category_ids]  # Stub implementation
        if not filtered:
            logging.warning(f"UX Issue - No categories filtered with min_discount: {min_discount_percent}")
        return filtered
    except Exception as e:
        logging.error(f"UX Issue - Error filtering categories: {str(e)}", exc_info=True)
        return []  # Return empty list to preserve UX

config.py

import json
import os
import logging

CONFIG_FILE = "config.json"

def load_config():
    try:
        if os.path.exists(CONFIG_FILE):
            with open(CONFIG_FILE, 'r') as f:
                config = json.load(f)
                # Redact sensitive data in logs
                log_config = config.copy()
                if "jwt" in log_config and "SECRET_KEY" in log_config["jwt"]:
                    log_config["jwt"]["SECRET_KEY"] = "[REDACTED]"
                logging.debug(f"Loaded config: {json.dumps(log_config)}")
                return config
        else:
            logging.warning("UX Issue - Config file not found, using defaults")
            default_config = {"log_level": "DEBUG", "jwt": {"SECRET_KEY": "your-secret-key"}}
            return default_config
    except json.JSONDecodeError as e:
        logging.error(f"Security Issue - Invalid config file format: {str(e)}", exc_info=True)
        return {"log_level": "DEBUG", "jwt": {"SECRET_KEY": "your-secret-key"}}
    except Exception as e:
        logging.error(f"UX Issue - Failed to load config: {str(e)}", exc_info=True)
        return {"log_level": "DEBUG", "jwt": {"SECRET_KEY": "your-secret-key"}}

def save_config(config):
    try:
        with open(CONFIG_FILE, 'w') as f:
            json.dump(config, f, indent=4)
        # Redact sensitive data in logs
        log_config = config.copy()
        if "jwt" in log_config and "SECRET_KEY" in log_config["jwt"]:
            log_config["jwt"]["SECRET_KEY"] = "[REDACTED]"
        logging.debug(f"Saved config: {json.dumps(log_config)}")
    except Exception as e:
        logging.error(f"UX Issue - Failed to save config: {str(e)}", exc_info=True)
        raise  # Re-raise to alert calling code

data.py

import os
import json
import logging

SITE_REQUEST_DIR = "siterequest"

def load_site_request(user_id):
    file_path = os.path.join(SITE_REQUEST_DIR, user_id)
    try:
        if os.path.exists(file_path):
            with open(file_path, 'r') as f:
                data = json.load(f)
                logging.debug(f"Loaded site request for user {user_id}: {json.dumps(data)}")
                return data
        else:
            logging.warning(f"UX Issue - No site request found for user {user_id}")
            return {}
    except json.JSONDecodeError as e:
        logging.error(f"Security Issue - Invalid site request file format for user {user_id}: {str(e)}", exc_info=True)
        return {}
    except Exception as e:
        logging.error(f"UX Issue - Failed to load site request for user {user_id}: {str(e)}", exc_info=True)
        return {}

def save_site_request(user_id, site_request_data):
    try:
        if not os.path.exists(SITE_REQUEST_DIR):
            os.makedirs(SITE_REQUEST_DIR)
            logging.debug(f"Created site request directory: {SITE_REQUEST_DIR}")
        file_path = os.path.join(SITE_REQUEST_DIR, user_id)
        with open(file_path, 'w') as f:
            json.dump(site_request_data, f, indent=4)
        logging.debug(f"Saved site request for user {user_id}: {json.dumps(site_request_data)}")
    except Exception as e:
        logging.error(f"UX Issue - Failed to save site request for user {user_id}: {str(e)}", exc_info=True)
        raise  # Re-raise to alert calling code

products.py

import logging
from utils.config import load_config

# Placeholder AmazonApi class (assuming it’s defined elsewhere or stubbed)
class AmazonApi:
    def __init__(self, access_key, secret_key, associate_tag, country):
        self.access_key = access_key
        self.secret_key = secret_key
        self.associate_tag = associate_tag
        self.country = country
    
    def search_items(self, BrowseNodeId, ItemCount):
        logging.debug(f"Amazon API call to search items - BrowseNodeId: {BrowseNodeId}, ItemCount: {ItemCount}")
        return []  # Stub for demo

def search_all_discounted(category_id):
    config = load_config()
    try:
        if all(config.get("amazon_uk", {}).values()):
            amazon = AmazonApi(
                config["amazon_uk"]["ACCESS_KEY"],
                config["amazon_uk"]["SECRET_KEY"],
                config["amazon_uk"]["ASSOCIATE_TAG"],
                config["amazon_uk"]["COUNTRY"]
            )
            search_result = amazon.search_items(BrowseNodeId=category_id, ItemCount=10)
            if not search_result:
                logging.warning(f"UX Issue - No discounted products found for category_id: {category_id}")
            items = [{"id": item.asin, "title": item.item_info.title.display_value} for item in search_result]
            return items
        else:
            logging.warning(f"UX Issue - Amazon config incomplete for category_id: {category_id}")
            return []
    except Exception as e:
        logging.error(f"Security Issue - Failed to search discounted products for category_id {category_id}: {str(e)}", exc_info=True)
        return []  # Return empty list to maintain UX

users.py

import os
import json
import string
import random
import logging

USERS_SETTINGS_FILE = "users_settings.json"

def load_users_settings():
    try:
        if os.path.exists(USERS_SETTINGS_FILE):
            with open(USERS_SETTINGS_FILE, 'r') as f:
                users_settings = json.load(f)
                # Ensure all user records have a phone_number field
                for user_id, settings in users_settings.items():
                    if 'phone_number' not in settings:
                        settings['phone_number'] = None
                # Redact sensitive data in logs
                log_settings = {uid: {k: "[REDACTED]" if k in ["password"] else v for k, v in s.items()} for uid, s in users_settings.items()}
                logging.debug(f"Loaded users settings: {json.dumps(log_settings)}")
                return users_settings
        else:
            logging.warning("UX Issue - Users settings file not found, returning empty dict")
            return {}
    except json.JSONDecodeError as e:
        logging.error(f"Security Issue - Invalid users settings file format: {str(e)}", exc_info=True)
        return {}
    except Exception as e:
        logging.error(f"UX Issue - Failed to load users settings: {str(e)}", exc_info=True)
        return {}

def save_users_settings(users_settings):
    try:
        with open(USERS_SETTINGS_FILE, 'w') as f:
            json.dump(users_settings, f, indent=4)
        # Redact sensitive data in logs
        log_settings = {uid: {k: "[REDACTED]" if k in ["password"] else v for k, v in s.items()} for uid, s in users_settings.items()}
        logging.debug(f"Saved users settings: {json.dumps(log_settings)}")
    except Exception as e:
        logging.error(f"UX Issue - Failed to save users settings: {str(e)}", exc_info=True)
        raise  # Re-raise to alert calling code

def get_user_settings(user_id):
    try:
        user_settings = load_users_settings().get(user_id, {})
        if not user_settings:
            logging.warning(f"UX Issue - No settings found for user {user_id}")
        # Ensure phone_number is included
        if 'phone_number' not in user_settings:
            user_settings['phone_number'] = None
        # Redact sensitive data in logs
        log_settings = {k: "[REDACTED]" if k in ["password"] else v for k, v in user_settings.items()}
        logging.debug(f"Retrieved settings for user {user_id}: {json.dumps(log_settings)}")
        return user_settings
    except Exception as e:
        logging.error(f"UX Issue - Failed to get settings for user {user_id}: {str(e)}", exc_info=True)
        return {}

def generate_code():
    try:
        charset = string.digits + string.ascii_uppercase
        code = ''.join(random.choice(charset) for _ in range(7))
        total = sum(charset.index(c) for c in code)
        checksum = charset[total % 36]
        result = code + checksum
        logging.debug(f"Generated code for user: {result}")
        return result
    except Exception as e:
        logging.error(f"UX Issue - Failed to generate code: {str(e)}", exc_info=True)
        return ""  # Return empty string as fallback

utils_contents_text.txt

+ [utils]
+----auth.py
+----categories.py
+----config.py
+----data.py
+----products.py
+----users.py

auth.py

from functools import wraps
from flask import request, jsonify, current_app, url_for
import jwt
import datetime
import bcrypt
import string
import random
import logging
from utils.users import load_users_settings, save_users_settings

def login_required(required_permissions, require_all=True):
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            token = request.headers.get("Authorization", "").replace("Bearer ", "")
            if not token:
                logging.warning("Security Issue - No token provided in Authorization header")
                return jsonify({"status": "error", "message": "Token required"}), 401
            try:
                payload = jwt.decode(token, current_app.config['JWT_SECRET_KEY'], algorithms=["HS256"])
                if datetime.datetime.utcnow().timestamp() > payload["exp"]:
                    logging.warning(f"Security Issue - Token expired for user: {payload.get('userId')}")
                    return jsonify({"status": "error", "message": "Token expired"}), 401
                request.user_id = payload["userId"]
                request.permissions = payload.get("permissions", [])
                effective_perms = []
                for perm in required_permissions:
                    if perm == "allauth":
                        effective_perms.extend(["admin", "merchant", "community", "wixpro"])
                    elif perm == "self":
                        user_id = next((v for v in kwargs.values() if isinstance(v, str)), None)
                        if user_id and request.user_id != user_id:
                            effective_perms.append(None)
                        else:
                            effective_perms.append("self")
                    else:
                        effective_perms.append(perm)
                if require_all:
                    if not all(p in request.permissions for p in effective_perms if p and p != "self"):
                        logging.warning(f"Security Issue - Insufficient permissions for user {request.user_id}: required={effective_perms}, has={request.permissions}")
                        return jsonify({"status": "error", "message": f"Insufficient permissions: {effective_perms}"}), 403
                else:
                    if not any(p in request.permissions for p in effective_perms if p and p != "self"):
                        logging.warning(f"Security Issue - Insufficient permissions for user {request.user_id}: required={effective_perms}, has={request.permissions}")
                        return jsonify({"status": "error", "message": f"Insufficient permissions: {effective_perms}"}), 403
                return f(*args, **kwargs)
            except jwt.InvalidTokenError:
                logging.error("Security Issue - Invalid token provided", exc_info=True)
                return jsonify({"status": "error", "message": "Invalid token"}), 401
            except Exception as e:
                logging.error(f"UX Issue - Token processing error: {str(e)}", exc_info=True)
                return jsonify({"status": "error", "message": f"Token error: {str(e)}"}), 500
        return decorated_function
    return decorator

def login_user():
    try:
        data = request.get_json()
        if not data or 'email' not in data or 'password' not in data:
            logging.warning("UX Issue - Login attempt with missing email or password")
            return jsonify({"status": "error", "message": "Email and password required"}), 400
        email = data["email"].strip().lower()
        users_settings = load_users_settings()

        user_id = None
        user = None
        for uid, settings in users_settings.items():
            if settings.get("email_address", "").lower() == email:
                try:
                    if bcrypt.checkpw(data["password"].encode('utf-8'), settings["password"].encode('utf-8')):
                        user_id = uid
                        user = settings
                        break
                except Exception as e:
                    logging.error(f"Security Issue - Password verification failed for email {email}: {str(e)}", exc_info=True)
                    return jsonify({"status": "error", "message": "Invalid password format in user data"}), 500

        if not user_id:
            logging.warning(f"Security Issue - Login failed, no user found for email: {email}")
            return jsonify({"status": "error", "message": "Invalid credentials"}), 401

        permissions = user.get("permissions", [])
        token = jwt.encode(
            {"userId": user_id, "permissions": permissions, "exp": datetime.datetime.utcnow() + datetime.timedelta(hours=1)},
            current_app.config['JWT_SECRET_KEY'],
            algorithm="HS256"
        )
        
        redirect_url = None
        if "admin" in permissions:
            redirect_url = url_for('role_pages.admin')
        elif "merchant" in permissions:
            redirect_url = url_for('role_pages.merchant')
        elif "community" in permissions:
            redirect_url = url_for('role_pages.community')
        elif "wixpro" in permissions:
            redirect_url = url_for('role_pages.wixpro')
        else:
            redirect_url = url_for('home')

        response_data = {
            "status": "success",
            "token": "[REDACTED]",  # Redact JWT in logs
            "userId": user_id,
            "contact_name": user.get("contact_name", "User"),
            "redirect_url": redirect_url
        }
        logging.debug(f"Login response for user {user_id}: {json.dumps(response_data)}")
        return jsonify({"status": "success", "token": token, "userId": user_id, "contact_name": user.get("contact_name", "User"), "redirect_url": redirect_url}), 200
    except Exception as e:
        logging.error(f"UX Issue - Login processing error: {str(e)}", exc_info=True)
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

def signup_user():
    data = request.get_json()
    required_fields = ['signup_type', 'contact_name', 'signup_email', 'signup_password']
    if not all(k in data for k in required_fields):
        logging.warning(f"UX Issue - Signup failed, missing fields: {required_fields}")
        return jsonify({"status": "error", "message": "Signup type, contact name, email, and password are required"}), 400

    signup_type = data['signup_type']
    signup_phone = data.get('signup_phone')
    if signup_type in ['community', 'seller'] and (signup_phone is None or signup_phone == ''):
        logging.warning(f"UX Issue - Signup failed for {signup_type}, phone required")
        return jsonify({"status": "error", "message": "Phone number is required for Community Group and Merchant signups"}), 400

    if signup_phone:
        import re
        if not re.match(r'^\d{10}$', signup_phone):
            logging.warning(f"UX Issue - Signup failed, invalid phone format: {signup_phone}")
            return jsonify({"status": "error", "message": "Phone number must be a 10-digit number with no spaces or special characters"}), 400

    users_settings = load_users_settings()
    if any(u['email_address'] == data['signup_email'] for u in users_settings.values()):
        logging.warning(f"UX Issue - Signup failed, email exists: {data['signup_email']}")
        return jsonify({"status": "error", "message": "Email exists"}), 400

    USERid = generate_code()
    hashed_password = bcrypt.hashpw(data['signup_password'].encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
    users_settings[USERid] = {
        "email_address": data['signup_email'],
        "password": hashed_password,
        "contact_name": data['contact_name'],
        "phone_number": signup_phone,
        "permissions": [data['signup_type']]
    }
    save_users_settings(users_settings)
    logging.debug(f"User signed up - User ID: {USERid}, Type: {signup_type}")
    return jsonify({"status": "success", "message": "Signup successful"}), 201

def generate_token(user_id, permissions):
    payload = {
        "userId": user_id,
        "permissions": permissions,
        "exp": datetime.datetime.utcnow() + datetime.timedelta(hours=24)
    }
    token = jwt.encode(payload, current_app.config['JWT_SECRET_KEY'], algorithm="HS256")
    logging.debug(f"Generated token for user {user_id}: [REDACTED]")
    return token

def generate_code():
    charset = string.digits + string.ascii_uppercase
    code = ''.join(random.choice(charset) for _ in range(7))
    total = sum(charset.index(c) for c in code)
    checksum = charset[total % 36]
    return code + checksum

categories.py

import logging
from utils.config import load_config

# Placeholder AmazonApi class (assuming it’s defined elsewhere or stubbed)
class AmazonApi:
    def __init__(self, access_key, secret_key, associate_tag, country):
        self.access_key = access_key
        self.secret_key = secret_key
        self.associate_tag = associate_tag
        self.country = country
    
    def get_browse_nodes(self, browse_node_ids, resources):
        logging.debug(f"Amazon API call to get browse nodes: {browse_node_ids}")
        return []  # Stub for demo

PSEUDO_CATEGORIES = [{"id": "1", "name": "Default Category"}]  # Placeholder

def get_all_categories(parent_id=None):
    config = load_config()
    if parent_id and all(config.get("amazon_uk", {}).values()):
        try:
            amazon = AmazonApi(
                config["amazon_uk"]["ACCESS_KEY"],
                config["amazon_uk"]["SECRET_KEY"],
                config["amazon_uk"]["ASSOCIATE_TAG"],
                config["amazon_uk"]["COUNTRY"]
            )
            browse_nodes = amazon.get_browse_nodes(browse_node_ids=[parent_id], resources=["BrowseNodes.Children"])
            if not browse_nodes:
                logging.warning(f"UX Issue - No categories returned from Amazon for parent_id: {parent_id}")
            categories = [{"id": node.browse_node_id, "name": node.display_name} for node in browse_nodes]
            return categories
        except Exception as e:
            logging.error(f"Security Issue - Failed to fetch Amazon categories for parent_id {parent_id}: {str(e)}", exc_info=True)
            return []  # Return empty list to maintain UX
    else:
        if parent_id:
            logging.warning(f"UX Issue - Amazon config incomplete for parent_id: {parent_id}")
        categories = [{"id": cat["id"], "name": cat["name"]} for cat in PSEUDO_CATEGORIES]
        return categories

def filter_categories_with_products(category_ids, min_discount_percent):
    logging.debug(f"Filtering categories: {category_ids} with min_discount_percent: {min_discount_percent}")
    try:
        # Placeholder logic (original was a stub)
        if not category_ids:
            logging.warning("UX Issue - No category IDs provided for filtering")
            return []
        filtered = [{"id": cat_id, "name": cat_id} for cat_id in category_ids]  # Stub implementation
        if not filtered:
            logging.warning(f"UX Issue - No categories filtered with min_discount: {min_discount_percent}")
        return filtered
    except Exception as e:
        logging.error(f"UX Issue - Error filtering categories: {str(e)}", exc_info=True)
        return []  # Return empty list to preserve UX

config.py

import json
import os
import logging

CONFIG_FILE = "config.json"

def load_config():
    try:
        if os.path.exists(CONFIG_FILE):
            with open(CONFIG_FILE, 'r') as f:
                config = json.load(f)
                # Redact sensitive data in logs
                log_config = config.copy()
                if "jwt" in log_config and "SECRET_KEY" in log_config["jwt"]:
                    log_config["jwt"]["SECRET_KEY"] = "[REDACTED]"
                logging.debug(f"Loaded config: {json.dumps(log_config)}")
                return config
        else:
            logging.warning("UX Issue - Config file not found, using defaults")
            default_config = {"log_level": "DEBUG", "jwt": {"SECRET_KEY": "your-secret-key"}}
            return default_config
    except json.JSONDecodeError as e:
        logging.error(f"Security Issue - Invalid config file format: {str(e)}", exc_info=True)
        return {"log_level": "DEBUG", "jwt": {"SECRET_KEY": "your-secret-key"}}
    except Exception as e:
        logging.error(f"UX Issue - Failed to load config: {str(e)}", exc_info=True)
        return {"log_level": "DEBUG", "jwt": {"SECRET_KEY": "your-secret-key"}}

def save_config(config):
    try:
        with open(CONFIG_FILE, 'w') as f:
            json.dump(config, f, indent=4)
        # Redact sensitive data in logs
        log_config = config.copy()
        if "jwt" in log_config and "SECRET_KEY" in log_config["jwt"]:
            log_config["jwt"]["SECRET_KEY"] = "[REDACTED]"
        logging.debug(f"Saved config: {json.dumps(log_config)}")
    except Exception as e:
        logging.error(f"UX Issue - Failed to save config: {str(e)}", exc_info=True)
        raise  # Re-raise to alert calling code

data.py

import os
import json
import logging

SITE_REQUEST_DIR = "siterequest"

def load_site_request(user_id):
    file_path = os.path.join(SITE_REQUEST_DIR, user_id)
    try:
        if os.path.exists(file_path):
            with open(file_path, 'r') as f:
                data = json.load(f)
                logging.debug(f"Loaded site request for user {user_id}: {json.dumps(data)}")
                return data
        else:
            logging.warning(f"UX Issue - No site request found for user {user_id}")
            return {}
    except json.JSONDecodeError as e:
        logging.error(f"Security Issue - Invalid site request file format for user {user_id}: {str(e)}", exc_info=True)
        return {}
    except Exception as e:
        logging.error(f"UX Issue - Failed to load site request for user {user_id}: {str(e)}", exc_info=True)
        return {}

def save_site_request(user_id, site_request_data):
    try:
        if not os.path.exists(SITE_REQUEST_DIR):
            os.makedirs(SITE_REQUEST_DIR)
            logging.debug(f"Created site request directory: {SITE_REQUEST_DIR}")
        file_path = os.path.join(SITE_REQUEST_DIR, user_id)
        with open(file_path, 'w') as f:
            json.dump(site_request_data, f, indent=4)
        logging.debug(f"Saved site request for user {user_id}: {json.dumps(site_request_data)}")
    except Exception as e:
        logging.error(f"UX Issue - Failed to save site request for user {user_id}: {str(e)}", exc_info=True)
        raise  # Re-raise to alert calling code

products.py

import logging
from utils.config import load_config

# Placeholder AmazonApi class (assuming it’s defined elsewhere or stubbed)
class AmazonApi:
    def __init__(self, access_key, secret_key, associate_tag, country):
        self.access_key = access_key
        self.secret_key = secret_key
        self.associate_tag = associate_tag
        self.country = country
    
    def search_items(self, BrowseNodeId, ItemCount):
        logging.debug(f"Amazon API call to search items - BrowseNodeId: {BrowseNodeId}, ItemCount: {ItemCount}")
        return []  # Stub for demo

def search_all_discounted(category_id):
    config = load_config()
    try:
        if all(config.get("amazon_uk", {}).values()):
            amazon = AmazonApi(
                config["amazon_uk"]["ACCESS_KEY"],
                config["amazon_uk"]["SECRET_KEY"],
                config["amazon_uk"]["ASSOCIATE_TAG"],
                config["amazon_uk"]["COUNTRY"]
            )
            search_result = amazon.search_items(BrowseNodeId=category_id, ItemCount=10)
            if not search_result:
                logging.warning(f"UX Issue - No discounted products found for category_id: {category_id}")
            items = [{"id": item.asin, "title": item.item_info.title.display_value} for item in search_result]
            return items
        else:
            logging.warning(f"UX Issue - Amazon config incomplete for category_id: {category_id}")
            return []
    except Exception as e:
        logging.error(f"Security Issue - Failed to search discounted products for category_id {category_id}: {str(e)}", exc_info=True)
        return []  # Return empty list to maintain UX

users.py

import os
import json
import string
import random
import logging

USERS_SETTINGS_FILE = "users_settings.json"

def load_users_settings():
    try:
        if os.path.exists(USERS_SETTINGS_FILE):
            with open(USERS_SETTINGS_FILE, 'r') as f:
                users_settings = json.load(f)
                # Ensure all user records have a phone_number field
                for user_id, settings in users_settings.items():
                    if 'phone_number' not in settings:
                        settings['phone_number'] = None
                # Redact sensitive data in logs
                log_settings = {uid: {k: "[REDACTED]" if k in ["password"] else v for k, v in s.items()} for uid, s in users_settings.items()}
                logging.debug(f"Loaded users settings: {json.dumps(log_settings)}")
                return users_settings
        else:
            logging.warning("UX Issue - Users settings file not found, returning empty dict")
            return {}
    except json.JSONDecodeError as e:
        logging.error(f"Security Issue - Invalid users settings file format: {str(e)}", exc_info=True)
        return {}
    except Exception as e:
        logging.error(f"UX Issue - Failed to load users settings: {str(e)}", exc_info=True)
        return {}

def save_users_settings(users_settings):
    try:
        with open(USERS_SETTINGS_FILE, 'w') as f:
            json.dump(users_settings, f, indent=4)
        # Redact sensitive data in logs
        log_settings = {uid: {k: "[REDACTED]" if k in ["password"] else v for k, v in s.items()} for uid, s in users_settings.items()}
        logging.debug(f"Saved users settings: {json.dumps(log_settings)}")
    except Exception as e:
        logging.error(f"UX Issue - Failed to save users settings: {str(e)}", exc_info=True)
        raise  # Re-raise to alert calling code

def get_user_settings(user_id):
    try:
        user_settings = load_users_settings().get(user_id, {})
        if not user_settings:
            logging.warning(f"UX Issue - No settings found for user {user_id}")
        # Ensure phone_number is included
        if 'phone_number' not in user_settings:
            user_settings['phone_number'] = None
        # Redact sensitive data in logs
        log_settings = {k: "[REDACTED]" if k in ["password"] else v for k, v in user_settings.items()}
        logging.debug(f"Retrieved settings for user {user_id}: {json.dumps(log_settings)}")
        return user_settings
    except Exception as e:
        logging.error(f"UX Issue - Failed to get settings for user {user_id}: {str(e)}", exc_info=True)
        return {}

def generate_code():
    try:
        charset = string.digits + string.ascii_uppercase
        code = ''.join(random.choice(charset) for _ in range(7))
        total = sum(charset.index(c) for c in code)
        checksum = charset[total % 36]
        result = code + checksum
        logging.debug(f"Generated code for user: {result}")
        return result
    except Exception as e:
        logging.error(f"UX Issue - Failed to generate code: {str(e)}", exc_info=True)
        return ""  # Return empty string as fallback








__init__.py


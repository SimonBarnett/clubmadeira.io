+ [js]
+----admin-page.js
+----category-management.js
+----common.js
+----community-page.js
+----merchant-page.js
+----page-load.js
+----partner-page.js
+----site-auth.js
+----site-navigation.js
+----site-request.js
+----user-management.js

admin-page.js
function initializeAdmin(pageType) {
    console.log('initializeAdmin - Initializing admin page with type: ' + pageType);
    const token = localStorage.getItem('authToken');
    if (!token) {
        console.error('initializeAdmin - No token found, redirecting to /');
        window.location.href = '/';
        return;
    }
    const decoded = decodeJWT(token); // Add permission check for robustness
    if (!decoded || !decoded.permissions || !decoded.permissions.includes('admin')) {
        console.error('initializeAdmin - Invalid token or no admin permission, redirecting to /');
        toastr.error('Permission denied: Admin access required');
        window.location.href = '/';
        return;
    }

    // Load initial content
    loadBranding(pageType, 'brandingContent');
    setupNavigation();
    showSection('welcome');
    loadInitialData();
    setupEventListeners();

    // Call shared "Change Password" logic
    if (typeof setupChangePassword === 'function') {
        setupChangePassword();
        console.log('initializeAdmin - Change Password logic initialized');
    } else {
        console.error('initializeAdmin - setupChangePassword function not found');
    }

    // Ensure loading overlay is hidden
    hideLoadingOverlay();
    console.log('Admin page initialized');
}

function setupNavigation() {
    console.log('setupNavigation - Setting up navigation');
    // Delegate to site-navigation.js's initializeNavigation
    if (typeof window.siteNavigation?.initializeNavigation === 'function') {
        window.siteNavigation.initializeNavigation();
    } else {
        console.warn('setupNavigation - window.siteNavigation.initializeNavigation not found, using fallback');
        // Fallback logic
        document.querySelectorAll('.menu button[data-section]').forEach(button => {
            button.addEventListener('click', function() {
                const sectionId = this.getAttribute('data-section');
                const submenuId = this.getAttribute('data-submenu');
                if (submenuId) {
                    const submenu = document.getElementById(submenuId);
                    const caret = this.querySelector('.caret');
                    if (submenu && caret) {
                        if (submenu.style.display === 'block') {
                            submenu.style.display = 'none';
                            caret.classList.remove('fa-caret-down');
                            caret.classList.add('fa-caret-right');
                        } else {
                            submenu.style.display = 'block';
                            caret.classList.remove('fa-caret-right');
                            caret.classList.add('fa-caret-down');
                        }
                    }
                }
            });
        });
    }
}

function loadInitialData() {
    console.log('loadInitialData - Loading initial data');
    authenticatedFetch(`${window.apiUrl}/deals`)
        .then(response => {
            if (!response.ok) throw new Error('Failed to fetch deals');
            return response.json();
        })
        .then(data => {
            console.log('loadInitialData - Deals fetched:', data);
            // Placeholder for deal list population
        })
        .catch(error => {
            console.error('loadInitialData - Error:', error);
            toastr.error('Failed to load deal listings');
        });
}

function setupEventListeners() {
    const saveSettingsButton = document.querySelector('button[data-action="saveSettings"]');
    if (saveSettingsButton) {
        saveSettingsButton.addEventListener('click', function() {
            const userId = document.getElementById('userId')?.value || '';
            const contactName = document.getElementById('contactName')?.value || '';
            const websiteUrl = document.getElementById('websiteUrl')?.value || '';
            const emailAddress = document.getElementById('emailAddress')?.value || '';

            console.log('setupEventListeners - Saving settings for user:', userId);
            authenticatedFetch(`${window.apiUrl}/settings`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ userId, contactName, websiteUrl, emailAddress })
            })
            .then(response => {
                if (!response.ok) throw new Error('Failed to save settings');
                return response.json();
            })
            .then(data => {
                console.log('setupEventListeners - Settings saved:', data);
                toastr.success('Settings updated successfully');
            })
            .catch(error => {
                console.error('setupEventListeners - Error saving settings:', error);
                toastr.error('Failed to save settings');
            });
        });
    } else {
        console.warn('setupEventListeners - Save settings button not found');
    }
}

// Export for use in other scripts
window.initializeAdmin = initializeAdmin;
window.loadInitialData = loadInitialData;
window.setupEventListeners = setupEventListeners;
// Removed: window.setupNavigation = setupNavigation;
category-management.js
// category-management.js
// Purpose: Manages treeview functionality for displaying and editing nested category information (used in community.html and admin.html).

// Creates a treeview node for category display with configurable behavior.
function createTreeNode(category, level = 0, isAdmin = false, savedCategories = []) {
    console.log('createTreeNode - Creating node - Category:', JSON.stringify(category), 'Level:', level, 'IsAdmin:', isAdmin);
    const li = document.createElement('li');
    const nodeDiv = document.createElement('div');
    nodeDiv.className = 'node';

    const toggle = document.createElement('span');
    toggle.className = 'toggle';
    toggle.setAttribute('data-id', category.id);
    toggle.textContent = '+'; // Default to '+' assuming subcategories may exist
    toggle.addEventListener('click', () => toggleSubcategories(category.id, toggle));

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.value = category.id;
    if (isAdmin) {
        checkbox.addEventListener('change', () => handleCategorySelection(category.id, checkbox));
    } else {
        checkbox.checked = savedCategories.includes(category.id.toString());
    }

    const span = document.createElement('span');
    span.textContent = `${category.name} (${category.id})`;

    nodeDiv.appendChild(toggle);
    nodeDiv.appendChild(checkbox);
    nodeDiv.appendChild(span);
    li.appendChild(nodeDiv);

    const subUl = document.createElement('ul');
    subUl.className = 'subcategories';
    li.appendChild(subUl);

    console.log('createTreeNode - Node created - Category ID:', category.id);
    return li;
}

// Loads category data for treeview rendering, with options for admin or community context.
async function loadCategories(userId = null, isAdmin = false) {
    console.log('loadCategories - Starting category load - UserID:', userId, 'IsAdmin:', isAdmin);
    let savedCategories = [];
    try {
        console.log('loadCategories - Fetching categories via authenticatedFetch');
        const startTime = Date.now();

        // Load user's saved categories if not admin
        if (!isAdmin && userId) {
            const userResponse = await authenticatedFetch(`${window.apiUrl}/${userId}/mycategories`);
            if (!userResponse.ok) throw new Error(`Failed to fetch user categories: ${userResponse.status}`);
            const userData = await userResponse.json();
            savedCategories = userData.categories || [];
            console.log('loadCategories - Saved categories fetched - Count:', savedCategories.length);
        }

        // Load all categories
        const response = await authenticatedFetch(`${window.apiUrl}/categories`);
        if (!response.ok) throw new Error(`Failed to fetch categories: ${response.status}`);
        const data = await response.json();
        const duration = Date.now() - startTime;
        console.log('loadCategories - Categories fetched - Count:', data.categories?.length, 'Duration:', `${duration}ms`);

        const treeElement = document.getElementById('categoryTree');
        if (!treeElement) {
            console.error('loadCategories - Tree element not found - ID: categoryTree');
            return;
        }
        treeElement.innerHTML = '';
        const ul = document.createElement('ul');

        // Filter top-level categories for community, show all for admin
        const categoriesToRender = isAdmin ? data.categories : data.categories.filter(cat => !cat.parent_id);
        console.log('loadCategories - Categories to render - Count:', categoriesToRender.length);

        categoriesToRender.forEach(category => {
            const node = createTreeNode(category, 0, isAdmin, savedCategories);
            ul.appendChild(node);
        });
        treeElement.appendChild(ul);

        // Reattach listeners for community context
        if (!isAdmin) attachEventListeners();

        console.log('loadCategories - Treeview rendered successfully');
        toastr.success('Categories loaded successfully');
    } catch (error) {
        console.error('loadCategories - Error loading categories - Error:', error.message, 'Stack:', error.stack);
        toastr.error('Failed to load categories');
    }
    console.log('loadCategories - Category load completed');
}

// Toggles visibility of subcategories in treeview and loads them dynamically if needed.
async function toggleSubcategories(categoryId, toggle) {
    console.log('toggleSubcategories - Toggling subcategories - Category ID:', categoryId);
    const li = toggle.closest('li');
    const subUl = li.querySelector('.subcategories');

    if (!subUl) {
        console.error('toggleSubcategories - Subcategories element not found - Category ID:', categoryId);
        return;
    }

    if (subUl.classList.contains('open')) {
        subUl.classList.remove('open');
        toggle.textContent = '+';
        console.log('toggleSubcategories - Subcategories closed - ID:', categoryId);
    } else {
        if (subUl.children.length === 0) {
            try {
                console.log('toggleSubcategories - Fetching subcategories - Parent ID:', categoryId);
                const response = await authenticatedFetch(`${window.apiUrl}/categories?parent_id=${categoryId}`);
                if (!response.ok) throw new Error(`Failed to fetch subcategories: ${response.status}`);
                const data = await response.json();

                if (data.categories && data.categories.length > 0) {
                    data.categories.forEach(cat => {
                        const node = createTreeNode(cat, 1); // Level 1 for subcategories
                        subUl.appendChild(node);
                    });
                    console.log('toggleSubcategories - Subcategories loaded - Count:', data.categories.length, 'Parent ID:', categoryId);
                    toastr.success(`Subcategories for ${categoryId} loaded successfully`);
                } else {
                    toggle.textContent = ' '; // No subcategories
                    console.log('toggleSubcategories - No subcategories found - Parent ID:', categoryId);
                    toastr.info(`No subcategories for ${categoryId}`);
                    return;
                }
            } catch (error) {
                console.error('toggleSubcategories - Error loading subcategories - Error:', error.message, 'Stack:', error.stack);
                toastr.error(`Error loading subcategories: ${error.message}`);
                toggle.textContent = ' ';
                return;
            }
        }
        subUl.classList.add('open');
        toggle.textContent = '-';
        console.log('toggleSubcategories - Subcategories opened - ID:', categoryId);
    }
    console.log('toggleSubcategories - Toggle completed');
}

// Saves updated category structure from treeview (community context).
async function saveCategories(userId) {
    console.log('saveCategories - Starting category save - UserID:', userId);
    if (!userId) {
        console.error('saveCategories - User ID not provided');
        toastr.error('User ID not found in session');
        return;
    }

    const checkedCategories = Array.from(document.querySelectorAll('#categoryTree input[type="checkbox"]:checked')).map(cb => cb.value);
    console.log('saveCategories - Checked categories - Count:', checkedCategories.length, 'Values:', checkedCategories);

    try {
        console.log('saveCategories - Sending categories via authenticatedFetch - URL:', `${window.apiUrl}/${userId}/mycategories`);
        const startTime = Date.now();
        const response = await authenticatedFetch(`${window.apiUrl}/${userId}/mycategories`, {
            method: 'PUT',
            body: JSON.stringify({ categories: checkedCategories })
        });
        const duration = Date.now() - startTime;

        if (!response.ok) {
            const errorText = await response.text();
            console.error('saveCategories - Fetch failed - Status:', response.status, 'Error:', errorText);
            throw new Error(`Failed to save categories: ${response.status} - ${errorText}`);
        }

        const result = await response.json();
        console.log('saveCategories - Save response received - Result:', JSON.stringify(result), 'Duration:', `${duration}ms`);
        toastr.success('Categories saved successfully');
    } catch (error) {
        console.error('saveCategories - Error saving categories - Error:', error.message, 'Stack:', error.stack);
        toastr.error(`Failed to save categories: ${error.message}`);
    }
    console.log('saveCategories - Save process completed');
}

// Handles category selection in admin context to load discounted products.
async function handleCategorySelection(categoryId, checkbox) {
    console.log('handleCategorySelection - Handling selection - Category ID:', categoryId, 'Checked:', checkbox.checked);
    document.querySelectorAll('#categoryTree input[type="checkbox"]').forEach(cb => {
        if (cb !== checkbox) cb.checked = false;
    });

    const tbody = document.getElementById('dealList');
    if (!tbody) {
        console.error('handleCategorySelection - Deal list element not found - ID: dealList');
        return;
    }

    if (checkbox.checked) {
        try {
            console.log('handleCategorySelection - Fetching discounted products - Category ID:', categoryId);
            const response = await authenticatedFetch(`${window.apiUrl}/discounted-products?category_id=${categoryId}&min_discount=20`);
            if (!response.ok) throw new Error(`Failed to fetch discounted products: ${response.status}`);
            const data = await response.json();

            tbody.innerHTML = '';
            data.products.forEach(product => {
                const tr = document.createElement('tr');
                const discountPercent = product.discount_percent || 
                    (product.original_price > product.current_price 
                        ? ((product.original_price - product.current_price) / product.original_price * 100).toFixed(2) 
                        : 'N/A');
                tr.innerHTML = `
                    <td>${product.category || 'N/A'}</td>
                    <td>${product.title}</td>
                    <td><a href="${product.product_url}" target="_blank">Link</a></td>
                    <td>${product.current_price}</td>
                    <td>${product.original_price}</td>
                    <td>${discountPercent}</td>
                    <td><img src="${product.image_url}" width="50" onerror="this.src='https://via.placeholder.com/50';"></td>
                    <td>${product.QTY || 'N/A'}</td>
                `;
                tbody.appendChild(tr);
            });
            console.log('handleCategorySelection - Products loaded - Count:', data.products.length);
            toastr.success(`Loaded ${data.products.length} discounted products for category ${categoryId}`);
        } catch (error) {
            console.error('handleCategorySelection - Error loading products - Error:', error.message, 'Stack:', error.stack);
            toastr.error(`Error loading discounted products: ${error.message}`);
            checkbox.checked = false;
            tbody.innerHTML = '';
        }
    } else {
        tbody.innerHTML = '';
        console.log('handleCategorySelection - Cleared deal list - Category deselected');
    }
    console.log('handleCategorySelection - Selection handling completed');
}// category-management.js
// Purpose: Manages treeview functionality for displaying and editing nested category information (used in community.html and admin.html).

// Creates a treeview node for category display with configurable behavior.
function createTreeNode(category, level = 0, isAdmin = false, savedCategories = []) {
    console.log('createTreeNode - Creating node - Category:', JSON.stringify(category), 'Level:', level, 'IsAdmin:', isAdmin);
    const li = document.createElement('li');
    const nodeDiv = document.createElement('div');
    nodeDiv.className = 'node';

    const toggle = document.createElement('span');
    toggle.className = 'toggle';
    toggle.setAttribute('data-id', category.id);
    toggle.textContent = '+'; // Default to '+' assuming subcategories may exist
    toggle.addEventListener('click', () => toggleSubcategories(category.id, toggle));

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.value = category.id;
    if (isAdmin) {
        checkbox.addEventListener('change', () => handleCategorySelection(category.id, checkbox));
    } else {
        checkbox.checked = savedCategories.includes(category.id.toString());
    }

    const span = document.createElement('span');
    span.textContent = `${category.name} (${category.id})`;

    nodeDiv.appendChild(toggle);
    nodeDiv.appendChild(checkbox);
    nodeDiv.appendChild(span);
    li.appendChild(nodeDiv);

    const subUl = document.createElement('ul');
    subUl.className = 'subcategories';
    li.appendChild(subUl);

    console.log('createTreeNode - Node created - Category ID:', category.id);
    return li;
}

// Loads category data for treeview rendering, with options for admin or community context.
async function loadCategories(userId = null, isAdmin = false) {
    console.log('loadCategories - Starting category load - UserID:', userId, 'IsAdmin:', isAdmin);
    let savedCategories = [];
    try {
        console.log('loadCategories - Fetching categories via authenticatedFetch');
        const startTime = Date.now();

        // Load user's saved categories if not admin
        if (!isAdmin && userId) {
            const userResponse = await authenticatedFetch(`${window.apiUrl}/${userId}/mycategories`);
            if (!userResponse.ok) throw new Error(`Failed to fetch user categories: ${userResponse.status}`);
            const userData = await userResponse.json();
            savedCategories = userData.categories || [];
            console.log('loadCategories - Saved categories fetched - Count:', savedCategories.length);
        }

        // Load all categories
        const response = await authenticatedFetch(`${window.apiUrl}/categories`);
        if (!response.ok) throw new Error(`Failed to fetch categories: ${response.status}`);
        const data = await response.json();
        const duration = Date.now() - startTime;
        console.log('loadCategories - Categories fetched - Count:', data.categories?.length, 'Duration:', `${duration}ms`);

        const treeElement = document.getElementById('categoryTree');
        if (!treeElement) {
            console.error('loadCategories - Tree element not found - ID: categoryTree');
            return;
        }
        treeElement.innerHTML = '';
        const ul = document.createElement('ul');

        // Filter top-level categories for community, show all for admin
        const categoriesToRender = isAdmin ? data.categories : data.categories.filter(cat => !cat.parent_id);
        console.log('loadCategories - Categories to render - Count:', categoriesToRender.length);

        categoriesToRender.forEach(category => {
            const node = createTreeNode(category, 0, isAdmin, savedCategories);
            ul.appendChild(node);
        });
        treeElement.appendChild(ul);

        // Reattach listeners for community context
        if (!isAdmin) attachEventListeners();

        console.log('loadCategories - Treeview rendered successfully');
        toastr.success('Categories loaded successfully');
    } catch (error) {
        console.error('loadCategories - Error loading categories - Error:', error.message, 'Stack:', error.stack);
        toastr.error('Failed to load categories');
    }
    console.log('loadCategories - Category load completed');
}

// Toggles visibility of subcategories in treeview and loads them dynamically if needed.
async function toggleSubcategories(categoryId, toggle) {
    console.log('toggleSubcategories - Toggling subcategories - Category ID:', categoryId);
    const li = toggle.closest('li');
    const subUl = li.querySelector('.subcategories');

    if (!subUl) {
        console.error('toggleSubcategories - Subcategories element not found - Category ID:', categoryId);
        return;
    }

    if (subUl.classList.contains('open')) {
        subUl.classList.remove('open');
        toggle.textContent = '+';
        console.log('toggleSubcategories - Subcategories closed - ID:', categoryId);
    } else {
        if (subUl.children.length === 0) {
            try {
                console.log('toggleSubcategories - Fetching subcategories - Parent ID:', categoryId);
                const response = await authenticatedFetch(`${window.apiUrl}/categories?parent_id=${categoryId}`);
                if (!response.ok) throw new Error(`Failed to fetch subcategories: ${response.status}`);
                const data = await response.json();

                if (data.categories && data.categories.length > 0) {
                    data.categories.forEach(cat => {
                        const node = createTreeNode(cat, 1); // Level 1 for subcategories
                        subUl.appendChild(node);
                    });
                    console.log('toggleSubcategories - Subcategories loaded - Count:', data.categories.length, 'Parent ID:', categoryId);
                    toastr.success(`Subcategories for ${categoryId} loaded successfully`);
                } else {
                    toggle.textContent = ' '; // No subcategories
                    console.log('toggleSubcategories - No subcategories found - Parent ID:', categoryId);
                    toastr.info(`No subcategories for ${categoryId}`);
                    return;
                }
            } catch (error) {
                console.error('toggleSubcategories - Error loading subcategories - Error:', error.message, 'Stack:', error.stack);
                toastr.error(`Error loading subcategories: ${error.message}`);
                toggle.textContent = ' ';
                return;
            }
        }
        subUl.classList.add('open');
        toggle.textContent = '-';
        console.log('toggleSubcategories - Subcategories opened - ID:', categoryId);
    }
    console.log('toggleSubcategories - Toggle completed');
}

// Saves updated category structure from treeview (community context).
async function saveCategories(userId) {
    console.log('saveCategories - Starting category save - UserID:', userId);
    if (!userId) {
        console.error('saveCategories - User ID not provided');
        toastr.error('User ID not found in session');
        return;
    }

    const checkedCategories = Array.from(document.querySelectorAll('#categoryTree input[type="checkbox"]:checked')).map(cb => cb.value);
    console.log('saveCategories - Checked categories - Count:', checkedCategories.length, 'Values:', checkedCategories);

    try {
        console.log('saveCategories - Sending categories via authenticatedFetch - URL:', `${window.apiUrl}/${userId}/mycategories`);
        const startTime = Date.now();
        const response = await authenticatedFetch(`${window.apiUrl}/${userId}/mycategories`, {
            method: 'PUT',
            body: JSON.stringify({ categories: checkedCategories })
        });
        const duration = Date.now() - startTime;

        if (!response.ok) {
            const errorText = await response.text();
            console.error('saveCategories - Fetch failed - Status:', response.status, 'Error:', errorText);
            throw new Error(`Failed to save categories: ${response.status} - ${errorText}`);
        }

        const result = await response.json();
        console.log('saveCategories - Save response received - Result:', JSON.stringify(result), 'Duration:', `${duration}ms`);
        toastr.success('Categories saved successfully');
    } catch (error) {
        console.error('saveCategories - Error saving categories - Error:', error.message, 'Stack:', error.stack);
        toastr.error(`Failed to save categories: ${error.message}`);
    }
    console.log('saveCategories - Save process completed');
}

// Handles category selection in admin context to load discounted products.
async function handleCategorySelection(categoryId, checkbox) {
    console.log('handleCategorySelection - Handling selection - Category ID:', categoryId, 'Checked:', checkbox.checked);
    document.querySelectorAll('#categoryTree input[type="checkbox"]').forEach(cb => {
        if (cb !== checkbox) cb.checked = false;
    });

    const tbody = document.getElementById('dealList');
    if (!tbody) {
        console.error('handleCategorySelection - Deal list element not found - ID: dealList');
        return;
    }

    if (checkbox.checked) {
        try {
            console.log('handleCategorySelection - Fetching discounted products - Category ID:', categoryId);
            const response = await authenticatedFetch(`${window.apiUrl}/discounted-products?category_id=${categoryId}&min_discount=20`);
            if (!response.ok) throw new Error(`Failed to fetch discounted products: ${response.status}`);
            const data = await response.json();

            tbody.innerHTML = '';
            data.products.forEach(product => {
                const tr = document.createElement('tr');
                const discountPercent = product.discount_percent || 
                    (product.original_price > product.current_price 
                        ? ((product.original_price - product.current_price) / product.original_price * 100).toFixed(2) 
                        : 'N/A');
                tr.innerHTML = `
                    <td>${product.category || 'N/A'}</td>
                    <td>${product.title}</td>
                    <td><a href="${product.product_url}" target="_blank">Link</a></td>
                    <td>${product.current_price}</td>
                    <td>${product.original_price}</td>
                    <td>${discountPercent}</td>
                    <td><img src="${product.image_url}" width="50" onerror="this.src='https://via.placeholder.com/50';"></td>
                    <td>${product.QTY || 'N/A'}</td>
                `;
                tbody.appendChild(tr);
            });
            console.log('handleCategorySelection - Products loaded - Count:', data.products.length);
            toastr.success(`Loaded ${data.products.length} discounted products for category ${categoryId}`);
        } catch (error) {
            console.error('handleCategorySelection - Error loading products - Error:', error.message, 'Stack:', error.stack);
            toastr.error(`Error loading discounted products: ${error.message}`);
            checkbox.checked = false;
            tbody.innerHTML = '';
        }
    } else {
        tbody.innerHTML = '';
        console.log('handleCategorySelection - Cleared deal list - Category deselected');
    }
    console.log('handleCategorySelection - Selection handling completed');
}
common.js
// common.js
// Purpose: Provides core shared utilities for all pages, specifically Toastr configuration.

// Configures Toastr for consistent toast notifications across the application.
function setupToastr() {
    console.log('setupToastr - Initiating Toastr configuration');
    if (typeof toastr === 'undefined') {
        console.error('setupToastr - Toastr library not loaded');
        return;
    }
    toastr.options = {
        closeButton: true,
        progressBar: true,
        positionClass: 'toast-top-right',
        timeOut: 5000,
        showMethod: 'slideDown',
        hideMethod: 'slideUp'
    };
    console.log('setupToastr - Toastr options configured:', JSON.stringify(toastr.options));
    console.log('setupToastr - Configuration completed');
}

// Export for use in other scripts
window.setupToastr = setupToastr;
community-page.js
// community-page.js
// Purpose: Manages page-specific functionality for the /community page.

// Initializes the community page with permission checks.
function initializeCommunity() {
    console.log('initializeCommunity - Initializing community page');
    const token = localStorage.getItem('authToken');
    const userId = localStorage.getItem('userId');
    if (!token) {
        console.error('initializeCommunity - No token found, redirecting to /');
        window.location.href = '/';
        return;
    }
    const decoded = decodeJWT(token);
    if (!decoded) {
        console.error('initializeCommunity - Invalid token, redirecting to /');
        window.location.href = '/';
        return;
    }
    window.userPermissions = decoded.permissions || [];
    if (!window.userPermissions.includes('community')) {
        toastr.error('Permission denied: Community permission required');
        console.error('initializeCommunity - No community permission, redirecting to /');
        window.location.href = '/';
        return;
    }
    if (!userId) {
        toastr.error('User ID not found in session, redirecting to login');
        console.error('initializeCommunity - No userId found in localStorage');
        window.location.href = '/';
        return;
    }
    const userIdInput = document.getElementById('userId');
    if (userIdInput) {
        userIdInput.value = userId;
    } else {
        console.warn('initializeCommunity - userId input not found');
    }

    // Set up navigation and event listeners to fix button functionality
    setupNavigation(); // From site-navigation.js (CREQ Requirement 1)
    attachEventListeners(); // From page-load.js (CREQ Requirement 1)

    // Load branding and initial data
    loadBranding('community', 'brandingContent');
    updateMenu();
    showSection('welcome');
    waitForTinyMCE(() => initializeTinyMCE('#aboutCommunity, #stylingDetails, #page1Content'));
    loadVisits();
    loadOrders();

    // Set up shared "Change Password" logic
    if (typeof setupChangePassword === 'function') {
        setupChangePassword(); // From user-management.js (CREQ Requirement 2)
        console.log('initializeCommunity - Change Password logic initialized');
    } else {
        console.error('initializeCommunity - setupChangePassword function not found');
    }

    // Hide loading overlay after initialization
    hideLoadingOverlay(); // From page-load.js (CREQ Requirement 3)
    console.log('initializeCommunity - Community page initialized successfully');
}

// Updates the menu dynamically based on permissions.
function updateMenu() {
    console.log('updateMenu - Updating menu');
    const menu = document.getElementById('menu');
    const userId = document.getElementById('userId') ? document.getElementById('userId').value : '';
    if (menu) {
        menu.innerHTML = `<input type="text" id="userId" style="display: none;" value="${userId || ''}">`;
        menu.innerHTML += `
            <button data-section="welcome">
                <span class="button-content"><i class="fas fa-home"></i> Dashboard</span>
            </button>
            <button data-submenu="my_website_intro" data-section="my_website_intro">
                <span class="button-content"><i class="fas fa-globe"></i> My Web Site</span>
                <i class="fas fa-caret-right caret"></i>
            </button>
            <div id="my_website_intro" class="submenu">
                <button data-section="wix">
                    <span class="button-content"><i class="fab fa-wix-simple"></i> Wix</span>
                </button>
                <button data-section="wordpress">
                    <span class="button-content"><i class="fab fa-wordpress"></i> WordPress</span>
                </button>
                <button data-section="squarespace">
                    <span class="button-content"><i class="fab fa-squarespace"></i> Squarespace</span>
                </button>
                <button data-section="weebly">
                    <span class="button-content"><i class="fab fa-weebly"></i> Weebly</span>
                </button>
                <button data-section="joomla">
                    <span class="button-content"><i class="fab fa-joomla"></i> Joomla</span>
                </button>
                <button data-section="no_website">
                    <span class="button-content"><i class="fas fa-question-circle"></i> I Don’t Have a Website Yet</span>
                </button>
            </div>
            <button data-section="categories">
                <span class="button-content"><i class="fas fa-list"></i> My Categories</span>
            </button>
            <button data-submenu="referrals_intro" data-section="referrals_intro">
                <span class="button-content">
                    <span class="svg-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512" preserveAspectRatio="xMidYMid meet">
                            <path d="M72 88a56 56 0 1 1 112 0A56 56 0 1 1 72 88zM64 245.7C54 256.9 48 271.8 48 288s6 31.1 16 42.3l0-84.7zm144.4-49.3C178.7 222.7 160 261.2 160 304c0 34.3 12 65.8 32 90.5l0 21.5c0 17.7-14.3 32-32 32l-64 0c-17.7 0-32-14.3-32-32l0-26.8C26.2 371.2 0 332.7 0 288c0-61.9 50.1-112 112-112l32 0c24 0 46.2 7.5 64.4 20.3zM448 416l0-21.5c20-24.7 32-56.2 32-90.5c0-42.8-18.7-81.3-48.4-107.7C449.8 183.5 472 176 496 176l32 0c61.9 0 112 50.1 112 112c0 44.7-26.2 83.2-64 101.2l0 26.8c0 17.7-14.3 32-32 32l-64 0c-17.7 0-32-14.3-32-32zm8-328a56 56 0 1 1 112 0A56 56 0 1 1 456 88zM576 245.7l0 84.7c10-11.3 16-26.1 16-42.3s-6-31.1-16-42.3zM320 32a64 64 0 1 1 0 128 64 64 0 1 1 0-128zM240 304c0 16.2 6 31 16 42.3l0-84.7c-10 11.3-16 26.1-16 42.3zm144-42.3l0 84.7c10-11.3 16-26.1 16-42.3s-6-31.1-16-42.3zM448 304c0 44.7-26.2 83.2-64 101.2l0 42.8c0 17.7-14.3 32-32 32l-64 0c-17.7 0-32-14.3-32-32l0-42.8c-37.8-18-64-56.5-64-101.2c0-61.9 50.1-112 112-112l32 0c61.9 0 112 50.1 112 112z"/>
                        </svg>
                    </span> My Referrals
                </span>
                <i class="fas fa-caret-right caret"></i>
            </button>
            <div id="referrals_intro" class="submenu">
                <button data-section="visits">
                    <span class="button-content"><i class="fas fa-eye"></i> Visits</span>
                </button>
                <button data-section="orders">
                    <span class="button-content"><i class="fas fa-shopping-cart"></i> Orders</span>
                </button>
            </div>
            <button data-submenu="my-account-submenu" data-section="my-account">
                <span class="button-content"><i class="fas fa-cog"></i> My Account</span>
                <i class="fas fa-caret-right caret"></i>
            </button>
            <div id="my-account-submenu" class="submenu">
                <button data-section="my-account">
                    <span class="button-content"><i class="fas fa-address-book"></i> Contact</span>
                </button>
                <button data-section="change-password">
                    <span class="button-content"><i class="fas fa-key"></i> Change Password</span>
                </button>
            </div>
        `;
        if (window.userPermissions.includes('admin')) {
            menu.innerHTML += `
                <button data-href="/admin" class="btn-admin">
                    <span class="button-content"><i class="fas fa-arrow-left"></i> Back to Admin</span>
                </button>
            `;
        }
        menu.innerHTML += `
            <button id="logOffBtn" class="btn-logoff">
                <span class="button-content"><i class="fas fa-sign-out-alt"></i> Log Off</span>
            </button>
        `;
        console.log('updateMenu - Menu updated');
    } else {
        console.error('updateMenu - Menu element not found');
    }
}

function updateIntegrationCode(section) {
    console.log('updateIntegrationCode - Updating integration code - Section:', section);
    const codeElements = {
        'wix': 'wixCode',
        'wordpress': 'wordpressCode',
        'squarespace': 'squarespaceCode',
        'weebly': 'weeblyCode',
        'joomla': 'joomlaCode'
    };
    const codeId = codeElements[section];
    const userId = document.getElementById('userId')?.value || 'unknown'; // Null-safe
    if (codeId) {
        const codeElement = document.getElementById(codeId);
        if (codeElement) {
            codeElement.textContent = `<iframe src="https://clubmadeira.io/discounts?referrer=${userId}" width="100%" height="600"></iframe>`;
            console.log('updateIntegrationCode - Code updated - ID:', codeId);
        } else {
            console.warn('updateIntegrationCode - Code element not found - ID:', codeId);
        }
    }
}

async function loadVisits() {
    console.log('loadVisits - Loading visits');
    const userId = document.getElementById('userId')?.value || '';
    if (!userId) {
        console.error('loadVisits - User ID not found in session');
        toastr.error('User ID not found in session');
        return;
    }
    try {
        console.log('loadVisits - Fetching visits - URL:', `${window.apiUrl}/${userId}/visits`);
        const response = await authenticatedFetch(`${window.apiUrl}/${userId}/visits`);
        if (!response.ok) throw new Error(`Failed to fetch visits: ${response.status}`);
        const data = await response.json();
        console.log('loadVisits - Visits fetched - Data:', JSON.stringify(data));
        if (data.status === 'success') {
            const now = new Date();
            const thisMonth = now.getMonth();
            const thisYear = now.getFullYear();
            const visitsThisMonth = [];
            const visitsLastMonth = [];
            const visitsEarlier = [];
            data.visits.forEach(visit => {
                const visitDate = new Date(visit.timestamp);
                if (visitDate.getFullYear() === thisYear && visitDate.getMonth() === thisMonth) {
                    visitsThisMonth.push(visit);
                } else if ((visitDate.getFullYear() === thisYear && visitDate.getMonth() === thisMonth - 1) ||
                          (visitDate.getFullYear() === thisYear - 1 && thisMonth === 0 && visitDate.getMonth() === 11)) {
                    visitsLastMonth.push(visit);
                } else {
                    visitsEarlier.push(visit);
                }
            });
            updateVisitsTable('visitsListThisMonth', visitsThisMonth);
            updateVisitsTable('visitsListLastMonth', visitsLastMonth);
            updateVisitsTable('visitsListEarlier', visitsEarlier);
            console.log('loadVisits - Visits loaded - Counts:', { 
                thisMonth: visitsThisMonth.length, 
                lastMonth: visitsLastMonth.length, 
                earlier: visitsEarlier.length 
            });
        }
    } catch (error) {
        console.error('loadVisits - Error loading visits:', error.message, error.stack);
        toastr.error(`Error loading visits: ${error.message}`);
    }
}

function updateVisitsTable(tableId, visits) {
    console.log('updateVisitsTable - Updating table - Table ID:', tableId, 'Visits:', visits.length);
    const tbody = document.getElementById(tableId);
    if (tbody) {
        tbody.innerHTML = visits.length === 0 ? '<tr><td colspan="2">No visits found</td></tr>' : '';
        visits.forEach(visit => {
            const row = document.createElement('tr');
            row.innerHTML = `<td>${visit.page || 'N/A'}</td><td>${visit.timestamp || 'N/A'}</td>`;
            tbody.appendChild(row);
        });
        console.log('updateVisitsTable - Table updated - ID:', tableId);
    } else {
        console.warn('updateVisitsTable - Table element not found - ID:', tableId);
    }
}

async function loadOrders() {
    console.log('loadOrders - Loading orders');
    const userId = document.getElementById('userId')?.value || '';
    if (!userId) {
        console.error('loadOrders - User ID not found in session');
        toastr.error('User ID not found in session');
        return;
    }
    try {
        console.log('loadOrders - Fetching orders - URL:', `${window.apiUrl}/${userId}/orders`);
        const response = await authenticatedFetch(`${window.apiUrl}/${userId}/orders`);
        if (!response.ok) throw new Error(`Failed to fetch orders: ${response.status}`);
        const data = await response.json();
        console.log('loadOrders - Orders fetched - Data:', JSON.stringify(data));
        if (data.status === 'success') {
            const now = new Date();
            const thisMonth = now.getMonth();
            const thisYear = now.getFullYear();
            const ordersThisMonth = [];
            const ordersLastMonth = [];
            const ordersEarlier = [];
            data.orders.forEach(order => {
                const orderDate = new Date(order.timestamp);
                if (orderDate.getFullYear() === thisYear && orderDate.getMonth() === thisMonth) {
                    ordersThisMonth.push(order);
                } else if ((orderDate.getFullYear() === thisYear && orderDate.getMonth() === thisMonth - 1) ||
                          (orderDate.getFullYear() === thisYear - 1 && thisMonth === 0 && orderDate.getMonth() === 11)) {
                    ordersLastMonth.push(order);
                } else {
                    ordersEarlier.push(order);
                }
            });
            updateOrdersTable('ordersListThisMonth', ordersThisMonth);
            updateOrdersTable('ordersListLastMonth', ordersLastMonth);
            updateOrdersTable('ordersListEarlier', ordersEarlier);
            console.log('loadOrders - Orders loaded - Counts:', { 
                thisMonth: ordersThisMonth.length, 
                lastMonth: ordersLastMonth.length, 
                earlier: ordersEarlier.length 
            });
        }
    } catch (error) {
        console.error('loadOrders - Error loading orders:', error.message, error.stack);
        toastr.error(`Error loading orders: ${error.message}`);
    }
}

function updateOrdersTable(tableId, orders) {
    console.log('updateOrdersTable - Updating table - Table ID:', tableId, 'Orders:', orders.length);
    const tbody = document.getElementById(tableId);
    if (tbody) {
        tbody.innerHTML = orders.length === 0 ? '<tr><td colspan="4">No orders found</td></tr>' : '';
        orders.forEach(order => {
            const row = document.createElement('tr');
            row.innerHTML = `<td>${order.orderId || 'N/A'}</td><td>${order.buyer || 'N/A'}</td><td>$${order.total || '0.00'}</td><td>${order.timestamp || 'N/A'}</td>`;
            tbody.appendChild(row);
        });
        console.log('updateOrdersTable - Table updated - ID:', tableId);
    } else {
        console.warn('updateOrdersTable - Table element not found - ID:', tableId);
    }
}

function waitForTinyMCE(callback) {
    console.log('waitForTinyMCE - Checking if TinyMCE is loaded');
    if (typeof tinymce !== 'undefined' && tinymce.init) {
        console.log('waitForTinyMCE - TinyMCE is loaded, executing callback');
        callback();
    } else {
        console.log('waitForTinyMCE - Waiting for TinyMCE to load...');
        const script = document.querySelector('script[src*="tinymce.min.js"]');
        if (script) {
            script.onload = () => {
                console.log('waitForTinyMCE - TinyMCE script loaded');
                callback();
            };
            script.onerror = () => console.error('waitForTinyMCE - TinyMCE failed to load');
        } else {
            setTimeout(() => waitForTinyMCE(callback), 100);
        }
    }
}

// Export for use in other scripts
window.initializeCommunity = initializeCommunity;
window.updateMenu = updateMenu;
window.updateIntegrationCode = updateIntegrationCode;
window.loadVisits = loadVisits;
window.updateVisitsTable = updateVisitsTable;
window.loadOrders = loadOrders;
window.updateOrdersTable = updateOrdersTable;
window.waitForTinyMCE = waitForTinyMCE;
merchant-page.js
// merchant-page.js
// Purpose: Manages page-specific functionality for the /merchant page.

// Initializes the merchant page with permission checks.
function initializeMerchant() {
    console.log('initializeMerchant - Initializing merchant page');
    const token = localStorage.getItem('authToken');
    const userId = localStorage.getItem('userId');
    if (!token) {
        console.error('initializeMerchant - No token found, redirecting to /');
        window.location.href = '/';
        return;
    }
    const decoded = decodeJWT(token);
    if (!decoded) {
        console.error('initializeMerchant - Invalid token, redirecting to /');
        window.location.href = '/';
        return;
    }
    window.userPermissions = decoded.permissions || [];
    if (!window.userPermissions.includes('merchant') && !window.userPermissions.includes('admin')) {
        toastr.error('Permission denied: Merchant or Admin permission required');
        console.error('initializeMerchant - No merchant/admin permission, redirecting to /');
        window.location.href = '/';
        return;
    }
    const userIdInput = document.getElementById('userId');
    if (userIdInput && userId) {
        userIdInput.value = userId;
    } else if (!userId) {
        console.warn('initializeMerchant - No userId found in localStorage');
    } else {
        console.warn('initializeMerchant - userId input element not found');
    }

    // Set up navigation and event listeners
    setupNavigation(); // From site-navigation.js
    checkAdminPermission();
    loadBranding('merchant', 'brandingContent'); // Adjusted to match typical usage
    showSection('info');
    loadProducts(); // Load merchant products
    loadStoreRequest(); // Load store request data
    attachEventListeners(); // From page-load.js

    // Call shared "Change Password" logic
    if (typeof setupChangePassword === 'function') {
        setupChangePassword(); // From user-management.js
        console.log('initializeMerchant - Change Password logic initialized');
    } else {
        console.error('initializeMerchant - setupChangePassword function not found');
    }

    // Hide loading overlay after initialization
    hideLoadingOverlay(); // From page-load.js
    console.log('initializeMerchant - Merchant page initialized successfully');
}

// Checks and toggles visibility of admin-specific elements.
function checkAdminPermission() {
    console.log('checkAdminPermission - Checking admin permission');
    const backButton = document.querySelector('button[data-href="/admin"]');
    if (backButton) {
        backButton.style.display = window.userPermissions.includes('admin') ? 'block' : 'none';
        console.log('checkAdminPermission - Back button visibility:', backButton.style.display);
    } else {
        console.warn('checkAdminPermission - Back button not found');
    }
}

// Loads and displays merchant products.
async function loadProducts() {
    console.log('loadProducts - Loading products');
    const userId = document.getElementById('userId') ? document.getElementById('userId').value : '';
    if (!userId) {
        console.error('loadProducts - User ID not found in session');
        toastr.error('User ID not found in session');
        return;
    }
    try {
        console.log('loadProducts - Fetching products - URL:', `${window.apiUrl}/${userId}/products`);
        const response = await authenticatedFetch(`${window.apiUrl}/${userId}/products`);
        if (!response.ok) throw new Error(`Failed to fetch products: ${response.status}`);
        const data = await response.json();
        console.log('loadProducts - Products fetched - Data:', JSON.stringify(data));
        
        const tbody = document.getElementById('productList');
        if (tbody) {
            tbody.innerHTML = '';
            data.products.forEach(product => tbody.appendChild(createProductRow(product)));
            console.log('loadProducts - Product table updated - Count:', data.products.length);
        } else {
            console.warn('loadProducts - Product list element not found');
        }
    } catch (error) {
        console.error('loadProducts - Error loading products - Error:', error.message, 'Stack:', error.stack);
        toastr.error(`Error loading products: ${error.message}`);
    }
}

// Creates a table row for a product.
function createProductRow(product) {
    console.log('createProductRow - Creating row - Product:', JSON.stringify(product));
    const tr = document.createElement('tr');
    tr.innerHTML = `
        <td class="hidden">${product.id || ''}</td>
        <td>${product.category || 'N/A'}</td>
        <td>${product.title || 'N/A'}</td>
        <td><a href="${product.product_url || '#'}" target="_blank">${product.product_url ? 'Link' : 'N/A'}</a></td>
        <td>${product.current_price || 'N/A'}</td>
        <td>${product.original_price || 'N/A'}</td>
        <td><img src="${product.image_url || ''}" width="50" onerror="this.src='https://via.placeholder.com/50';"></td>
        <td>${product.qty || 'N/A'}</td>
    `;
    return tr;
}

// Loads store request data specific to merchant page.
async function loadStoreRequest() {
    console.log('loadStoreRequest - Loading store request');
    const userId = document.getElementById('userId') ? document.getElementById('userId').value : '';
    if (!userId) {
        console.error('loadStoreRequest - User ID not found in session');
        toastr.error('User ID not found in session');
        return;
    }
    try {
        console.log('loadStoreRequest - Fetching store request - URL:', `${window.apiUrl}/${userId}/siterequest`);
        const response = await authenticatedFetch(`${window.apiUrl}/${userId}/siterequest`);
        if (!response.ok) throw new Error(`Failed to fetch store request: ${response.status}`);
        const data = await response.json();
        const storeRequest = data.site_request || {};
        console.log('loadStoreRequest - Store request fetched - Data:', JSON.stringify(storeRequest));

        document.getElementById('storeName').value = storeRequest.storeName || '';
        if (window.tinyMCELoaded) {
            tinymce.get('aboutStore')?.setContent(storeRequest.aboutStore || '');
        } else {
            document.getElementById('aboutStore').value = storeRequest.aboutStore || '';
        }
        document.getElementById('colorPrefs').value = storeRequest.colorPrefs || '';
        document.getElementById('stylingDetails').value = storeRequest.stylingDetails || '';
        document.getElementById('preferredDomain').value = storeRequest.preferredDomain || 'mystore.uk';

        const emails = storeRequest.emails || ['info'];
        window.emailCount = 0;
        const emailsContainer = document.getElementById('emailsContainer');
        if (emailsContainer) {
            emailsContainer.innerHTML = '';
            emails.forEach((email, index) => {
                window.emailCount++;
                const emailDiv = document.createElement('div');
                emailDiv.className = 'email-section';
                emailDiv.dataset.email = window.emailCount;
                emailDiv.innerHTML = `
                    <label for="email${window.emailCount}Name">Email Name:</label>
                    <input type="text" id="email${window.emailCount}Name" name="email${window.emailCount}Name" value="${email}">
                    <span id="email${window.emailCount}Domain">@${storeRequest.preferredDomain || 'mystore.uk'}</span>
                    ${window.emailCount > 1 ? `<button type="button" class="remove-email-btn" onclick="removeEmail(${window.emailCount})">Remove Email</button>` : ''}
                `;
                emailsContainer.appendChild(emailDiv);
            });
        } else {
            console.warn('loadStoreRequest - Emails container not found');
        }

        const pages = storeRequest.pages && storeRequest.pages.length >= 2 ? storeRequest.pages : [
            { name: 'Home', content: '' },
            { name: 'Returns Policy', content: '' }
        ];
        window.pageCount = 0;
        const pagesContainer = document.getElementById('pagesContainer');
        if (pagesContainer) {
            pagesContainer.innerHTML = '';
            pages.forEach((page, index) => {
                window.pageCount++;
                const pageDiv = document.createElement('div');
                pageDiv.className = 'page-section';
                pageDiv.dataset.page = window.pageCount;
                pageDiv.innerHTML = `
                    <label for="page${window.pageCount}Name">Page Name:</label>
                    <input type="text" id="page${window.pageCount}Name" name="page${window.pageCount}Name" value="${page.name || ''}" ${window.pageCount <= 2 ? 'readonly' : ''}>
                    <br><br>
                    <label for="page${window.pageCount}Content">${window.pageCount === 1 ? 'Home Page' : window.pageCount === 2 ? 'Returns Policy' : 'Page'} Content:</label>
                    <textarea id="page${window.pageCount}Content" name="page${window.pageCount}Content">${page.content || ''}</textarea>
                    <label for="page${window.pageCount}Images">Additional Images:</label>
                    <input type="file" id="page${window.pageCount}Images" name="page${window.pageCount}Images" accept="image/*" multiple>
                    ${window.pageCount > 2 ? `<button type="button" class="remove-page-btn" onclick="removePage(${window.pageCount})">Remove Page</button>` : ''}
                `;
                pagesContainer.appendChild(pageDiv);
                if (window.tinyMCELoaded) {
                    tinymce.init({
                        selector: `#page${window.pageCount}Content`,
                        height: 200,
                        menubar: false,
                        plugins: 'lists',
                        toolbar: 'bold italic | bullist numlist',
                        setup: editor => {
                            editor.on('init', () => console.log(`TinyMCE editor initialized for page${window.pageCount}`));
                        }
                    });
                }
            });
        } else {
            console.warn('loadStoreRequest - Pages container not found');
        }

        const widgets = storeRequest.widgets || [];
        document.querySelectorAll('input[name="widgets"]').forEach(checkbox => {
            checkbox.checked = widgets.includes(checkbox.value);
        });

        updateDomainPreview(); // Assumed function from site-request.js
        console.log('loadStoreRequest - Store request loaded successfully');
    } catch (error) {
        console.error('loadStoreRequest - Error loading store request - Error:', error.message, 'Stack:', error.stack);
        toastr.error(`Error loading store request: ${error.message}`);
    }
}

// Export for use in other scripts
window.initializeMerchant = initializeMerchant;
window.checkAdminPermission = checkAdminPermission;
window.loadProducts = loadProducts;
window.createProductRow = createProductRow;
window.loadStoreRequest = loadStoreRequest;
page-load.js
// /static/js/page-load.js
// Purpose: Manages page initialization, event listener attachment for navigation and section handling, and loading overlay behavior.

// Function to show the loading overlay
function showLoadingOverlay() {
    let loadingOverlay = document.getElementById('loadingOverlay');
    if (!loadingOverlay) {
        loadingOverlay = document.createElement('div');
        loadingOverlay.id = 'loadingOverlay';
        loadingOverlay.innerHTML = `
            <div class="multicircle-loader">
                <div class="circle circle1"></div>
                <div class="circle circle2"></div>
                <div class="circle circle3"></div>
                <div class="circle circle4"></div>
            </div>
        `;
        document.body.prepend(loadingOverlay);
        console.log('showLoadingOverlay - Created and prepended loading overlay');
    }
    loadingOverlay.style.display = 'flex';
    console.log('showLoadingOverlay - Loading overlay set to visible');
    return loadingOverlay;
}

// Function to hide the loading overlay and show the main content with a minimum visibility delay
async function hideLoadingOverlay(minDelay = 1000) {
    const loadingOverlay = document.getElementById('loadingOverlay');
    const layoutWrapper = document.querySelector('.layout-wrapper');
    
    if (loadingOverlay && layoutWrapper) {
        await new Promise(resolve => setTimeout(resolve, minDelay));
        loadingOverlay.style.display = 'none';
        layoutWrapper.style.display = 'block';
        console.log('hideLoadingOverlay - Loading overlay hidden, main content displayed');
    } else {
        console.warn('hideLoadingOverlay - Loading overlay or layout wrapper not found');
    }
}

// Loads branding content into #brandingContent
async function loadBranding(brandingType) {
    console.log('loadBranding - Loading branding - Type:', brandingType);
    const brandingContent = document.getElementById('brandingContent');
    if (!brandingContent) {
        console.error('loadBranding - Branding container not found - ID: brandingContent');
        return;
    }
    try {
        console.log('loadBranding - Fetching branding from /branding - Type:', brandingType);
        const response = await authenticatedFetch(`${window.apiUrl}/branding?type=${brandingType}`);
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Failed to fetch branding: ${response.status} - ${errorData.message || 'Unknown error'}`);
        }
        const data = await response.json();
        if (data.status === 'success' && data.branding) {
            brandingContent.innerHTML = data.branding;
            console.log('loadBranding - Branding loaded successfully - Type:', brandingType);
        } else {
            throw new Error('Invalid branding response');
        }
    } catch (error) {
        console.error('loadBranding - Error fetching branding:', error.message);
        brandingContent.innerHTML = `<h1>${brandingType.charAt(0).toUpperCase() + brandingType.slice(1)} Dashboard</h1>`;
        console.log('loadBranding - Fallback branding applied - Type:', brandingType);
    }
}

// Attaches event listeners for navigation and section handling.
function attachEventListeners() {
    console.log('attachEventListeners - Attaching event listeners');
    const buttons = document.querySelectorAll('button[data-section], button[data-href]'); // Exclude data-submenu to avoid overlap
    console.log('attachEventListeners - Found buttons with data attributes:', buttons.length);
    buttons.forEach(button => {
        const sectionId = button.getAttribute('data-section');
        const href = button.getAttribute('data-href');
        if (sectionId || href) { // Only handle sections or SPA links, not submenus
            button.addEventListener('click', (event) => {
                if (href) {
                    event.preventDefault();
                    fetchProtectedPage(href, '.content-wrapper');
                } else if (sectionId) {
                    siteNavigation.showSection(sectionId);
                }
            });
            console.log('attachEventListeners - Added click listener to button with data:', sectionId || href);
        }
    });
    // Log off button logic remains
    const contentWrapper = document.querySelector('.content-wrapper');
    if (contentWrapper) {
        contentWrapper.addEventListener('click', (event) => {
            if (event.target.id === 'logOffBtn') handleLogOff(event);
        });
    }
    console.log('attachEventListeners - Event listeners attached');
}

// Base initialization function ensuring permission checks before page setup.
function initializePage(requiredPermissions, callback) {
    console.log('initializePage - Starting initialization - Permissions required:', requiredPermissions);
    const token = localStorage.getItem('authToken');
    console.log('initializePage - Retrieved token from localStorage:', token || 'None');
    if (!token) {
        console.warn('initializePage - No auth token found - Redirecting to /');
        window.location.href = '/';
        return;
    }
    const decoded = decodeJWT(token);
    console.log('initializePage - Decoded token:', decoded ? JSON.stringify(decoded) : 'null');
    if (!decoded) {
        console.warn('initializePage - Failed to decode token - Redirecting to /');
        window.location.href = '/';
        return;
    }
    window.userPermissions = decoded.permissions || [];
    console.log('initializePage - User permissions set:', JSON.stringify(window.userPermissions));
    if (!requiredPermissions.some(perm => window.userPermissions.includes(perm))) {
        console.warn('initializePage - Required permissions not found - Required:', requiredPermissions, 'Permissions:', window.userPermissions);
        toastr.error(`Permission denied: one of ${requiredPermissions.join(', ')} required`);
        window.location.href = '/';
        return;
    }
    console.log('initializePage - Permission check passed - Executing callback');
    callback();
    console.log('initializePage - Initialization completed for permissions:', requiredPermissions);
}

// Common initialize function handling page-specific setup based on page type.
async function initialize(pageType) {
    console.log('initialize - Starting page initialization - Page type:', pageType);
    
    showLoadingOverlay();

    const pageConfigs = {
        'partner': {
            permissions: ["wixpro", "admin"],
            brandingType: 'partner',
            initialSection: null,
            requiresUserId: false,
            extraSteps: () => {
                console.log('initialize - Executing partner-specific steps');
                initializePartner(); // From partner-page.js
                attachEventListeners();
                console.log('initialize - Partner-specific steps completed');
            }
        },
        'merchant': {
            permissions: ["merchant", "admin"],
            brandingType: 'merchant',
            initialSection: 'info',
            requiresUserId: true,
            extraSteps: () => {
                console.log('initialize - Executing merchant-specific steps');
                initializeMerchant(); // From merchant-page.js
                attachEventListeners();
                console.log('initialize - Merchant-specific steps completed');
            }
        },
        'community': {
            permissions: ["community", "admin"],
            brandingType: 'community',
            initialSection: 'welcome',
            requiresUserId: true,
            extraSteps: () => {
                console.log('initialize - Executing community-specific steps');
                initializeCommunity(); // From community-page.js
                attachEventListeners();
                console.log('initialize - Community-specific steps completed');
            }
        },
        'admin': {
            permissions: ["admin"],
            brandingType: 'admin',
            initialSection: 'welcome',
            requiresUserId: false,
            extraSteps: () => {
                console.log('initialize - Executing admin-specific steps');
                initializeAdmin('admin'); // From admin-page.js
                attachEventListeners();
                console.log('initialize - Admin-specific steps completed');
            }
        },
        'login': {
            permissions: [],
            brandingType: 'login',
            initialSection: null,
            requiresUserId: false,
            extraSteps: () => {
                console.log('initialize - Executing login-specific steps');
                console.log('initialize - Login-specific steps completed');
            }
        },
        'signup': {
            permissions: [],
            brandingType: 'signup',
            initialSection: null,
            requiresUserId: false,
            extraSteps: () => {
                console.log('initialize - Executing signup-specific steps');
                console.log('initialize - Signup-specific steps completed');
            }
        }
    };

    const config = pageConfigs[pageType];
    if (!config) {
        console.error('initialize - Invalid page type provided - Type:', pageType);
        toastr.error('Invalid page type');
        await hideLoadingOverlay();
        return;
    }
    console.log('initialize - Configuration loaded for page type:', pageType, 'Config:', JSON.stringify(config));

    if (config.permissions && config.permissions.length > 0) {
        console.log('initialize - Performing permission check for:', config.permissions);
        initializePage(config.permissions, async () => {
            console.log('initialize - Permission validated for:', config.permissions);
            await performPageSetup(pageType, config);
            await hideLoadingOverlay();
        });
    } else {
        console.log('initialize - No permissions required for:', pageType);
        await performPageSetup(pageType, config);
        await hideLoadingOverlay();
    }
    console.log('initialize - Initialization process completed for:', pageType);
}

// Attach initialize to the window object to ensure it's globally available
window.initialize = initialize;

// Helper function to perform page setup after permission checks.
async function performPageSetup(pageType, config) {
    console.log('performPageSetup - Starting setup - Page type:', pageType);
    
    console.log('performPageSetup - Loading branding - Type:', config.brandingType);
    await loadBranding(config.brandingType);

    if (config.initialSection) {
        console.log('performPageSetup - Showing initial section - ID:', config.initialSection);
        showSection(config.initialSection);
    } else {
        console.log('performPageSetup - No initial section specified for:', pageType);
    }

    if (typeof config.extraSteps === 'function') {
        console.log('performPageSetup - Executing extra steps for:', pageType);
        config.extraSteps();
    } else {
        console.log('performPageSetup - No extra steps defined for:', pageType);
    }

    console.log('performPageSetup - Page setup completed for:', pageType);
}

// Attaches click event listeners for section navigation.
function handleSectionClick(event) {
    console.log('handleSectionClick - Section click event triggered');
    const target = event.target.closest('button[data-section], button[data-submenu]');
    console.log('handleSectionClick - Event target:', target);
    if (!target) return;

    event.stopPropagation(); // Stop bubbling to parent elements

    const sectionId = target.getAttribute('data-section');
    const submenuId = target.getAttribute('data-submenu');
    console.log(`handleSectionClick - Extracted attributes - Section: ${sectionId} Submenu: ${submenuId}`);

    // Toggle submenu if the button has a data-submenu attribute
    if (submenuId) {
        console.log(`handleSectionClick - Toggling submenu - ID: ${submenuId}`);
        toggleSubmenu(submenuId);
    }

    // Show section if the button has a data-section attribute
    if (sectionId) {
        console.log(`handleSectionClick - Showing section - ID: ${sectionId}`);
        showSection(sectionId);
    }
    console.log('handleSectionClick - Event handling completed');
}

// Attaches click event listeners for href navigation with SPA support.
async function handleHrefClick(event, options = {}) {
    console.log('handleHrefClick - Href click event triggered');
    const target = event.currentTarget;
    console.log('handleHrefClick - Event target:', target);
    const href = target.getAttribute('data-href');
    console.log('handleHrefClick - Extracted href:', href);
    console.log('handleHrefClick - Options provided:', JSON.stringify(options));
    if (!href) {
        console.warn('handleHrefClick - No href attribute found - Target:', target);
        return;
    }

    showLoadingOverlay();
    try {
        console.log('handleHrefClick - Initiating fetch for protected page - Href:', href);
        const startTime = Date.now();
        const html = await fetchProtectedPage(href);
        const duration = Date.now() - startTime;
        if (!html) {
            console.error('handleHrefClick - No HTML returned - Href:', href);
            return;
        }
        console.log('handleHrefClick - HTML fetched successfully - Length:', html.length, 'Duration:', `${duration}ms`);

        const { spaPaths = ['/partner'], containerSelector = '.content-container', onLoad = null } = options;
        console.log('handleHrefClick - SPA paths:', spaPaths, 'Container selector:', containerSelector);

        // Update URL for all navigations
        history.pushState({ page: href.slice(1) }, `${href} Page`, href);
        console.log('handleHrefClick - URL updated via history.pushState - New URL:', window.location.href);

        const contentContainer = document.querySelector(containerSelector);
        console.log('handleHrefClick - Content container:', contentContainer);
        if (contentContainer) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const content = doc.querySelector(containerSelector) || doc.body;
            console.log('handleHrefClick - Extracted content element:', content.tagName);
            contentContainer.innerHTML = content.innerHTML;
            console.log('handleHrefClick - Content container updated - Href:', href);
            const scripts = doc.querySelectorAll('script:not([src])');
            console.log('handleHrefClick - Found inline scripts:', scripts.length);
            scripts.forEach((script, index) => {
                if (script.innerHTML.trim()) {
                    console.log('handleHrefClick - Executing inline script', index + 1);
                    try {
                        new Function(script.innerHTML)();
                        console.log('handleHrefClick - Inline script', index + 1, 'executed successfully');
                    } catch (e) {
                        console.error('handleHrefClick - Error executing inline script', index + 1, 'Error:', e.message);
                    }
                }
            });
            // Re-initialize after content update
            const pageType = href.split('/')[1] || 'login';
            console.log('handleHrefClick - Re-initializing page - Page type:', pageType);
            initialize(pageType);
        } else {
            console.error('handleHrefClick - Content container not found - Selector:', containerSelector);
            toastr.error('Failed to update page content: container missing');
            document.body.innerHTML = html;
            console.log('handleHrefClick - Body updated with full HTML - Href:', href);
            // Re-initialize after full body update
            const pageType = href.split('/')[1] || 'login';
            console.log('handleHrefClick - Re-initializing page after full update - Page type:', pageType);
            initialize(pageType);
        }

        if (typeof onLoad === 'function') {
            console.log('handleHrefClick - Executing onLoad callback - Href:', href);
            onLoad(href, html);
        }
    } catch (error) {
        console.error('handleHrefClick - Error handling href click - Href:', href, 'Error:', error.message);
        toastr.error('Navigation failed: ' + error.message);
    } finally {
        await hideLoadingOverlay();
    }
    console.log('handleHrefClick - Event handling completed');
}

// Initialize on DOM load (fallback, though fetchProtectedPage should handle it)
document.addEventListener('DOMContentLoaded', () => {
    console.log('DOMContentLoaded - Starting initialization');
    const pageType = window.location.pathname.split('/')[1] || 'login';
    console.log('DOMContentLoaded - Determined page type:', pageType);
    initialize(pageType);
});

// Common initialize function handling page-specific setup based on page type.
async function initialize(pageType) {
    console.log('initialize - Starting page initialization - Page type:', pageType);
    
    showLoadingOverlay();

    const pageConfigs = {
        'partner': {
            permissions: ["wixpro", "admin"],
            brandingType: 'partner',
            initialSection: null,
            requiresUserId: false,
            extraSteps: () => {
                console.log('initialize - Executing partner-specific steps');
                attachEventListeners();
                console.log('initialize - Partner-specific steps completed');
            }
        },
        'merchant': {
            permissions: ["merchant", "admin"],
            brandingType: 'merchant',
            initialSection: 'info',
            requiresUserId: true,
            extraSteps: () => {
                console.log('initialize - Executing merchant-specific steps');
                const userId = localStorage.getItem('userId');
                console.log('initialize - Retrieved userId from localStorage:', userId || 'None');
                if (userId) {
                    console.log('initialize - Setting userId in DOM - ID:', userId);
                    document.getElementById('userId').value = userId;
                } else {
                    console.warn('initialize - No userId found for merchant - Proceeding without setting');
                }                
                attachEventListeners();
                console.log('initialize - Merchant-specific steps completed');
            }
        },
        'community': {
            permissions: ["community", "admin"],
            brandingType: 'community',
            initialSection: 'welcome',
            requiresUserId: true,
            extraSteps: () => {
                console.log('initialize - Executing community-specific steps');
                const userId = localStorage.getItem('userId');
                console.log('initialize - Retrieved userId from localStorage:', userId || 'None');
                if (!userId) {
                    console.warn('initialize - User ID not found for community - Redirecting to /');
                    toastr.error('User ID not found in session');
                    window.location.href = '/';
                    return;
                }
                console.log('initialize - Setting userId in DOM - ID:', userId);
                document.getElementById('userId').value = userId;
                updateMenu();
                waitForTinyMCE(initializeTinyMCE);
                attachEventListeners();
                console.log('initialize - Community-specific steps completed');
            }
        },
        'admin': {
            permissions: ["admin"],
            brandingType: 'admin',
            initialSection: 'welcome',
            requiresUserId: false,
            extraSteps: () => {
                console.log('initialize - Executing admin-specific steps');
                attachEventListeners();
                console.log('initialize - Admin-specific steps completed');
            }
        },
        'login': {
            permissions: [],
            brandingType: 'login',
            initialSection: null,
            requiresUserId: false,
            extraSteps: () => {
                console.log('initialize - Executing login-specific steps');
                console.log('initialize - Login-specific steps completed');
            }
        },
        'signup': {
            permissions: [],
            brandingType: 'signup',
            initialSection: null,
            requiresUserId: false,
            extraSteps: () => {
                console.log('initialize - Executing signup-specific steps');
                console.log('initialize - Signup-specific steps completed');
            }
        }
    };

    const config = pageConfigs[pageType];
    if (!config) {
        console.error('initialize - Invalid page type provided - Type:', pageType);
        toastr.error('Invalid page type');
        await hideLoadingOverlay();
        return;
    }
    console.log('initialize - Configuration loaded for page type:', pageType, 'Config:', JSON.stringify(config));

    if (config.permissions && config.permissions.length > 0) {
        console.log('initialize - Performing permission check for:', config.permissions);
        initializePage(config.permissions, async () => {
            console.log('initialize - Permission validated for:', config.permissions);
            await performPageSetup(pageType, config);
            await hideLoadingOverlay();
        });
    } else {
        console.log('initialize - No permissions required for:', pageType);
        await performPageSetup(pageType, config);
        await hideLoadingOverlay();
    }
    console.log('initialize - Initialization process completed for:', pageType);
}

// Attach initialize to the window object to ensure it's globally available
window.initialize = initialize;
partner-page.js
// partner-page.js
// Purpose: Manages page-specific functionality for the /partner page.

// Initializes the partner page with permission checks.
function initializePartner() {
    console.log('initializePartner - Initializing partner page');
    const token = localStorage.getItem('authToken');
    const userId = localStorage.getItem('userId');
    if (!token) {
        console.error('initializePartner - No token found, redirecting to /');
        window.location.href = '/';
        return;
    }
    const decoded = decodeJWT(token);
    if (!decoded) {
        console.error('initializePartner - Invalid token, redirecting to /');
        window.location.href = '/';
        return;
    }
    window.userPermissions = decoded.permissions || [];
    if (!window.userPermissions.includes('wixpro') && !window.userPermissions.includes('admin')) {
        toastr.error('Permission denied: WixPro or Admin permission required');
        console.error('initializePartner - No wixpro/admin permission, redirecting to /');
        window.location.href = '/';
        return;
    }
    const userIdInput = document.getElementById('userId');
    if (userIdInput && userId) {
        userIdInput.value = userId;
    } else if (!userId) {
        console.warn('initializePartner - No userId found in localStorage');
    } else {
        console.warn('initializePartner - userId input element not found');
    }

    // Set up navigation and load initial content
    setupNavigation(); // From site-navigation.js
    checkAdminPermission();
    loadBranding('partner', 'brandingContent'); // Adjusted to match typical usage
    showSection('welcome');
    loadPartnerIntegrations(); // Load partner-specific integrations
    attachEventListeners(); // From page-load.js

    // Call shared "Change Password" logic
    if (typeof setupChangePassword === 'function') {
        setupChangePassword(); // From user-management.js
        console.log('initializePartner - Change Password logic initialized');
    } else {
        console.error('initializePartner - setupChangePassword function not found');
    }

    // Hide loading overlay after initialization
    hideLoadingOverlay(); // From page-load.js
    console.log('initializePartner - Partner page initialized successfully');
}

// Checks and toggles visibility of admin-specific elements.
function checkAdminPermission() {
    console.log('checkAdminPermission - Checking admin permission');
    const backButton = document.querySelector('button[data-href="/admin"]');
    if (backButton) {
        backButton.style.display = window.userPermissions.includes('admin') ? 'block' : 'none';
        console.log('checkAdminPermission - Back button visibility:', backButton.style.display);
    } else {
        console.warn('checkAdminPermission - Back button not found');
    }
}

// Loads and displays partner-specific integrations or tests.
async function loadPartnerIntegrations() {
    console.log('loadPartnerIntegrations - Loading partner integrations');
    const userId = document.getElementById('userId') ? document.getElementById('userId').value : '';
    if (!userId) {
        console.error('loadPartnerIntegrations - User ID not found in session');
        toastr.error('User ID not found in session');
        return;
    }
    try {
        console.log('loadPartnerIntegrations - Fetching integrations - URL:', `${window.apiUrl}/${userId}/integrations`);
        const response = await authenticatedFetch(`${window.apiUrl}/${userId}/integrations`);
        if (!response.ok) throw new Error(`Failed to fetch integrations: ${response.status}`);
        const data = await response.json();
        console.log('loadPartnerIntegrations - Integrations fetched - Data:', JSON.stringify(data));

        const integrationList = document.getElementById('integrationList');
        if (integrationList) {
            integrationList.innerHTML = '';
            data.integrations.forEach(integration => {
                const li = document.createElement('li');
                li.textContent = `${integration.name} - Status: ${integration.status}`;
                integrationList.appendChild(li);
            });
            console.log('loadPartnerIntegrations - Integration list updated - Count:', data.integrations.length);
        } else {
            console.warn('loadPartnerIntegrations - Integration list element not found');
        }
    } catch (error) {
        console.error('loadPartnerIntegrations - Error loading integrations - Error:', error.message, 'Stack:', error.stack);
        toastr.error(`Error loading integrations: ${error.message}`);
    }
}

// Export for use in other scripts
window.initializePartner = initializePartner;
window.checkAdminPermission = checkAdminPermission;
window.loadPartnerIntegrations = loadPartnerIntegrations;
site-auth.js
// site-auth.js
// Purpose: Manages authentication-related functionality, including password visibility toggling, 
// user logout, JWT token decoding, and password saving for user management.

// Toggles the visibility of a password input field, updating associated icon.
function togglePassword(fieldId) {
    console.log('togglePassword - Initiating visibility toggle - Field ID:', fieldId);
    const input = document.getElementById(fieldId);
    const icon = input ? input.nextElementSibling : null;
    console.log('togglePassword - Input element retrieved:', input, 'Icon element:', icon);

    if (!input) {
        console.error('togglePassword - Password input not found - Field ID:', fieldId);
        return;
    }
    if (!icon) {
        console.error('togglePassword - Icon element not found for input - Field ID:', fieldId);
        return;
    }

    const isPassword = input.type === 'password';
    console.log('togglePassword - Current input type:', input.type);
    if (isPassword) {
        input.type = 'text';
        icon.classList.remove('fa-eye');
        icon.classList.add('fa-eye-slash');
        console.log('togglePassword - Changed to text visibility - Field ID:', fieldId);
    } else {
        input.type = 'password';
        icon.classList.remove('fa-eye-slash');
        icon.classList.add('fa-eye');
        console.log('togglePassword - Changed to password visibility - Field ID:', fieldId);
    }
    console.log('togglePassword - Toggle completed - New type:', input.type);
}

// Logs the user out, clearing session data and redirecting to home.
function logOff() {
    console.log('logOff - Initiating logout process');
    const confirmed = confirm('Are you sure you want to log off?');
    console.log('logOff - User confirmation received:', confirmed);

    if (confirmed) {
        console.log('logOff - User confirmed logout - Clearing session data');
        localStorage.removeItem('authToken');
        localStorage.removeItem('userId');
        console.log('logOff - Auth token and userId removed from localStorage - Current localStorage:', JSON.stringify(localStorage));
        toastr.success('Logged off successfully');
        console.log('logOff - Success toast displayed');

        setTimeout(() => {
            console.log('logOff - Redirecting to / after 1-second delay');
            window.location.href = '/';
            console.log('logOff - Redirect executed');
        }, 1000);
    } else {
        console.log('logOff - Logout cancelled by user');
    }
    console.log('logOff - Logout process completed');
}

// Decodes a JWT token to extract user data, such as permissions.
function decodeJWT(token) {
    console.log('decodeJWT - Starting JWT decoding - Input token:', token);
    if (!token || typeof token !== 'string') {
        console.warn('decodeJWT - Invalid token: null or not a string - Token:', token);
        return null;
    }
    if (!token.match(/^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+$/)) {
        console.warn('decodeJWT - Token does not match JWT format - Token:', token);
        return null;
    }
    console.log('decodeJWT - Token format validated - Proceeding with decode');

    const parts = token.split('.');
    console.log('decodeJWT - Token split into parts:', parts);

    try {
        const base64Url = parts[1];
        console.log('decodeJWT - Extracted base64Url from token:', base64Url);
        const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
        console.log('decodeJWT - Converted to base64:', base64);
        const jsonPayload = decodeURIComponent(atob(base64).split('').map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));
        console.log('decodeJWT - Decoded JSON payload:', jsonPayload);
        const decoded = JSON.parse(jsonPayload);
        console.log('decodeJWT - Parsed JWT payload:', JSON.stringify(decoded));
        return decoded;
    } catch (error) {
        console.error('decodeJWT - Error decoding JWT - Error:', error.message, 'Stack:', error.stack, 'Token:', token);
        return null;
    }
}

// Saves an updated user password via an authenticated request.
async function savePassword(newPassword) {
    console.log('savePassword - Starting password save - New password length:', newPassword ? newPassword.length : 'None');
    if (!newPassword || typeof newPassword !== 'string') {
        console.error('savePassword - Invalid password provided - Password:', newPassword);
        toastr.error('Invalid password provided');
        return;
    }

    try {
        console.log('savePassword - Sending password update via authenticatedFetch');
        const startTime = Date.now();
        const response = await authenticatedFetch('/update-password', { // Assumes endpoint exists
            method: 'POST',
            body: JSON.stringify({ password: newPassword })
        });
        const duration = Date.now() - startTime;

        if (!response) {
            console.error('savePassword - No response from fetch');
            toastr.error('Failed to save password: No server response');
            return;
        }

        console.log('savePassword - Response received - Status:', response.status, 'Duration:', `${duration}ms`);
        const result = await response.json();
        console.log('savePassword - Save response data:', JSON.stringify(result));

        if (result.status === 'success') {
            console.log('savePassword - Password saved successfully');
            toastr.success('Password updated successfully');
        } else {
            console.error('savePassword - Server reported failure - Message:', result.message);
            toastr.error(result.message || 'Failed to save password');
        }
    } catch (error) {
        console.error('savePassword - Error saving password - Error:', error.message, 'Stack:', error.stack);
        toastr.error('Failed to save password: ' + error.message);
    }
    console.log('savePassword - Password save process completed');
}
site-navigation.js
// site-navigation.js
// Purpose: Handles navigation, content loading, branding, and section/submenu management across the site.

// Check if window.apiUrl is defined, throw an error if not
if (!window.apiUrl) {
    console.error('site-navigation.js - window.apiUrl is not defined. Please set window.apiUrl before loading this script.');
    throw new Error('window.apiUrl is not defined');
}
console.log('site-navigation.js - Using apiUrl:', window.apiUrl);

// Performs authenticated fetch requests for protected resources
async function authenticatedFetch(url, options = {}) {
    console.log('authenticatedFetch - Initiating fetch - URL:', url);
    const token = localStorage.getItem('authToken');
    if (!token) {
        console.warn('authenticatedFetch - No authentication token found - Redirecting to /');
        toastr.error('No authentication token found. Please log in.');
        window.location.href = '/';
        return null;
    }
    const headers = {
        ...options.headers,
        'Authorization': `Bearer ${token}`,
        'Content-Type': options.body instanceof FormData ? undefined : 'application/json'
    };
    const fetchUrl = `${url}${url.includes('?') ? '&' : '?'}t=${Date.now()}`;
    try {
        const response = await fetch(fetchUrl, { ...options, headers });
        if (!response.ok) {
            const errorText = await response.text();
            console.error('authenticatedFetch - Fetch failed - Status:', response.status, 'Error text:', errorText);
            throw new Error(`Server returned ${response.status}: ${errorText}`);
        }
        if (response.status === 401) {
            console.warn('authenticatedFetch - Unauthorized response (401) - Clearing token and redirecting to /');
            toastr.error('Session expired. Please log in again.');
            localStorage.removeItem('authToken');
            localStorage.removeItem('userId');
            window.location.href = '/';
            return null;
        }
        return response;
    } catch (error) {
        console.error('authenticatedFetch - Error during fetch:', error.message);
        toastr.error(error.message || 'Failed to connect to server');
        return null;
    }
}

// Fetches protected page content for navigation
async function fetchProtectedPage(url, targetContainer = null) {
    const token = localStorage.getItem('authToken');
    if (!token) {
        toastr.error('No authentication token found. Please log in.');
        showLogin(); // Assumes showLogin is defined elsewhere
        return;
    }
    const overlay = showLoadingOverlay(); // Assumes showLoadingOverlay is defined
    try {
        const response = await authenticatedFetch(`${window.apiUrl}${url}`, {
            method: 'GET',
            headers: { 'Accept': 'text/html' }
        });
        if (!response) throw new Error('No response from server');
        const html = await response.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const scripts = doc.querySelectorAll('script');
        scripts.forEach(script => script.remove());

        if (targetContainer) {
            const container = document.querySelector(targetContainer);
            if (!container) throw new Error(`Target container not found: ${targetContainer}`);
            const newContent = doc.querySelector('.content-wrapper') || doc.body;
            container.innerHTML = newContent.innerHTML;

            await Promise.all([...scripts].map(script => {
                if (script.src) {
                    return new Promise(resolve => {
                        const newScript = document.createElement('script');
                        newScript.src = script.src;
                        newScript.async = false;
                        newScript.onload = resolve;
                        newScript.onerror = () => console.error(`Failed to load script: ${script.src}`);
                        document.head.appendChild(newScript);
                    });
                } else if (script.innerHTML.trim()) {
                    new Function(script.innerHTML)();
                }
            }));

            if (typeof window.initialize === 'function') {
                const pageType = url.split('/')[1] || 'admin';
                window.initialize(pageType);
            }
            initializeNavigation();
            setTimeout(() => hideLoadingOverlay(), 500); // Assumes hideLoadingOverlay is defined
            return html;
        } else {
            document.documentElement.innerHTML = doc.documentElement.innerHTML;
            setTimeout(() => hideLoadingOverlay(), 1000);
            return html;
        }
    } catch (error) {
        console.error('fetchProtectedPage - Error:', error);
        toastr.error(error.message || 'Failed to load protected page');
        hideLoadingOverlay();
    }
}

// Loads page-specific branding content
async function loadBranding(brandingType, containerId = 'brandingContent') {
    console.log('loadBranding - Starting branding load - Type:', brandingType, 'Container ID:', containerId);
    const defaultContents = {
        'partner': '<h1>Partner Dashboard</h1>',
        'merchant': '<h1>Merchant Dashboard</h1>',
        'community': '<h1>Community Dashboard</h1>',
        'admin': '<h1>Admin Dashboard</h1>',
        'login': '<h1>Login</h1>',
        'signup': '<h1>Signup</h1>'
    };
    const defaultContent = defaultContents[brandingType] || '<h1>Dashboard</h1>';
    const container = document.getElementById(containerId);
    if (!container) {
        console.error('loadBranding - Container not found - ID:', containerId);
        return;
    }
    try {
        const response = await authenticatedFetch(`${window.apiUrl}/branding?type=${encodeURIComponent(brandingType)}`);
        if (!response) {
            container.innerHTML = defaultContent;
            return;
        }
        const data = await response.json();
        if (data.status === 'success' && data.branding) {
            container.innerHTML = data.branding;
        } else {
            container.innerHTML = defaultContent;
        }
    } catch (error) {
        console.error('loadBranding - Error:', error.message);
        toastr.error(`Error loading ${brandingType} branding: ${error.message}`);
        container.innerHTML = defaultContent;
    }
}

// Loads content for a specific section
async function loadSection(sectionId) {
    console.log('loadSection - Starting section load - Section ID:', sectionId);
    // Example stub; expand with actual logic from your app
    if (sectionId === 'deal_listings') {
        await loadCategories(); // Assumes loadCategories is defined elsewhere
    } else if (sectionId === 'merchants') {
        await loadMerchants(); // Assumes loadMerchants is defined elsewhere
    } else {
        try {
            const response = await authenticatedFetch(`${window.apiUrl}/config`);
            if (!response) throw new Error('No response from fetch');
            const data = await response.json();
            const config = data.config[sectionId] || {};
            // Populate section-specific fields (stubbed example)
            const el = document.getElementById(`${sectionId}Field`);
            if (el) el.value = config.value || '';
        } catch (error) {
            console.error('loadSection - Error:', error.message);
            toastr.error(`Error loading ${sectionId}: ${error.message}`);
        }
    }
}

// Function to show a section and hide others
function showSection(sectionId, onSectionLoad = null) {
    console.log('showSection - Starting section display - Section ID:', sectionId);
    const allSections = document.querySelectorAll('.section');
    allSections.forEach(s => {
        s.classList.remove('active');
        s.style.display = 'none';
    });
    const section = document.getElementById(sectionId);
    if (section) {
        section.style.display = 'block';
        section.classList.add('active');
        if (typeof onSectionLoad === 'function') {
            console.log('showSection - Executing callback for:', sectionId);
            onSectionLoad(sectionId);
        } else {
            loadSection(sectionId); // Default to loadSection if no callback
        }
    } else {
        console.error('showSection - Section not found - ID:', sectionId);
    }
}

// Function to toggle a submenu
function toggleSubmenu(submenuId) {
    console.log(`toggleSubmenu - Starting toggle - Submenu ID: ${submenuId}`);
    const submenu = document.getElementById(submenuId);
    const button = document.querySelector(`button[data-submenu="${submenuId}"]`);
    const caret = button ? button.querySelector('.caret') : null;
    if (submenu && button && caret) {
        const isOpen = submenu.classList.contains('open'); // Use class as source of truth
        submenu.classList.toggle('open', !isOpen);
        submenu.style.display = isOpen ? 'none' : 'block'; // Sync display with class
        caret.classList.toggle('fa-caret-down', !isOpen);
        caret.classList.toggle('fa-caret-right', isOpen);
        button.setAttribute('aria-expanded', !isOpen);
        console.log(`toggleSubmenu - Submenu ${submenuId} set to ${isOpen ? 'closed' : 'open'}`, {
            display: submenu.style.display,
            className: submenu.className
        });
    } else {
        console.error(`toggleSubmenu - Submenu or button not found - Submenu ID: ${submenuId}`);
    }
}

// Function to handle clicks on navigation buttons
function handleSectionClick(event) {
    const target = event.target.closest('button[data-section], button[data-submenu]');
    if (!target) return;
    event.stopPropagation();
    event.preventDefault();
    const sectionId = target.getAttribute('data-section');
    const submenuId = target.getAttribute('data-submenu');
    console.log('handleSectionClick - Clicked:', { sectionId, submenuId });

    // Debug: Log all top-level submenu buttons
    const topLevelButtons = document.querySelectorAll('.menu > button[data-submenu]');
    console.log('handleSectionClick - Found top-level submenu buttons:', topLevelButtons.length);
    topLevelButtons.forEach(button => {
        const otherSubmenuId = button.getAttribute('data-submenu');
        console.log(`handleSectionClick - Top-level button: ${otherSubmenuId}`);
    });

    // Close all other top-level submenus
    topLevelButtons.forEach(button => {
        const otherSubmenuId = button.getAttribute('data-submenu');
        if (submenuId && otherSubmenuId === submenuId) return;
        const otherSubmenu = document.getElementById(otherSubmenuId);
        if (otherSubmenu && otherSubmenu.classList.contains('open')) {
            console.log(`handleSectionClick - Closing other submenu: ${otherSubmenuId}`);
            toggleSubmenu(otherSubmenuId);
        }
    });

    if (submenuId === 'my-account-submenu') {
        showSection('my-account');
        toggleSubmenu(submenuId);
    } else if (submenuId) {
        toggleSubmenu(submenuId);
        if (sectionId) showSection(sectionId);
    } else if (sectionId) {
        showSection(sectionId);
    }
}

// Ensure toggleSubmenu uses class-based visibility for CSS control
function toggleSubmenu(submenuId) {
    console.log(`toggleSubmenu - Starting toggle - Submenu ID: ${submenuId}`);
    const submenu = document.getElementById(submenuId);
    const button = document.querySelector(`button[data-submenu="${submenuId}"]`);
    const caret = button ? button.querySelector('.caret') : null;
    if (submenu && button && caret) {
        const isOpen = submenu.classList.contains('open'); // Use class as source of truth
        submenu.classList.toggle('open', !isOpen);
        submenu.style.display = isOpen ? 'none' : 'block'; // Sync display with class
        caret.classList.toggle('fa-caret-down', !isOpen);
        caret.classList.toggle('fa-caret-right', isOpen);
        button.setAttribute('aria-expanded', !isOpen);
        const computedStyle = window.getComputedStyle(submenu);
        console.log(`toggleSubmenu - Submenu ${submenuId} set to ${isOpen ? 'closed' : 'open'}`, {
            inlineDisplay: submenu.style.display,
            computedDisplay: computedStyle.display,
            height: computedStyle.height,
            maxHeight: computedStyle.maxHeight,
            className: submenu.className
        });
    } else {
        console.error(`toggleSubmenu - Submenu or button not found - Submenu ID: ${submenuId}`);
    }
}

// Main function to initialize navigation
function initializeNavigation() {
    console.log('initializeNavigation - Starting navigation setup');
    document.querySelectorAll('.submenu').forEach(submenu => {
        submenu.style.display = 'none';
        submenu.classList.remove('open');
        const submenuId = submenu.id;
        const button = document.querySelector(`button[data-submenu="${submenuId}"]`);
        if (button) {
            button.setAttribute('aria-expanded', 'false');
            const caret = button.querySelector('.caret');
            if (caret) {
                caret.classList.remove('fa-caret-down');
                caret.classList.add('fa-caret-right');
            }
        }
    });
    document.querySelectorAll('.menu button[data-section], .menu button[data-submenu]').forEach(button => {
        button.addEventListener('click', handleSectionClick);
        console.log('initializeNavigation - Added click listener to button:', button.dataset.section || button.dataset.submenu);
    });

    document.querySelectorAll('button[data-href]').forEach(button => {
        button.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const href = button.getAttribute('data-href');
            await fetchProtectedPage(href, '.content-wrapper');
            const pageType = href.split('/')[1] || 'admin';
            await loadBranding(pageType);
        });
    });
}

// Export navigation functions under a namespace
window.siteNavigation = {
    showSection,
    toggleSubmenu,
    initializeNavigation,
    authenticatedFetch,
    fetchProtectedPage,
    loadBranding,
    loadSection
};

// Initialize navigation based on document readiness
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        console.log('DOMContentLoaded - Initializing navigation');
        initializeNavigation();
    });
} else {
    console.log('Document already loaded - Initializing navigation immediately');
    initializeNavigation();
}
site-request.js
// site-request.js
// Purpose: Manages site request functionality for merchants and communities (e.g., merchant.html, community.html), 
// including page/email management, domain handling, and TinyMCE integration.

// Adds a page to the site request form based on type (merchant/community).
function addPage(type = 'merchant') {
    console.log('addPage - Adding page to site request - Type:', type);
    const maxPages = 5;
    let pageCount = parseInt(localStorage.getItem(`${type}PageCount`) || (type === 'merchant' ? 2 : 1));
    console.log('addPage - Current page count:', pageCount);

    if (pageCount >= maxPages) {
        console.warn('addPage - Maximum pages reached - Max:', maxPages);
        toastr.error(`Maximum of ${maxPages} pages allowed`);
        return;
    }

    pageCount++;
    console.log('addPage - Incrementing page count to:', pageCount);
    localStorage.setItem(`${type}PageCount`, pageCount);

    const container = document.getElementById('pagesContainer');
    console.log('addPage - Pages container:', container);
    if (!container) {
        console.error('addPage - Pages container not found');
        return;
    }

    const pageDiv = document.createElement('div');
    pageDiv.className = 'page-section';
    pageDiv.dataset.page = pageCount;
    const isMerchantDefault = type === 'merchant' && pageCount <= 2;
    const pageName = isMerchantDefault ? (pageCount === 1 ? 'Home' : 'Returns Policy') : '';
    pageDiv.innerHTML = `
        <label for="page${pageCount}Name">Page Name:</label>
        <input type="text" id="page${pageCount}Name" name="page${pageCount}Name" value="${pageName}" ${isMerchantDefault ? 'readonly' : ''} placeholder="e.g., ${type === 'merchant' ? 'Products' : 'Events'}">
        <br><br>
        <label for="page${pageCount}Content">${isMerchantDefault ? (pageCount === 1 ? 'Home Page' : 'Returns Policy') : 'Page'} Content:</label>
        <textarea id="page${pageCount}Content" name="page${pageCount}Content" placeholder="Describe this page"></textarea>
        <label for="page${pageCount}Images">Additional Images:</label>
        <input type="file" id="page${pageCount}Images" name="page${pageCount}Images" accept="image/*" multiple>
        ${pageCount > (type === 'merchant' ? 2 : 1) ? `<button type="button" class="remove-page-btn" data-page="${pageCount}">Remove Page</button>` : ''}
    `;
    container.appendChild(pageDiv);
    console.log('addPage - New page section added - Page number:', pageCount);

    tinymce.remove(`#page${pageCount}Content`);
    initializeTinyMCE(`#page${pageCount}Content`);
    console.log('addPage - TinyMCE initialized for new page');
    console.log('addPage - Page addition completed');
}

// Removes a page from the site request form based on type (merchant/community).
function removePage(pageNum, type = 'merchant') {
    console.log('removePage - Removing page - Page number:', pageNum, 'Type:', type);
    let pageCount = parseInt(localStorage.getItem(`${type}PageCount`) || (type === 'merchant' ? 2 : 1));
    console.log('removePage - Current page count:', pageCount);
    const minPages = type === 'merchant' ? 2 : 1;

    if (pageCount <= minPages) {
        console.warn('removePage - Cannot remove below minimum pages - Min:', minPages);
        toastr.error(`Cannot remove the last ${type === 'merchant' ? 'Home or Returns Policy' : ''} page${minPages > 1 ? 's' : ''}`);
        return;
    }

    const pageSection = document.querySelector(`.page-section[data-page="${pageNum}"]`);
    console.log('removePage - Page section to remove:', pageSection);
    if (pageSection) {
        tinymce.get(`page${pageNum}Content`)?.remove();
        console.log('removePage - Removed TinyMCE instance for page:', pageNum);
        pageSection.remove();
        pageCount--;
        localStorage.setItem(`${type}PageCount`, pageCount);
        console.log('removePage - Page removed, new page count:', pageCount);
    } else {
        console.error('removePage - Page section not found - Page number:', pageNum);
    }
    console.log('removePage - Removal completed');
}

// Adds an email to the site request form.
function addEmail(type = 'merchant') {
    console.log('addEmail - Adding email to site request - Type:', type);
    const maxEmails = 5;
    let emailCount = parseInt(localStorage.getItem(`${type}EmailCount`) || 1);
    console.log('addEmail - Current email count:', emailCount);

    if (emailCount >= maxEmails) {
        console.warn('addEmail - Maximum emails reached - Max:', maxEmails);
        toastr.error(`Maximum of ${maxEmails} email addresses allowed`);
        return;
    }

    emailCount++;
    console.log('addEmail - Incrementing email count to:', emailCount);
    localStorage.setItem(`${type}EmailCount`, emailCount);

    const container = document.getElementById('emailsContainer');
    console.log('addEmail - Emails container:', container);
    if (!container) {
        console.error('addEmail - Emails container not found');
        return;
    }

    const domain = document.getElementById('preferredDomain')?.value || (type === 'merchant' ? 'mystore.uk' : 'mycommunity.org');
    console.log('addEmail - Using domain:', domain);
    const emailDiv = document.createElement('div');
    emailDiv.className = 'email-section';
    emailDiv.dataset.email = emailCount;
    emailDiv.innerHTML = `
        <label for="email${emailCount}Name">Email Name:</label>
        <input type="text" id="email${emailCount}Name" name="email${emailCount}Name" placeholder="e.g., contact">
        <span id="email${emailCount}Domain">@${domain}</span>
        <button type="button" class="remove-email-btn" data-email="${emailCount}">Remove Email</button>
    `;
    container.appendChild(emailDiv);
    console.log('addEmail - New email section added - Email number:', emailCount);

    updateDomainPreview(type);
    console.log('addEmail - Email addition completed');
}

// Removes an email from the site request form.
function removeEmail(emailNum, type = 'merchant') {
    console.log('removeEmail - Removing email - Email number:', emailNum, 'Type:', type);
    let emailCount = parseInt(localStorage.getItem(`${type}EmailCount`) || 1);
    console.log('removeEmail - Current email count:', emailCount);

    if (emailCount <= 1) {
        console.warn('removeEmail - Cannot remove the last email');
        toastr.error('Cannot remove the last email');
        return;
    }

    const emailSection = document.querySelector(`.email-section[data-email="${emailNum}"]`);
    console.log('removeEmail - Email section to remove:', emailSection);
    if (emailSection) {
        emailSection.remove();
        emailCount--;
        localStorage.setItem(`${type}EmailCount`, emailCount);
        console.log('removeEmail - Email removed, new email count:', emailCount);
        updateDomainPreview(type);
    } else {
        console.error('removeEmail - Email section not found - Email number:', emailNum);
    }
    console.log('removeEmail - Removal completed');
}

// Updates the domain preview and email domain spans for the site request.
function updateDomainPreview(type = 'merchant') {
    console.log('updateDomainPreview - Updating domain preview - Type:', type);
    const domain = document.getElementById('preferredDomain')?.value || (type === 'merchant' ? 'mystore.uk' : 'mycommunity.org');
    console.log('updateDomainPreview - Domain value:', domain);

    const previewElement = document.getElementById('domainPreview');
    if (previewElement) {
        previewElement.textContent = `@${domain}`;
        console.log('updateDomainPreview - Updated domain preview to:', `@${domain}`);
    }

    let emailCount = parseInt(localStorage.getItem(`${type}EmailCount`) || 1);
    console.log('updateDomainPreview - Email count:', emailCount);
    for (let i = 1; i <= emailCount; i++) {
        const domainSpan = document.getElementById(`email${i}Domain`);
        console.log('updateDomainPreview - Checking domain span - ID:', `email${i}Domain`, 'Element:', domainSpan);
        if (domainSpan) {
            domainSpan.textContent = `@${domain}`;
            console.log('updateDomainPreview - Updated email domain - ID:', `email${i}Domain`, 'to:', `@${domain}`);
        }
    }
    console.log('updateDomainPreview - Update completed');
}

// Checks domain availability for the site request.
async function checkDomainAvailability() {
    console.log('checkDomainAvailability - Starting domain availability check');
    const domainInput = document.getElementById('preferredDomain');
    const domain = domainInput?.value;
    console.log('checkDomainAvailability - Domain to check:', domain);

    const domainRegex = /^[a-zA-Z0-9-]+\.[a-zA-Z]{2,}$/;
    if (!domain) {
        console.warn('checkDomainAvailability - No domain provided');
        toastr.error('Please enter a preferred domain name');
        return false;
    }
    if (!domainRegex.test(domain)) {
        console.warn('checkDomainAvailability - Invalid domain format - Domain:', domain);
        toastr.error('Invalid domain name (e.g., mystore.uk)');
        return false;
    }

    console.log('checkDomainAvailability - Domain format valid, proceeding with check');
    toastr.info(`Checking availability for ${domain}...`);

    try {
        const startTime = Date.now();
        const response = await fetch(`https://clubmadeira.io/check-domain?domain=${encodeURIComponent(domain)}`, {
            method: 'GET',
            credentials: 'same-origin'
        });
        const duration = Date.now() - startTime;
        console.log('checkDomainAvailability - Fetch response received - Status:', response.status, 'Duration:', `${duration}ms`);

        if (!response.ok) {
            const errorText = await response.text();
            console.error('checkDomainAvailability - Fetch failed - Status:', response.status, 'Error text:', errorText);
            if (response.status === 403) {
                throw new Error('Permission denied - please log in');
            }
            throw new Error(`Server error: ${errorText}`);
        }

        const result = await response.json();
        console.log('checkDomainAvailability - Availability result:', JSON.stringify(result));
        if (result.available) {
            console.log('checkDomainAvailability - Domain available:', domain);
            toastr.success(`${result.domain} is available!`);
            return true;
        } else {
            console.warn('checkDomainAvailability - Domain not available:', domain);
            toastr.error(`${result.domain} is not available`);
            if (domainInput) domainInput.value = '';
            return false;
        }
    } catch (error) {
        console.error('checkDomainAvailability - Error checking domain - Error:', error.message, 'Stack:', error.stack);
        toastr.error(`Failed to check domain availability: ${error.message}`);
        return false;
    }
}

// Loads TinyMCE editor for site request content editing.
async function loadTinyMCE() {
    console.log('loadTinyMCE - Starting TinyMCE load');
    if (typeof tinymce !== 'undefined' && tinymce.init) {
        console.log('loadTinyMCE - TinyMCE already loaded');
        initializeTinyMCE();
        return;
    }

    console.log('loadTinyMCE - Loading TinyMCE script');
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdn.tiny.cloud/1/ml1wlwr128qsm8hn8d86e5mhs3y2fuvjr9ztknrsh23x6krp/tinymce/5/tinymce.min.js';
        script.referrerpolicy = 'origin';
        document.head.appendChild(script);
        console.log('loadTinyMCE - Script element added to head:', script.src);

        script.onload = () => {
            console.log('loadTinyMCE - TinyMCE script loaded successfully');
            initializeTinyMCE();
            resolve();
        };
        script.onerror = () => {
            console.error('loadTinyMCE - Failed to load TinyMCE script');
            toastr.error('Failed to load rich text editor');
            reject(new Error('TinyMCE load failed'));
        };
    });
}

// Initializes TinyMCE editor for site request content editing with a specific selector.
function initializeTinyMCE(selector = 'textarea[name$="Content"], #aboutStore, #aboutCommunity') {
    console.log('initializeTinyMCE - Starting TinyMCE initialization - Selector:', selector);
    if (!window.tinymce) {
        console.error('initializeTinyMCE - TinyMCE not available');
        return;
    }

    tinymce.remove(selector);
    console.log('initializeTinyMCE - Removed existing TinyMCE instances for selector:', selector);

    tinymce.init({
        selector: selector,
        height: 200,
        menubar: false,
        plugins: 'lists',
        toolbar: 'bold italic | bullist numlist',
        setup: editor => {
            editor.on('init', () => {
                console.log('initializeTinyMCE - TinyMCE editor initialized for:', editor.id);
            });
        }
    });
    console.log('initializeTinyMCE - TinyMCE initialization completed');
}

// Generates a formatted timestamp for site request forms.
function getCurrentTimestamp() {
    console.log('getCurrentTimestamp - Generating current timestamp');
    const now = new Date();
    console.log('getCurrentTimestamp - Current date object:', now);
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const seconds = String(now.getSeconds()).padStart(2, '0');
    console.log('getCurrentTimestamp - Extracted components - Year:', year, 'Month:', month, 'Day:', day, 'Hours:', hours, 'Minutes:', minutes, 'Seconds:', seconds);
    const timestamp = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    console.log('getCurrentTimestamp - Generated timestamp:', timestamp);
    return timestamp;
}

// Saves the site request form data for either a merchant store or community site.
async function saveSiteRequest(type = 'merchant') {
    console.log('saveSiteRequest - Starting site request save - Type:', type);
    const userId = document.getElementById('userId')?.value || localStorage.getItem('userId');
    console.log('saveSiteRequest - Retrieved userId:', userId);

    if (!userId) {
        console.error('saveSiteRequest - User ID not found in session or DOM');
        toastr.error('User ID not found in session');
        return;
    }

    const nameField = type === 'merchant' ? 'storeName' : 'communityName';
    const aboutField = type === 'merchant' ? 'aboutStore' : 'aboutCommunity';
    const logoField = type === 'merchant' ? 'storeLogos' : 'communityLogos';
    const defaultDomain = type === 'merchant' ? 'mystore.uk' : 'mycommunity.org';

    const siteRequest = {
        userId: userId,
        type: type,
        [nameField]: document.getElementById(nameField)?.value.trim() || '',
        [aboutField]: tinymce.get(aboutField)?.getContent() || document.getElementById(aboutField)?.value || '',
        [logoField]: [],
        colorPrefs: document.getElementById('colorPrefs')?.value.trim() || '',
        stylingDetails: document.getElementById('stylingDetails')?.value.trim() || '',
        preferredDomain: document.getElementById('preferredDomain')?.value.trim() || defaultDomain,
        emails: [],
        pages: [],
        widgets: Array.from(document.querySelectorAll('input[name="widgets"]:checked')).map(cb => cb.value)
    };
    console.log('saveSiteRequest - Initial site request object:', JSON.stringify(siteRequest));

    // Validation
    if (!siteRequest[nameField]) {
        console.warn('saveSiteRequest - Name field is empty - Field:', nameField);
        toastr.error(`${type === 'merchant' ? 'Store' : 'Community'} name is required`);
        return;
    }

    const domainRegex = /^[a-zA-Z0-9-]+\.[a-zA-Z]{2,}$/;
    if (!domainRegex.test(siteRequest.preferredDomain)) {
        console.warn('saveSiteRequest - Invalid domain format - Domain:', siteRequest.preferredDomain);
        toastr.error(`Invalid domain name (e.g., ${defaultDomain})`);
        return;
    }

    // Handle logos
    const logoFiles = document.getElementById(logoField)?.files || [];
    console.log('saveSiteRequest - Logo files count:', logoFiles.length);
    if (logoFiles.length > 5) {
        console.warn('saveSiteRequest - Too many logos - Count:', logoFiles.length);
        toastr.error('Maximum of 5 logos allowed');
        return;
    }
    for (let i = 0; i < logoFiles.length; i++) {
        const reader = new FileReader();
        await new Promise(resolve => {
            reader.onload = () => {
                siteRequest[logoField].push(reader.result);
                console.log('saveSiteRequest - Added logo - Index:', i, 'Result length:', reader.result.length);
                resolve();
            };
            reader.readAsDataURL(logoFiles[i]);
        });
    }

    // Collect emails
    let emailCount = parseInt(localStorage.getItem(`${type}EmailCount`) || 1);
    console.log('saveSiteRequest - Collecting emails - Email count:', emailCount);
    for (let i = 1; i <= emailCount; i++) {
        const emailInput = document.getElementById(`email${i}Name`);
        if (emailInput && emailInput.value.trim()) {
            siteRequest.emails.push(emailInput.value.trim());
            console.log('saveSiteRequest - Added email - Index:', i, 'Value:', emailInput.value.trim());
        }
    }

    // Collect pages
    let pageCount = parseInt(localStorage.getItem(`${type}PageCount`) || (type === 'merchant' ? 2 : 1));
    console.log('saveSiteRequest - Collecting pages - Page count:', pageCount);
    for (let i = 1; i <= pageCount; i++) {
        const nameInput = document.getElementById(`page${i}Name`);
        const contentEditor = tinymce.get(`page${i}Content`);
        const contentFallback = document.getElementById(`page${i}Content`);
        const imagesInput = document.getElementById(`page${i}Images`);
        if (nameInput && nameInput.value.trim()) {
            const page = {
                name: nameInput.value.trim(),
                content: contentEditor ? contentEditor.getContent() : (contentFallback?.value || ''),
                images: []
            };
            console.log('saveSiteRequest - Processing page - Index:', i, 'Name:', page.name);

            if (imagesInput && imagesInput.files.length > 0) {
                for (let j = 0; j < imagesInput.files.length; j++) {
                    const reader = new FileReader();
                    await new Promise(resolve => {
                        reader.onload = () => {
                            page.images.push(reader.result);
                            console.log('saveSiteRequest - Added image to page - Page:', i, 'Image index:', j, 'Result length:', reader.result.length);
                            resolve();
                        };
                        reader.readAsDataURL(imagesInput.files[j]);
                    });
                }
            }
            siteRequest.pages.push(page);
        }
    }

    const minPages = type === 'merchant' ? 2 : 1;
    if (siteRequest.pages.length < minPages || (type === 'merchant' && (!siteRequest.pages.some(p => p.name === 'Home') || !siteRequest.pages.some(p => p.name === 'Returns Policy')))) {
        console.warn('saveSiteRequest - Insufficient or missing required pages - Pages:', siteRequest.pages.length, 'Required:', minPages);
        toastr.error(type === 'merchant' ? 'Home and Returns Policy pages are required' : 'At least one page is required');
        return;
    }

    // Save to server
    try {
        console.log('saveSiteRequest - Sending site request to server - URL:', `${apiUrl}/${userId}/siterequest`);
        const startTime = Date.now();
        const response = await authenticatedFetch(`${apiUrl}/${userId}/siterequest`, {
            method: 'POST',
            body: JSON.stringify(siteRequest)
        });
        const duration = Date.now() - startTime;

        if (!response) {
            console.error('saveSiteRequest - No response from fetch');
            toastr.error('Failed to save site request: No server response');
            return;
        }
        if (!response.ok) {
            const errorText = await response.text();
            console.error('saveSiteRequest - Fetch failed - Status:', response.status, 'Error text:', errorText);
            throw new Error(`Failed to save site request: ${response.status} - ${errorText}`);
        }

        console.log('saveSiteRequest - Save successful - Duration:', `${duration}ms`);
        toastr.success(`${type === 'merchant' ? 'Store' : 'Site'} request saved successfully`);
    } catch (error) {
        console.error('saveSiteRequest - Error saving site request - Error:', error.message, 'Stack:', error.stack);
        toastr.error(`Error saving ${type === 'merchant' ? 'store' : 'site'} request: ${error.message}`);
    }
    console.log('saveSiteRequest - Save process completed');
}
user-management.js
// user-management.js
// Purpose: Manages user-specific settings, Wix client ID operations, and shared "Change Password" logic.

// Loads user settings into the DOM.
async function loadSettings() {
    console.log('loadSettings - Starting settings load');
    const userId = localStorage.getItem('userId');
    console.log('loadSettings - Retrieved userId:', userId);

    if (!userId) {
        console.error('loadSettings - User ID not found in session');
        toastr.error('User ID not found in session');
        return;
    }

    try {
        console.log('loadSettings - Fetching settings via authenticatedFetch - URL:', `${window.apiUrl}/${userId}/user`);
        const startTime = Date.now();
        const response = await authenticatedFetch(`${window.apiUrl}/${userId}/user`);
        const duration = Date.now() - startTime;

        if (!response.ok) {
            const errorText = await response.text();
            console.error('loadSettings - Fetch failed - Status:', response.status, 'Error:', errorText);
            throw new Error(`Failed to fetch settings: ${response.status} - ${errorText}`);
        }

        const data = await response.json();
        console.log('loadSettings - Settings fetched - Data:', JSON.stringify(data), 'Duration:', `${duration}ms`);

        // Update DOM with settings
        const referrerId = document.getElementById('referrerId');
        const contactName = document.getElementById('contactName');
        const websiteUrl = document.getElementById('websiteUrl');
        const emailAddress = document.getElementById('emailAddress');
        const phoneNumber = document.getElementById('phoneNumber');

        if (referrerId) referrerId.textContent = userId;
        if (contactName) contactName.value = data.contact_name || '';
        if (websiteUrl) websiteUrl.value = data.website_url || '';
        if (emailAddress) emailAddress.value = data.email_address || '';
        if (phoneNumber) phoneNumber.value = data.phone_number || '';

        console.log('loadSettings - DOM updated - Fields:', {
            referrerId: userId,
            contactName: data.contact_name || '',
            websiteUrl: data.website_url || '',
            emailAddress: data.email_address || '',
            phoneNumber: data.phone_number || ''
        });
    } catch (error) {
        console.error('loadSettings - Error loading settings - Error:', error.message, 'Stack:', error.stack);
        toastr.error(`Error loading settings: ${error.message}`);
    }
    console.log('loadSettings - Settings load completed');
}

// Saves user settings from the DOM.
async function saveSettings(settings) {
    console.log('saveSettings - Starting settings save - Settings:', JSON.stringify(settings));
    const userId = localStorage.getItem('userId');
    console.log('saveSettings - Retrieved userId:', userId);

    if (!userId) {
        console.error('saveSettings - User ID not found in session');
        toastr.error('User ID not found in session');
        return;
    }

    try {
        console.log('saveSettings - Sending settings via authenticatedFetch - URL:', `${window.apiUrl}/${userId}/user`);
        const startTime = Date.now();
        const response = await authenticatedFetch(`${window.apiUrl}/${userId}/user`, {
            method: 'PUT',
            body: JSON.stringify(settings)
        });
        const duration = Date.now() - startTime;

        if (!response.ok) {
            const errorText = await response.text();
            console.error('saveSettings - Fetch failed - Status:', response.status, 'Error:', errorText);
            throw new Error(`Failed to save settings: ${response.status} - ${errorText}`);
        }

        const result = await response.json();
        console.log('saveSettings - Save response received - Result:', JSON.stringify(result), 'Duration:', `${duration}ms`);
        toastr.success('Settings saved successfully');
    } catch (error) {
        console.error('saveSettings - Error saving settings - Error:', error.message, 'Stack:', error.stack);
        toastr.error(`Failed to save settings: ${error.message}`);
    }
    console.log('saveSettings - Save process completed');
}

// Loads Wix client ID into the DOM.
async function loadWixClientId() {
    console.log('loadWixClientId - Starting Wix client ID load');
    const userId = localStorage.getItem('userId');
    console.log('loadWixClientId - Retrieved userId:', userId);

    if (!userId) {
        console.error('loadWixClientId - User ID not found in session');
        toastr.error('User ID not found in session');
        return;
    }

    try {
        console.log('loadWixClientId - Fetching Wix client ID via authenticatedFetch - URL:', `${window.apiUrl}/${userId}/wix-client-id`);
        const startTime = Date.now();
        const response = await authenticatedFetch(`${window.apiUrl}/${userId}/wix-client-id`);
        const duration = Date.now() - startTime;

        if (!response.ok) {
            const errorText = await response.text();
            console.error('loadWixClientId - Fetch failed - Status:', response.status, 'Error:', errorText);
            throw new Error(`Failed to fetch Wix client ID: ${response.status} - ${errorText}`);
        }

        const data = await response.json();
        console.log('loadWixClientId - Wix client ID fetched - Data:', JSON.stringify(data), 'Duration:', `${duration}ms`);

        // Update DOM with Wix client ID
        const wixClientIdField = document.getElementById('wixClientId');
        if (wixClientIdField) {
            wixClientIdField.value = data.client_id || data.clientId || '';
            console.log('loadWixClientId - DOM updated - wixClientId:', data.client_id || data.clientId || '');
        } else {
            console.warn('loadWixClientId - Wix client ID field not found - ID: wixClientId');
        }
    } catch (error) {
        console.error('loadWixClientId - Error loading Wix client ID - Error:', error.message, 'Stack:', error.stack);
        toastr.error(`Error loading Wix client ID: ${error.message}`);
    }
    console.log('loadWixClientId - Wix client ID load completed');
}

// Saves Wix client ID from the DOM.
async function saveWixClientId(clientId) {
    console.log('saveWixClientId - Starting Wix client ID save - Client ID:', clientId);
    const userId = localStorage.getItem('userId');
    console.log('saveWixClientId - Retrieved userId:', userId);

    if (!userId) {
        console.error('saveWixClientId - User ID not found in session');
        toastr.error('User ID not found in session');
        return;
    }

    try {
        console.log('saveWixClientId - Sending Wix client ID via authenticatedFetch - URL:', `${window.apiUrl}/${userId}/wix-client-id`);
        const startTime = Date.now();
        const response = await authenticatedFetch(`${window.apiUrl}/${userId}/wix-client-id`, {
            method: 'POST',
            body: JSON.stringify({ clientId })
        });
        const duration = Date.now() - startTime;

        if (!response.ok) {
            const errorText = await response.text();
            console.error('saveWixClientId - Fetch failed - Status:', response.status, 'Error:', errorText);
            throw new Error(`Failed to save Wix client ID: ${response.status} - ${errorText}`);
        }

        const result = await response.json();
        console.log('saveWixClientId - Save response received - Result:', JSON.stringify(result), 'Duration:', `${duration}ms`);
        toastr.success('Wix client ID saved successfully');
    } catch (error) {
        console.error('saveWixClientId - Error saving Wix client ID - Error:', error.message, 'Stack:', error.stack);
        toastr.error(`Failed to save Wix client ID: ${error.message}`);
    }
    console.log('saveWixClientId - Save process completed');
}

// Validates password complexity
function validatePassword(password) {
    console.log('validatePassword - Validating password');
    const minLength = 8;
    const hasUpperCase = /[A-Z]/.test(password);
    const hasLowerCase = /[a-z]/.test(password);
    const hasNumber = /\d/.test(password);
    const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(password);

    if (password.length < minLength) {
        toastr.error('Password must be at least 8 characters long.');
        console.log('validatePassword - Failed: Length < 8');
        return false;
    }
    if (!hasUpperCase) {
        toastr.error('Password must contain at least one uppercase letter.');
        console.log('validatePassword - Failed: No uppercase');
        return false;
    }
    if (!hasLowerCase) {
        toastr.error('Password must contain at least one lowercase letter.');
        console.log('validatePassword - Failed: No lowercase');
        return false;
    }
    if (!hasNumber) {
        toastr.error('Password must contain at least one number.');
        console.log('validatePassword - Failed: No number');
        return false;
    }
    if (!hasSpecialChar) {
        toastr.error('Password must contain at least one special character.');
        console.log('validatePassword - Failed: No special character');
        return false;
    }
    console.log('validatePassword - Password valid');
    return true;
}

// Sets up the "Change Password" form submission logic
function setupChangePassword() {
    console.log('setupChangePassword - Setting up change password logic');
    const changePasswordButton = document.querySelector('button[data-action="savePassword"]');
    if (!changePasswordButton) {
        console.warn('setupChangePassword - Change password button not found');
        return;
    }

    changePasswordButton.addEventListener('click', async () => {
        console.log('setupChangePassword - Change password button clicked');
        const currentPasswordInput = document.getElementById('currentPassword');
        const newPasswordInput = document.getElementById('newPassword');
        const confirmPasswordInput = document.getElementById('confirmPassword');

        // Validate input elements exist
        if (!currentPasswordInput || !newPasswordInput || !confirmPasswordInput) {
            toastr.error('Password fields are missing on this page.');
            console.error('setupChangePassword - One or more password input elements not found');
            return;
        }

        const currentPassword = currentPasswordInput.value.trim();
        const newPassword = newPasswordInput.value.trim();
        const confirmPassword = confirmPasswordInput.value.trim();

        // Check for empty fields
        if (!currentPassword || !newPassword || !confirmPassword) {
            toastr.error('All password fields are required.');
            console.log('setupChangePassword - Empty password field detected');
            return;
        }

        // Check password match
        if (newPassword !== confirmPassword) {
            toastr.error('New password and confirmation do not match.');
            console.log('setupChangePassword - Passwords do not match');
            return;
        }

        // Validate password complexity
        if (!validatePassword(newPassword)) {
            console.log('setupChangePassword - Password complexity validation failed');
            return;
        }

        // Submit password change request
        try {
            console.log('setupChangePassword - Submitting password change request');
            const token = localStorage.getItem('authToken');
            if (!token) {
                throw new Error('No authentication token found');
            }

            const response = await authenticatedFetch(`${window.apiUrl}/update-password`, {
                method: 'POST',
                body: JSON.stringify({
                    current_password: currentPassword,
                    new_password: newPassword
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `Failed to update password: ${response.status}`);
            }

            const data = await response.json();
            console.log('setupChangePassword - Password updated successfully:', data);
            toastr.success('Password updated successfully!');
            // Clear form fields after success
            currentPasswordInput.value = '';
            newPasswordInput.value = '';
            confirmPasswordInput.value = '';
        } catch (error) {
            console.error('setupChangePassword - Error updating password:', error.message);
            toastr.error(error.message || 'An error occurred while updating the password.');
        }
    });
    console.log('setupChangePassword - Event listener attached');
}

// Export for use in other scripts
window.loadSettings = loadSettings;
window.saveSettings = saveSettings;
window.loadWixClientId = loadWixClientId;
window.saveWixClientId = saveWixClientId;
window.validatePassword = validatePassword;
window.setupChangePassword = setupChangePassword;
